# Декларативная параллельная модель

## Как понять в программировании всё

Декларативная модель позволяет создавать самые разные программы и применять весьма мощные методы их понимания и
повышения выразительности кода. Но тем не менее существуют полезные классы программ, которые не могут быть легко или
эффективно написаны в декларативной модели. Например, некоторые программы проще писать как набор инструкций, которые
выполняются независимо друг от друга. Такие программы называются  **параллельными** .

Правильнее тут говорить об  **одновременности (concurrency)** , потому что, говоря о параллельном выполнении,
подразумевается прежде всего аппаратная поддержка, физический аспект вычислений. Но в русскоязычной технической
литературе относительно абстрактных вычислений, одновременного выполнения кода традиционно используется термин "
параллельный", поэтому далее под параллельными вычислениями будут пониматься классические одновременные (concurrency)
вычисления, если явно не оговорено другое.

Сами по себе эти понятия ортогональны: независимые части кода могут выполняться "одновременно" на единственном
процессоре (используя механизм разделения времени между программными процессами), и единственная программа может
исполняться параллельно на мультипроцессорной системе (за счёт автоматического программно-аппаратного распараллеливания
её независимых кусочков на разные ядра).

**Реальный мир параллельный в смысле одновременности** : он состоит из множества активностей, которые развиваются
независимо. Мир программных систем также по сути параллельный (одновременный), и в нём очень часто разрабатываются
модели реального мира, поэтому параллельность в программировании так важна.

Параллелизм необходим любым программам, которые взаимодействуют со своим окружением: например, при программировании
графического интерфейса, взаимодействия с ОС, обработки внешних сигналов и т. д. Параллелизм также позволяет так
организовать программу, что разные её части будут выполняться независимо, а взаимодействуют друг с другом только при
необходимости (это прежде всего классическая архитектура клиент-сервер).

На этом курсе мы  **расширяем декларативную модель параллелизмом, полностью сохраняя при этом декларативный подход** .
Все приёмы программирования и рассуждений остаются также применимы. Ключевой принцип декларативной параллельной модели
прост: мы придерживаемся того факта, что  **dataflow-переменная может быть связана только с одним значением**.

Напомню, что декларативные переменные, в отношении которых система ожидает, когда они получат своё значение, называются
dataflow-переменные. Из этого мы и получаем автоматически декларативный параллелизм.

Из такого подхода вытекают два важных следствия:

- Что в модели остаётся неизменным:  **результат работы программы остаётся один и тот же, независимо от того,
  параллельная она или нет** . Помещение любой части программы в отдельный поток вычислений не изменяет итоговый
  результат.
- Что в модели нового:  **результат работы программы может рассчитываться постепенно** . Если входные данные подаются "
  по частям", то и программа будет вычислять свой результат также постепенно.

К сожалению, даже такой базовый, элементарный уровень декларативного параллелизма в популярных языках программирования
фактически не поддерживается, поэтому придётся немножечко использовать псевдокод.

Пример. Имеется рекурсивная декларативная функция Gen, которая формирует список последовательных целых чисел от N1 до
N2, и имеется декларативная функция Square, которая получает на вход список, и с помощью стандартной универсальной
операции над списками Map возводит каждый элемент списка-аргумента в квадрат. Мы хотим подавать функции Square на вход
результат работы функции Gen.

Допустим, что Gen на самом деле выполняет какие-то гораздо более сложные вычисления, которые требуют, например, 1
секунды на вычисление каждого очередного числа. То есть если её аргументы будут 1 и 10, то Gen проработает 10 секунд.

В последовательной схеме сперва Gen отработает до самого конца в течение 10 секунд, выдаст список, а затем Square
получит полностью этот список, и сразу обработает каждый его элемент. Результат будет получен, когда все вычисления
полностью закончатся.

В параллельной модели и Gen, и Square выполняются одновременно: как только Gen, проработав очередную секунду, выдаст в
список очередное число, его тут же подцепит Square и возведёт в квадрат. Результат тут формируется постепенно, по одному
элементу в секунду (и им уже тоже сразу может пользоваться следующая часть программы).

Глубинная причина, по которой данная форма параллелизма так проста, заключается в том, что  **декларативные программы не
характеризуются наблюдаемым недетерминизмом** . Программа в декларативной параллельной модели всегда обладает этим
свойством, так как не пытается связать одну и ту же переменную с несовместимыми значениями. Таким образом, внешний
пользователь программы даже не знает, выполняются ли её части последовательно или параллельно, результат гарантированно
будет один и тот же. По этой причине, в частности, в декларативной параллельной программе не возникает условий
конкуренции (race condition), которая есть просто наблюдаемое недетерминированное поведение (при одних и тех же данных
программа может выдавать разные результаты).

### 1. Параллельные вычисления

======= 1. Параллельные вычисления -- это ...

[0] физически независимое выполнение инструкций

[1] логически независимое выполнение инструкций

[0] одновременное выполнение инструкций

======= 2. Выберите ошибочное утверждение

[ 0] единственная программа может исполняться параллельно

[0] реальный мир параллельный в смысле одновременности

[0] независимые части кода могут выполняться одновременно

[ 1] реальный мир одновременный в смысле параллельности

======= 3. Для каких программ параллелизм неактуален?

[ 1] для консольных

[ 0] для программ с графическим интерфесом

[0] для клиент-серверных систем

[ 0] для программ, части которых выполняются независимо
