### Ленивое выполнение

Впервые концепция ленивого выполнения была обнаружена (фактически -- открыта) в функциональном программировании, где обрела долгую и богатую историю. Изначально она рассматривалась как стратегия, полезная только для декларативных программ. Однако ленивая схема также играет роль и в более выразительных вычислительных моделях, включающих декларативные в качестве подмножеств.

Важно, что ленивое выполнение играет роль не только в programming in small (для разработки и проектирования эффективных алгоритмов), но и в programming in large (для поддержки модульной структуры и продуктивного управления ресурсами всей системы). В частности, о проектировании декларативных алгоритмов, которые дают хорошие оценки (и O-большое, и амортизационные), рассказывает Крис Окасаки в своей классической книге **"Чисто функциональные структуры данных"** (рекомендую).

Параллельная модель ленивых вычислений в целом отличается от ленивого выполнения, используемого в функциональных языках наподобие Haskell, которые подразумевают последовательное выполнение. В их случае ленивое вычисление фактически представляет собой "корутининг" между ленивой функцией и функцией, которой нужен её результат.


### Параллельная модель по запросу/управляемая запросами (demand-driven concurrent model)

Параллельная модель по запросу расширяет параллельную модель, управляемую данными (она считается используемой по умолчанию), ровно одной новой концепцией --  **триггером "по необходимости" (by-need trigger)** . Этот триггер, соответственно, должен использоваться явно, чтобы определить соответствующую часть кода, управляемую запросами. Однако архитектурно рекомендуется само ядро системы ориентировать на работу по запросу, а вот его окружение формировать на основе управления данными.

Условная инструкция by_need аналогична инструкции thread, которую мы вводили раньше, чтобы указать, что какая-то часть кода будет выполняться в отдельной нити. Разница между thread и by_need лишь в том, что в случае нити соответствующий код при его вызове будет запущен на выполнение обязательно. А вот в случае by_need соответствующий код (функция) будет реально выполнен, только когда в программе потребуется его результат. Например:

```
X = by_need 5
Y = X
```

Значение X будет вычислено, только если к нему в программе случится явное обращение (как в команде Y=X).При этом модель с таким "ленивым" триггером должна сохраняться декларативной. Например, если есть три нити:

```
X = 1
X = by_need 5
Y = X
```

то независимо от порядка их выполнения (шесть вариантов) отказ должен возникать всегда, даже если вторая нить выполнится последней, и значение X вроде бы уже не должно запрашиваться (так как третья нить уже отработала). Однако даже потенциальное намерение связывания уже связанной X должно приводить к отказу.Примеры ленивой работы в Julia (в том числе и бесконечные ленивые списки, значения которых формируются только при их явном запросе) можно найти например в этом модуле: [Lazy.jl](https://github.com/MikeInnes/Lazy.jl)


Ленивое выполнение само по себе может применяться как реализация динамического связывания, используемого для структурирования приложений (компонентно-ориентированное программирование).

Исходный код проекта составляется из набора спецификаций компонентов, называемых  **функторами** . Работающее приложение состоит из экземпляров этих компонентов, называемых  **модули** .

Модуль представлен записью, в которой сгруппированы все его операции. Каждое поле записи ссылается на одну операцию. Компоненты связываются, только когда они реально необходимы -- т. е. их функторы загружаются в память и создаются их экземпляры. До тех пор, пока модуль явно при работе программы не востребован, компонент не связывается. А когда например программа пытается получить доступ к некоторому полю модуля, то компонент становится необходимым, и для его связывания компонента срабатывает выполнение "по запросу".


### 12. Корутины и параллельная композиция

======= 34. Корутина -- это ...

[ ] аналог нити с автоматическим вытеснением

[ 1] аналог нити с явным переключением в коде

[ ] аналог нити с локусом контроля

======= 35. Корутины ...

[ ] вносят недетерминизм

[ ] могут быть реализованы в декларативной модели

[ 1] подвержены голоданию

======= 36. Комбинатор в параллельной композиции...

[ 1] выполняет процедуры-аргументы в своих нитях

[ ] выполняет процедуры с аргументами в своих нитях

[ ] запускает процедуры в нитях и завершает свою работу
