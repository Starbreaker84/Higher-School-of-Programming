## Что такое абстракция в программировании?

*Interfaces are abstractions*
— [Olaf Thielke](https://codecoach.co.nz/interfaces-are-abstractions/), the "Code Coach"

*Interfaces are not abstractions*
— [Mark Seeman](https://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/), автор "Code that Fits in Your Head" и "Dependency Injection"

*In software, abstraction is the process of simplifying code by finding similarities between different parts of the code and extracting shared logic into a named component*
— [Eric Elliott](https://ericelliottjs.com/premium-content/abstraction-and-composition), автор "Composing Software and Programming JavaScript Applications"

*Abstraction is a process which is used to produce generalized concepts or models, but in software we often refer to individual parts of a model as abstractions as well*
— [Steve Smith](https://ardalis.com/what-are-abstractions-in-software-development/), автор "Architecting Modern Web Applications with ASP.NET Core and Microsoft Azure"

И это сегодня пишут, на минуточку, авторитетные специалисты в computer science, авторы учебников и серьёзных научных работ, известные преподаватели. Чьих рекомендаций придерживаться? :)

Они не согласны даже в таком фундаментальнейшем моменте, а что вообще означает  **абстракция** . Это какая-то солянка из различных концепций, которые чрезмерно обобщены и расплывчаты, нередко сводятся в итоге к примитивному повторному использованию кода. Эти бесконечные инженерные дебаты, что хуже --- дублирование кода или неправильная абстракция, или делает ли абстракция систему более понятной или более трудной для понимания, бла бла бла, вся эта мартинфаулерщина и путаница при отсутствии изначального понимания самой абстракции превращает подобные споры в бессмыслицу.

К счастью, если обратиться к оригинальным монографиям святых computer science 40-50-летней давности, то можно найти хорошее формальное определение абстракции от Эдсгера Дейкстры -- одного из самых великих учёных в информатике, оказавшего, наверное, самое сильное влияние на мир повседневной разработки. Поэтому именно его определение прекрасно связывает теорию с требованиями современной программной инженерии.

В мэйнстриме обычно заявляют, что абстракция -- это то, что помогает разработчику понять код, не вникая в его детали. В целом этот постулат можно вполне принять в некотором обобщённом формате, я же его формализую так: действительно, программистам полезно изучить математику такого рода абстракций, как следует понять, как эта математика строго объясняет вещи, которые они уже умеют делать, и позволить в дальнейшем этому уже достаточно чёткому подходу управлять их использованием термина "абстракция". Однако это задача довольно объёмная, мы разберём её постепенно.

Цель данного материала куда меньшая: согласовать те повседневные сущности программирования, которые вы постоянно используете, под зонтиком "абстракции", чтобы их можно было применять (и критиковать) вполне конкретно.

Есть как минимум четыре вещи, которые обычно объединяются под термином "абстракция".

Есть как минимум четыре вещи, которые обычно объединяются под термином "абстракция".

### Функции

Одним из претендентов на звание самого старого языка программирования становится лямбда-исчисление, в котором Алонзо Чёрч показал, что фактически используя только одно формальное правило, можно вычислить что угодно.

В лямбда-исчислении создание новой функции называется "лямбда-абстракция", а часто просто "абстракция".

Конечно, рядовой разработчик справедливо заметит, что такое использование слова "абстракция" сильно отличается от других его употреблений, принятых в разработке. Например: [Why is abstraction in lambda calculus called abstraction?](https://cs.stackexchange.com/questions/93006/why-is-abstraction-in-lambda-calculus-called-abstraction)

К сожалению, такой конфликт терминов привёл в итоге к гораздо более широкой неформальной дискуссии. Вообще, использование лямбда-исчисления сродни использованию открывающей и закрывающей скобок в блоке кода в разных языках программирования -- подобная практика постепенно просочилась в обсуждение "абстрагирования вещей в формат функций", что очень любят фанаты функционального программирования, и оттуда переросло в восхваление преимуществ стиля игнорирования деталей и некоторых других вещей, которые закрывающие скобки по большому счёту и не позволяют вам делать.

Таким образом, функции можно считать абстракциями -- но только в очень ограниченном значении этого слова, не имеющем никакого отношения ко всему остальному под этим ярлыком.

### Анти-унификация

Анти-унификация -- это причудливый термин для обозначения процесса взятия двух вещей, которые в основном похожи, и замены различных частей переменными. Если вы замените эти переменные одним способом, то вы получите первую вещь; в противном случае вы получите вторую. Если вы видите выражения x*x и (a-b)*(a-b) рядом друг с другом, и вам надо единообразно выполнить возведение в квадрат, то вы только что провели анти-унификацию: сформировали шаблон A*A с двумя заменами [A |-> x] и [A |-> a*b] .

Соответственно, противоположностью тут будет унификация, которая сравнительно редко используется в программировании, если только вы не пишете на языках логического программирования вроде Prolog, когда она присутствует буквально в каждой строке.

Вероятно, это выглядит для вас знакомо: практически всё, что принято помечать в программировании инженерным ярлыком "Не повторяйся" (пресловутый принцип DRY) будет хорошим примером анти-унификации.

Возможно, вы бы описали вышесказанное как "абстрагирование от квадратичной функции" (в отличие от предыдущего определения, где "абстрагирование" -- это просто добавление фигурных скобок).

В мэйнстриме на этой теме вообще хайпуют, например [&#34;The Secret of Simple Code&#34;:](https://medium.com/javascript-scene/the-secret-of-simple-code-a2cacd8004dd)

*The secret to being 10x more productive is to gain a mastery of abstraction...
Abstraction is the process of simplifying code by finding similarities between different parts of the code and extracting shared logic into a named component (such as a function, module, etc...)*

Нюанс в том, что этот вышеупомянутый процесс был формализован и автоматизирован(!) [ещё в 1970-м](https://homepages.inf.ed.ac.uk/gdp/publications/MI5_note_ind_gen.pdf) легендарным Гордоном Плоткиным.

Как-то странно говорить на эту тему 50 лет спустя в контексте "десятикратной продуктивности" при использовании абстракций, не находите? Ну вот такое сегодня обучение computer science по всему миру.

### Упаковка (boxing)

"Боксинг" -- это то, что случается, когда вы делаете слишком много анти-унификации :)

Куча мест с синтаксически схожим кодом превращается в одну большую функцию с множеством условий и чрезмерным количеством параметров. "Запихиваем беспорядок в коробку", есть и такой инженерный антипаттерн (boxing). И тут тоже полно хайпа, например именно с таких случаев начинаются холивары "дублирование лучше, чем неправильная абстракция", например:
[duplication-cheaper-wrong-abstraction](https://www.codewithjason.com/duplication-cheaper-wrong-abstraction/)
[the-wrong-abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)

Sandi Metz хорошо описывает этот кривейший антипаттерн, очень распространённый в мэйнстриме (многие IDE его прямо навязывают через рефакторинг):
"Программист считает своим долгом сохранить существующую абстракцию, но поскольку она не получается абсолютно одинаковой для каждого случая, он изменяет код, выделяя его в функцию, принимающую соответствующий параметр, а затем добавляет логику для условного выполнения нужных действий на основе значения этого параметра".

Я регулярно выступаю против такого наивного де-дублирования кода. Хорошее упражнение -- привести несколько примеров логики, которые имеют одинаковую реализацию, но разную спецификацию (и поэтому должны в последующем сопровождаться и развиваться принципиально по-разному). Наличие фактически идентичного кода никак не может выступать надёжным критерием того, что эти два блока делают одно и то же. Поэтому важно поддерживать соответствующую терминологию при объединении похожих вещей, которые могут сочетаться, а могут и не сочетаться.

В частности, если мы хотим, чтобы абстракция имела какое-то реальное отношение к возможности игнорировать неважные детали, мы должны прежде всего забыть про вот этот вот шаблонный сценарий "абстракции" боксинга.

### Перенаправление

Точного определения понятия Indirection нет, но обычно подразумевается "любое время, когда вам потребовалось заглянуть в другой файл с кодом, чтобы посмотреть, что происходит".

Шикарная пародия [FizzBuzzEnterpriseEdition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) на все эти ваши многослойные абстракции, получившие такое распространение в мэйнстриме "благодаря" книгам вроде "Паттерны архитектуры корпоративных приложений" Мартина Фаулера, ну и архитектуре Spring например, хм. Когда пишете бесконечные цепочки однострочных функций, вызывающих друг друга (что преподносится вам как функциональное программирование), или организуете иерархию классов в семи файлах (что подаётся как ООП).

Мартинфаулерщина например, это когда вы "оптимизируете"

```
contract.calculateTotalRevenue()
```

в Service Layer Abstraction (TM)

```
calculateTotalRevenue(Contract)
```

Но это не работа с формой, это не паттерн, это не правило думательной машинки, это просто какой-то детский сад :)

Если вы поизучали цикл заметок "Три уровня мышления о программе", то теперь, если будете описывать первый вариант, то вероятно скажете: "Это рассчитывает общий доход по контракту". Если будете описывать второй вариант, то вероятно скажете: " Это рассчитывает общий доход по контракту ". Мы не скупимся на подробности, чего уж.

### Интерфейсы, тайпклассы и параметрический полиморфизм

Все эти три механизма по сути предназначены для одного:  **группировки нескольких реализаций одной функции так, что конкретный её вызов может быть передан любой из них по некоторой формальной схеме** . Большинство программистов знакомы с интерфейсами (в Java или TypeScript). Тайпклассы по сути те же интерфейсы, не привязанные к объектам. Параметрический полиморфизм (он же "генерики") немного отличается тем, что объединяет методы класса, которые отличаются только типами в сигнатуре. В некоторых языках, например, Julia и Go, поддерживается так называемый multiple/dynamic dispatch ("параметрический полиморфизм" для обычных функций, не привязанных к классам).

Параметрический полиморфизм фактически -- просто добавление дополнительного параметра к функции (за исключением того, что этот дополнительный параметр есть тип, а не значение). Это никакая не абстракция (так же, как и не будет абстракцией анти-унификация).

Что касается интерфейсов и тайпклассов, то действительно, есть тенденция ассоциировать их с абстракциями. Но есть банальная причина, по которой они не удовлетворяют цели абстракции: ничто в них не принуждает к тому, чтобы все реализации (множество) имели какое-то отношение друг к другу. Например, в Julia функция getindex фактически выступает интерфейсом со 188 реализациями, диспетчеризируемыми в зависимости от типа аргументов во время выполнения (классический multiple dispatch). Большинство этих реализаций выполняют поиск в массиво-подобных структурах, однако некоторые делают прямо противоположное -- сами создают массив.

Или же, когда мы работаем с интерфейсом полиморфного класса, то заранее невозможно понять, какая из реализаций метода будет выбрана -- но они могут совершенно различаться в том, что они делают! Надеюсь, вы понимаете, о чём я. Нам надо уметь объяснить работу такого множества реализаций на каком-то общем мета-языке, рассчитывая, что они все делают примерно одно, с небольшими различиями. Например, условные методы Говорить для классов Cat и Dog, ожидается, будут делать примерно одно: котики могут только мяукать, а собачки только гавкать, но они будут точно издавать некоторые звуки. Однако программист может ошибиться, и вместо логики Говорить, ошибочно закодит, например, логику Кусать.

Нам же хочется, чтобы некоторый мета-язык определял и основную логику, и подобные мелкие нюансы-различия. Писал об этом не раз, что в идеале это должна быть умная AI-система, поддерживающая и понимающая знания о предметной области, по которой пишется код.

Но в нашей прозаической повседневности пока такого не ожидается, поэтому мы естественно приходим к...

### Истинная Абстракция

В computer science, в частности, в теории языков программирования и формальных методов существует несколько определений понятия "абстракция" в различных контекстах, но все они довольно похожи.

**Абстракции -- это отображение между "грязным" (запутанным, нечётким, противоречивым) конкретным реальным миром (предметной областью) и "чистым" идеализированным (который можно описать математически)** . В терминах теории типов абстракция отображает сложную структуру данных в базовые типы, как-то их комбинируя. В терминах программной инженерии абстракция связывает маленькие изменения состояния в каждой строке, реализующей стек TCP, с информацией, содержащейся в конкретной диаграмме протокола. Такие абстракции становятся полезными, когда мы можем определять нужные нам операции полностью в абстрактной форме.
Так было заповедано нам Дейкстрой:
**"Цель абстракции -- не быть расплывчатой, а создать новый семантический уровень, на котором можно быть абсолютно точным"** .

Вы, вероятно, уже использовали сегодня одну из таких абстракций в своём коде: число 42 может быть представлено во многих формах, например, с помощью битов, счётных знаков и даже (как это делается в математике) в виде [множества](https://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers).

Операция сложения также имеет своё множество реализаций, но при использовании калькулятора вам не нужно задумываться ни об одной из них. И крайне важно, что абстракции могут быть скомбинированы: существует абстракция для математических целых чисел, скомбинированная с их двоичной реализацией, и другая абстракция для двоичных чисел, скомбинированная с реализацией в виде фактического напряжения в чипе.

Работая с хорошими абстракциями, вы никогда не подумаете, что это вообще абстракция.

Итак, как на самом деле выглядят абстракции в коде?

Никак.

### Истинная Абстракция

Где же тогда находятся абстракции?

Когда ментор на очень редких действительно хороших курсах спрашивает, обладает ли демонстрируемый код каким-то системным свойством (элементом дизайна системы, "фичей" из ТЗ), практически всегда можно дать шаблонный ответ "может быть". Практически так же происходит, если спрашивать: "Является ли X абстракцией Y?".

**Абстракции -- это отображения** . Абстракция -- это шаблон, который мы накладываем на  **моделируемый мир** , а не на сущности, с которыми он связан.

Поэтому корректно спросить так: "Будет ли это абстракцией, отображение из X в Y?". Сохранятся ли корректно при таком отображении нужные нам операции Y в абстракции X?

Целые числа -- это отличная абстракция аппаратного обеспечения, используемого для их хранения в оперативной памяти. Каждое число соответствует большому набору различных напряжений на множестве транзисторов. Мы не хотим работать напрямую с этими напряжениями, мы хотим работать с их удобной абстракцией - знакомыми нам числами. Но для этого надо, чтобы абстракция целых чисел корректно отображалась на реальный мир (физические напряжения). Аналогично и сложение соответствует различным путям изменения электрического заряда. Это вполне можно описать формально, однако в явном виде абстракция сложения не существует.

Следствие: ваш смартфон можно абстрагировать в целое число. Всё просто: достаточно взять его IMEI.

Это конечно не означает, что целые числа -- это абстракции смартфонов, просто это конкретное отображение будет именно таковым. Но его однако не следует считать хорошим, поскольку оно не сохраняет ни одной из операций над сущностью "Смартфон" -- равно как не существует аналогичного отображения между обычными арифметическими операциями над целыми числами и над значениями IMEI. Добавив единицу к серийному номеру, вы не получите серийный номер "более большего" телефона.

И это контринтуитивно означает, что  **хорошие абстракции обычно легко найти** . Действительно, существует абстракция (отображение) от каждой реализации к её интерфейсу, и к каждому вызову функции от её реализации. Но только хорошие абстракции позволяют нам взглянуть на цепочку вызовов интерфейсов и сделать достаточно корректные предсказания, выходящие за наивные рамки "что-то произойдёт".

Ранее приведённые примеры абстракций (целые числа и операции над ними как абстрагирование транзисторной логики электрических напряжений в чипе) обладают двумя ключевыми свойствами, которые делают их реально полезными.

Первое -- это  **soundness (надёжность, обоснованность, разумность)** . Абстрагирование (отображение), если оно состоит из нескольких операций, обычно коммутативно: например, можно делегировать операцию прибавления +1 к числу непосредственно чипу, и затем считать готовые итоговый результат, либо преобразовать начальное напряжение в исходное число, и затем прибавить к нему +1 вручную ручкой на бумаге; результат в каждой цепочке будет один и тот же, хотя исходные напряжения различны.

Второе свойство -- это  **точность** : прибавление +1 к числу всегда даёт ровно один (и тот же) результат, даже если он соответствует разному множеству выходных напряжений (которые могут немного "плавать"). И вот если абстракции, отвечающие как-то требованию soundness, находятся достаточно просто, то точность делает поиск хороших абстракций весьма нетривиальным.

Факт, что любая функция (математическая или программная) для целых чисел даёт хорошую абстракцию. Например, существует абстракция от вашего телефона к целым числам: серийный номер, IMEI. Однако вам будет трудно найти какие-либо операции над смартфонами как физическими предметами, которые могут быть разумно выражены в целых числах. Включение телефона или запуск программы происходит с точно таким же IMEI, а замена телефона на более мощный едва ли отличима от случайной смены серийного номера. Да, в принципе функцию "смартфон чуть большего размера" можно реализовать на абстрактной области серийных номеров, отображая каждый серийный номер на множество всех других серийных номеров. Это разумно: получение большего смартфона и последующее взятие его IMEI, безусловно, потенциально содержится в "операции" просмотра серийного номера вашего текущего телефона и "получения" его размера. Однако такая функция, очевидно, будет работать максимально неточно и почти всегда ошибаться.

Следствие: если мы переведём любой вопрос "является ли X абстракцией Y" в "существует ли абстракция, которая отображает X в Y", то ответ всегда будет "да". Поэтому правильно будет спрашивать, какие операции такого отображения можно точно использовать, обращаясь только к абстрактной версии. Абстракция перехода от напряжения к числам идеально точна для всех операций над числами, но не поддерживает такие операции, как например проверка, держит ли определённый транзистор в схеме сумматора 2.1 или 2.2 вольта. Абстракция перехода от смартфонов к их серийным номерам совершенно неточна для любой операции, кроме проверки, будут ли два телефона одинаковы (а также, возможно, для получения информации об их производителе и модели).

Кроме того, к свойствам обоснованности и точности добавляется третье измерение, по которому полезно оценивать абстракции:  **размер (в битах) абстрактного состояния** . Хорошие абстракции -- это разумные абстракции, которые имеют небольшой размер в битах, но при этом достаточно точны в смысле "отслеживания"/соответствия многих полезных операций абстрагируемой сущности.

Например, создаётся сервис бронирования столиков в ресторане, где конкретным семантическим доменом будет фактическое количество бронирований на один столик. Такое состояние всего ресторана может быть представлен словарём, где ключи -- номера столиков, а значение -- список объектов, состоящих в свою очередь из двух полей (период бронирования от-до, и имя посетителя). Для каждого посетителя можно абстрагировать его конкретное состояние до абстрактного состояния в виде перечисления забронированных на него временных интервалов (без привязки к столикам! почему, рассматриваем далее). Что делает такое перечисление абстракцией, а не просто программной операцией над состоянием ресторана? То, как мы будем задавать в дальнейшем связь других операций с этим абстрактным перечислимым значением.

В таком сервисе самое первое, что, очевидно, нам потребуется, это функция, которая получает параметром посетителя и желаемый им временной интервал, и должна "как-то" зарезервировать столик. Как может быть описана спецификация такой функции (её работа на третьем уровне, как мы изучали в материалах про уровни думания о программе)?

1. Это может быть просто дословное/буквальное описание её реализации, например: назначить посетителю первый доступный столик, начиная со столика с наименьшим номером.
2. Все допустимые варианты поведения на всех доступных состояниях: найти любой свободный столик на заданное время, и назначить его посетителю, или ничего не делать, если свободных мест нет.
3. Отображение в упомянутый выше абстрактный домен данного посетителя, т.е. возвращается "перечисление", в котором будут все слоты брони (скорее всего, один, если столик найден, хотя теоретически посетитель может забронировать несколько столиков), либо оно будет пустым, если свободного столика на запрошенное время не нашлось.
4. Отображение в упомянутый выше абстрактный домен каких-то других посетителей: например, если свободных столиков нету, то будет выдано перечисление всех слотов времени, перекрывающихся с запрошенным, а если столик найден, то перечисление будет пустым (был найден столик без перекрытий по времени).


Важные выводы.

-- Все эти спецификации полезны тем, что вы можете использовать любую из них при изучении работы кода с привязкой к реальным данным в базе. Возможно, вы подумаете "когда я нажму на эту кнопку, будет забронирован либо столик 5, либо столик 6, либо столик 7" (используя спецификацию 2), или "эта строчка никак не связана с перечислением слотов времени для Пети" (спецификация 4).

-- Абстракции отделены не только от кода, но и даже от абстракции домена. Не имеет смысла говорить, что упомянутая функция резервирования, или что-то ещё в этом файле с кодом, "является" абстракцией, потому что, как мы только что видели, мы можем использовать множество различных абстракций при описании её поведения. Более того, мы видим, что даже для конкретной пары реального и абстрактного доменов может существовать множество абстракций (отображений) между ними.

-- Вместо этого считаем, что код ассоциируется с абстракциями. Обратите внимание на множественное число. Мы видели, что та функция может быть связана с несколькими абстракциями поведения. На самом деле их бесконечно много, включая и некоторое множество реально полезных, которые ранее не обсуждались (например, отображение состояния ресторана на список слотов с привязкой к доступным столикам).

-- Чтобы рассуждать, используя абстракцию, не нужно менять код. Мы могли бы расширить отображение от связи абстрактных/конкретных состояний к конкретным шагам их связывания, а затем сказать, что наша функция "абстрагирует" набор промежуточных шагов, которые программа делает в каждой строке в функции, но это будет чрезмерно привязано к реализации. Наоборот, мы стараемся от этого уйти.


Различные абстракции, как правило, не бывают "более" или "менее" точными по сравнению друг с другом -- они просто точны по-разному. Сравните те четыре абстракции по состоянию ресторана -- все они точны и вполне могут быть использованы для ответа на разные вопросы.

Однако конечно мы вполне можем оценить, что делает ту или иную абстракцию "более хорошей". Спецификация 3 довольно близка к детерминированной, предлагая только два возможных результирующих состояния ("количества" информации). В общем, хорошие абстрактные состояния всегда содержат гораздо меньше информации, чем конкретные. Поэтому, в частности, в выдачу не включалась информация о конкретных забронированных столиках; если вы проходили курсы по ООАП, то помните, что у нас есть команды и запросы, каждая из которых делает ровно одно. Соответственно, субъект (человек или код), отслеживающий только это абстрактное состояние, всё равно сможет прекрасно предсказать результат нескольких других операций -- например, проверить, какой именно у посетителя столик. Это и есть тот новый семантический слой, на котором можно быть абсолютно точным, о котором и говорит Дейкстра!

Конечно, громоздко выражаться "существует надёжная и точная абстракция, отображающая напряжения в чипе на математические числа" или "существует хорошая абстракция от конкретных деталей того, когда и как бронируются столики, к доступным периодам времени". Вполне удобно использовать более привычную формулировку "числа абстрагируют аппаратуру" или "такая-то функция абстрагирует все детали бронирования столиков"; или вы можете говорить "абстракция отображения", если хотите явно ссылаться на абстракции так, как они определены в этом материале. Однако такое сокращение в то же время допускает множество неоднозначных толкований и может привести к спору, должно ли бронирование столиков быть такой же абстракцией, как и бронирование гостиничных номеров. Не стесняйтесь называть числа абстракцией оборудования, но будьте готовы перейти на более точную терминологию, когда на горизонте актуальности возникнет напряжение на транзисторах чипа.


### Корень путаницы

Программисты справедливо настаивают в спорах об абстракциях, что желательно иметь какой-то единый универсальный способ рассуждать о коде, игнорируя детали. На самом деле самое первое точное определение абстракции в том виде, в каком оно актуально сегодня, дали [в своей работе 1977 года](https://cs.nyu.edu/~pcousot/COUSOTpapers/POPL77.shtml) Патрик и Радхия Кузо. Очень многие другие попытки определения абстракций не учитывают их бесплотной природы и вместо научного подхода зацикливаются на чём-то в коде (хотя какая-то связь между абстракцией и кодом, конечно, должна быть).

Да, функции -- не абстракции. Но для каждой функции существует абстракция (не обязательно хорошая), которая сводит множество промежуточных шагов функции к атомарной операции. Также могут существовать абстракции, допускающие простое формальное описание отношения между входом и выходом функции.

Да, анти-унификация -- это не абстракция. Тем не менее, два фрагмента кода, которые вполне могут быть успешно смоделированы семантически -- похожими абстрактными состояниями, часто поддаются и синтаксической анти-унификации. Но по мере объединения разрозненных операций в одно абстрактное состояние приходится добавлять всё больше дополнительной информации, чтобы сохранять точность работы. В результате возникает boxing.

Перенаправление -- это не абстракция, хотя для функций с одинаковыми именами вполне разумно предполагать связанные с ними абстрактные области (в чём-то разные, но несильно). Когда мы делаем абстракции более явными, это сопровождается перенаправлением; проблема в том, что программисты слишком часто навязывают абстракции коду без какого-либо перенаправления вообще.

Интерфейсы и тайпклассы -- это не абстракции, но хороший интерфейс будет связан по крайней мере с одной хорошей абстрактной областью, причём эта связь будет достаточно точной, что делает каждую операцию интерфейса почти детерминированной (или, по крайней мере, простой для определения в спецификации), а каждая реализация будет поставляться с разумной абстракцией, отображающей её конкретные состояния в эту абстрактную область.

Абстракции соблазняют нас идеалом -- возможностью рассуждать, думать в процессе создания программы достаточно просто и легко, получая при этом качественный и надёжный код с богатым поведением. Но реализация этого идеала, очевидно, находится за пределами возможностей любой фичи массовых языков программирования, будь то функции или интерфейсы. Мы должны мыслить глубже, конструировать в своём уме думательную машинку, которая достаточно строго (сперва грубо приблизительно, затем всё точнее и точнее) определяет, как именно беспорядочный мир превращается в чистую цифровую модель.

Речь о том, что вместо того, чтобы мучительно разбираться, использует ли некоторый кусок кода функции или интерфейсы на уровне синтаксиса, и заявлять, демонстрирует ли он прекрасные преимущества и ужасные недостатки "абстракций", мы должны учиться думать глубже и всё чётче и чётче формулировать, как именно беспорядочный мир преобразуется в чистый идеал.

А это значит, что мы должны выйти за пределы двоичного определения того, является или не является что-то абстракцией, и вместо этого **открыть для себя новый семантический уровень мышления, на котором мы парадоксально можем быть абсолютно точны** -- ещё более точны, чем даже на уровне синтаксиса кода.
