### Кооперативный и конкурентный параллелизм

**Кооперативный параллелизм** подразумевает схему, когда множество сущностей работают вместе над некоторой глобальной задачей. Нити предназначены именно для такого подхода, когда все подсистемы приложения "доверяют" друг другу. В таком случае нити обычно сами следят за своей работой, за своими квантами времени.

С другой стороны, **конкурентный параллелизм** подразумевает схему, когда каждая сущность имеет свою локальную цель, т. е. работает только на себя. Она заинтересована только в своей собственной производительности, а не в глобальной продуктивности. Конкурентный параллелизм обычно управляется ОС в терминах концепции, называемой  **"процесс"** .

Подобные вычисления часто имеют двухуровневую структуру. На самом верхнем уровне находится набор процессов ОС, взаимодействующих друг с другом в формате конкурентного параллелизма (конкурирующих за ресурсы ОС). Процессы обычно принадлежат различным приложениям, имеющим различные (возможно, противоречивые) цели.

Внутри каждого процесса существует набор нитей, взаимодействующих друг с другом в формате кооперативного параллелизма. Нити внутри одного процесса практически всегда принадлежат одному приложению.

### Потоки (Streams)

Наиболее полезная техника параллельного программирования в соответствующей декларативной модели -- это  **использование потоков для организации связи между нитями** .

**Поток -- это потенциально неограниченный список сообщений** (т. е. список, хвост которого -- несвязанная dataflow-переменная). Отправка сообщения осуществляется путем расширения потока на один элемент: хвост связывается со списком из пары элементов (значение сообщения и новый несвязанный хвост). Получение нитью сообщения -- это чтение очередного элемента потока.

Нить, взаимодействующая через потоки -- это своего рода "активный объект", который мы будем называть  **потоковым объектом** . Никакие блокировки или взаимные изоляции не требуются, поскольку любая переменная может быть однократно связана только одной нитью, выполняющейся в свой квант времени.

Потоковое программирование -- это довольно общий подход, который может применяться в разных областях (например, эта концепция заложена в основе конвейеров Unix). Мы рассматриваем  **детерминированное потоковое программирование** , когда каждый объект потока всегда знает для каждого своего входа, откуда придёт следующее сообщение.

### Паттерн producer/consumer

Это весьма популярная в прикладном программироании модель, когда имеется одна нить- **поставщик (producer)** , которая отправляет объекты в поток (формирует соответствующий список потока), и имеется несколько нитей- **потребителей (consumer)** , которые асинхронно читают значения из потока по мере того, как они там появляются. Базовый механизм синхронизации работы и взаимодействия поставщика и потребителей -- это автоматическое ожидание связывания dataflow-переменной.

Каждая нить-потребитель получает элементы потока независимо от других. Потребители не мешают друг другу, потому что они фактически не "потребляют" поток; они просто читают его, ведь его содержимое иммутабельно. А если происходит обращение какой-то нити к несвязанной переменной (в потоке временно закончились элементы), то её работа просто автоматически приостанавливается, пока нить-поставщик в свой квант времени не свяжёт хвост потока с новым значением.

### 8. Планирование работы нитей

======= 20. Полноценный планировщик должен ... (выберите неверное утверждение)

[ ] обрабатывать по очереди все готовые нити

[ ] подсчитывать шаги вычислений

[ 1] управлять аппаратным таймером

[ ]  быть справедливым

======= 21. Уровни приоритетов нитей -- это ...
[ ] организация срочной обработки событий

[ 1] дополнительный компромисс для оптимизации вычислений

[ ] избегание излишнего замедления вычислений

======= 22. Наследование приоритетов важно, так как ...

[ ] задание приоритета требует ресурсов

[ ] по умолчанию нити получают средний приоритет

[1] дочерние нити с низкими приоритетами могут вводить систему в клинч

221
223
233
133
123
323
