### Альтернативы наследованию

Наследование -- это только один из способов повторного использования уже определённой функциональности при создании новых возможностей. Наследование нередко бывает сложным для правильного использования и требует хорошей подготовки, поскольку подразумевает тесную связь между классом-предком и его потомками-расширениями. Иногда лучше использовать более свободные подходы. Два таких известных подхода -- это  **переадресация (forwarding) и делегирование (delegation)** . Оба они определяются на уровне объекта: если объект A не принимает сообщение M, то оно прозрачно передаётся объекту B.

Переадресация и делегирование различаются в том, как они обрабатывают self/this.

**При переадресации объекты A и B работают со своими собственными оригинальными self** .

**При делегировании есть только одна сущность A, и обращение к self внутри B подразумевает self из A.**

Можно сказать, что делегирование, как и наследование реализации, подразумевает общий self. Переадресация же общий self не подразумевает.

Делегирование в общем случае считается мощным механизмом структурирования системы динамически, подразумевая  **конструирование иерархии объектов** , а не классов. Вместо организации наследования объектов через классы (в момент определения класса, фактически во время компиляции), мы позволяем объектам делегировать работу другому объекту в момент физического создания объекта в ходе работы программы.

Делегирование даёт такой же эффект, как и наследование, с двумя важными отличиями: сама иерархия уже строится между объектами, а не между классами, и она может быть (следовательно) изменена в любой момент работы программы.

Важным свойством семантики делегирования считается тот момент, что self всегда сохраняется (оно одно на всех): это self исходного объекта, который инициировал всю цепочку делегирования. Из этого следует, что состояние текущего объекта (атрибуты) также будет состоянием и исходного объекта. В этом смысле другие объекты, участвующие в цепочке делегирования, играют роль классов: только их методы важны при делегировании, а не значения их атрибутов (которые всегда родительские).

### Рефлексия

Система считается рефлексивной, если она может проверять части своего состояния непосредственно во время работы. Рефлексия может быть чисто интроспективной (только чтение внутреннего состояния, без изменения) или интрузивной (допускается как чтение, так и изменение внутреннего состояния). Рефлексия может быть выполнена на высоком или низком уровне абстракции.

Пример рефлексии на высоком уровне -- возможность рассматривать элементы в стеке как замыкания. Этот пример можно объяснить в терминах абстрактной машины. С другой стороны, способность обращаться к оперативной памяти программы напрямую, как к массиву целых чисел -- это рефлексия на низком уровне. Нет простого способа выразить её в абстрактной машине.

### Мета-объектные протоколы

ООП благодаря своему высокому потенциалу, предлагает обширное поле для экспериментов. Например, система может позволять рефлексивное изучение или даже изменение иерархии наследования во время работы программы. Другая возможность -- изменять работу самих объектов на базовом уровне, например, работу наследования (как происходит поиск методов в иерархии классов), или механизм вызова методов.

Определение того, как именно объектная система функционирует на подобных базовых уровнях, называется  **мета-объектным протоколом** . Возможность изменять мета-объектный протокол -- мощный способ модификации объектной системы. Мета-объектные протоколы используются в самых разных целях: для отладки, настройки, разделения концепций (например, прозрачным добавлением шифрования, или изменением формата вызова методов). Мета-объектные протоколы были первоначально изобретены в контексте объектной системы Common Lisp Object System (CLOS) и считаются активной областью исследований в ООП.

**Обёртка методов**

Общая схема мета-объектных протоколов подразумевает "оборачивание" методов дополнительным кодом -- перехват каждого вызова метода, и, например, выполнение определенной программистом операции перед вызовом и после вызова, изменение аргументов самого вызова, и т. п.

### Альтернативы наследованию

======= 21. При переадресации ...

[1 ] объекты A и B работают с оригинальными self

[ ] обращение к self внутри B подразумевает self из A

======= 22. При делегировании ...

[ ] объекты A и B работают с оригинальными self

[1 ] обращение к self внутри B подразумевает self из A

======= 23. Отличие делегирования от наследования -- это ... (выберите ложное утверждение)

[ ] иерархия объектов может динамически меняться

[ 1] иерархия строится между объектами

[ ] наследование объектов строится через классы в момент компиляции
