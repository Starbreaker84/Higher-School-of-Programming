## Кэш

Кэш -- это такая эвристическая (эмпирическая) структура данных, которая используется для оптимизации систем, где происходит выборка множества повторяющихся записей. Причём одни записи выбираются чаще, а другие реже, но заранее мы даже примерно не представляем, какие именно.

Кэш -- это своеобразная хэш-таблица, используемая в схемах, когда количество элементов в ней на много порядков меньше, чем общее количество значений. Например, мы хотим уместить в табличку размером тысяча элементов хэш на миллионы ключей. В таких ситуациях хэш-таблица обычно быстро полностью заполняется, поэтому требуются механизмы удаления наименее "ценного" элемента.

Типичный пример -- это кэширование прокси-серверами веб-страничек, когда частота обращений к популярному адресу (ключу) столь высока, что значение ключа (саму страничку) удобно поместить в хэш-таблицу, которая существует в оперативной памяти, и очень быстро выдавать результат. Активно используется концепция кэша в процессорах, когда доступ к оперативной памяти -- к наиболее "популярным" адресам, кэшируется в небольшом, но очень быстром буфере.

Основное отличие кэшей от других структур данных, основанных на хэш-таблицах, в том, что для кэша надо реализовать схему вытеснения некоторого элемента, когда она вся заполнена. Классическая модель хэш-таблицы будет выдавать отказ в обслуживании, а нам требуется создать на её основе новый класс, который в случае отсутствия свободных слотов будет освобождать один из слотов.

Схем такого вытеснения существует довольно много. Самые простые и популярные -- это вытеснение самого старого элемента, или вытеснение элемента, к которому зафиксировано наименьшее количество обращений. Надо отметить, что существуют немного парадоксальные схемы, когда вытесняется элемент, к которому было самое последнее обращение. Это возможно в случаях, когда максимальное количество обращений фиксируется к самым старым элементам.

Реализуйте на основе словаря новый класс NativeCache, который дополнительно будет учитывать количество обращений к каждому ключу. Когда хэш-таблица заполняется и найти свободное место не удаётся, вытесняйте элемент с наименьшим количеством обращений. Для этого в дополнение к массивам, хранящим ключи и их значения, заведите третий массив, который будет хранить соответствующие количества обращений.

*Вытеснение элемента -- это просто удаление ключа и значения (освобождаем один слот каким-то внутренним способом). Новый ключ может иметь другой хэш, и он должен механизмом разрешения коллизий попасть на освободившееся место. Это не очень эффективная схема, тут сильно зависит от схемы разрешения коллизий, в данном учебном случае делаем так. Но вы можете придумать какую-то свою схему.*

```
class NativeCache<T>
{
    public int size;
    public String [] slots;
    public T [] values;
    public int [] hits;
    // ...
}
```

Смоделируйте в тестах программно ситуацию, когда хэш-таблица заполнена (например, организуйте множество коллизий) и проверьте, правильно ли работает схема вытеснения. Также проверяйте в тестах, корректно ли учитывается количество обращений к ключам.

Решение отправляйте на сервер в свободной форме.

**[предыдущее](https://skillsmart.ru/algo/15-121-cm/z0b3da83s2.html)**

---

Это последнее занятие первого курса по алгоритмам. Напишите пожалуйста отзыв, ваши впечатления, чему вы научились, что было полезного.

Мы изучили базовые, фундаментальные структуры данных, используемые во всех современных языках программирования, и основные методы работы с ними. Главное, что теперь мы представляем, как эти структуры данных устроены изнутри, и можем успешно выбирать подходящие стандартные типы данных под конкретную задачу, а при необходимости и самостоятельно реализовывать эффективные модели хранения и обработки информации с учётом проектной специфики. Этот навык на самом деле очень ценен, так как объёмы обрабатываемых данных в серьёзных проектах постоянно растут, и правильный выбор подходящего способа работы с ними может дать выигрыш производительности в десятки, а то и сотни раз.

На втором курсе по алгоритмам мы изучаем более сложные структуры -- в частности, деревья, включая двоичные, кучи и графы. Пользоваться этим всем с хорошим пониманием внутреннего устройства умеют, наверное, единичные проценты программистов с хорошим образованием, а остальные просто придумывают кривые костыли, не подозревая о наличии готовых мощных решений.

Эти типы данных применяются сегодня практически в каждой нагрузочной системе, так как деревья дают наилучшую эффективность при поиске информации, и по этой причине огромное количество прикладных систем (например, файловые) основаны на деревьях. Графы -- это ещё более мощная абстракция, которая позволяет качественно описать весьма и весьма сложные концепции, в частности, сети -- от электрических и энергетических до военных и транспортных.
Кучи (варианты деревьев) также применяются для быстрого нахождения максимального и минимального элементов и задействованы в системах с приоритетной обработкой.

Пожалуй, самое главное, что вы продолжите на практике постепенное изучение плавно усложняющихся типов данных и алгоритмов, повышая своё мастерство программирования. Это главный подход в обучении профессиональных программистов, принятый в качестве стандарта практически во всех ведущих университетах мира, а разрабатывается он старейшей международной Ассоциацией вычислительной техники ACM.

Ещё рекомендации с курса CS106B Стэнфордского университета.
Конкретные внутренние реализации различных структур данных надо обязательно учитывать, если в проекте ожидаются большие объемы данных. Например, миллиарды динамических объектов сегодня совсем не редкость. И даже если для задачи достаточно двух операций добавления/удаления в голову или хвост, использовать связный список, в каждом узле надо хранить два указателя -- на предыдущий и следующий элементы. И для миллиардов элементов накладные расходы на хранение указателей могут оказаться чрезмерными.

В таких проектах всегда приходится чем-то жертвовать, невозможно все операции свести к O(1). Чем проще редактирование (добавление/удаление элементов), тем дольше будет поиск, и наоборот. В списке добавление/удаление в голову или хвост выполняется за O(1), а поиск нужного элемента -- за O(N). В хэш-таблицах, наоборот, поиск может происходить за O(1) а добавление элемента за O(N) (в наихудшем случае, если коллизий много). Возможен компромисс -- упорядоченный список, когда и добавление, и поиск примерно одинаковы по эффективности (надо добавить элемент в нужное место, которое и выполняется тем же двоичным поиском).

Кроме того, есть ещё и фактор трудоёмкости программирования. Хэш-таблицу разрабатывать труднее чем стек, деревья ещё сложнее, они вдобавок требуют сложной балансировки, и т. д. Учитывать надо и наглядность реализации для тех, кто будет читать ваш код.

Понимание внутренних реализаций и умение подбирать подходящие структуры данных под конкретный проект очень важны. Например, если вы заранее знаете, что у вас будет не более тысячи элементов в массиве, то скорее всего можно вообще забыть про какие-то сложные структуры. Проще всего взять обычный стандартный массив или список, и O(N) будет вполне достаточно.

Ещё одно правило -- если структура данных явно напрашивается под какую-то подзадачу, используйте её. Если лучше подходит стек, то используйте конкретный готовый тип данных Стек. На уровне компилятора вы будете формально ограничены допустимым набором операций, в подходящем типе данных будет инкапсулировано все лишнее, и тем самым возможность ошибок или различных некорректных действий понизится.
