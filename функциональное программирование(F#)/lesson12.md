## Записи (records)

## 24. Записи

**24.1. Определение нового типа**

Определение нового типа в F# вводится так:

```
type имя-типа = определение-типа
```

**24.2. Записи**

Запись -- это обобщённый кортеж, где каждый его компонент идентифицируется не позицией в кортеже, а меткой (названием).

Структура записи может быть задана как тип:

```
type тип-записи = { метка-1 : тип-1; метка-2 : тип-2; ... }
```

```
type Cat = { name : string; age : int; sex: char }
let barsik = { name = "Barsik"; age = 5; sex = 'M' }
```

Компилятор автоматически сопоставляет идентификатору barsik значение типа Cat.

Значения меток конкретной записи называются поля.

Конкретная запись -- это определённым образом упакованное локальное окружение, включающее связь каждой метки с её значением.

Обращение к полям записи осуществляется указанием метки с префиксом записи.

```
let barsik_age = barsik.age
```

Записи одного типа считаются равными, если совпадают все значения, ассоциированные с соответствующими метками.

Записи одного типа можно сравнивать -- в лексикографическом порядке полей.

```
type R1 = { f1 : int; f2 : int }
let v1 = { f1 = 1; f2 = 1000 }
let v2 = { f1 = 2; f2 = 3 }
v1 < v2 // true 
```

**24.3. Шаблоны записей**

В шаблонах записей, использующихся в операциях сопоставления, вместо конкретных значений меток задаются идентификаторы.

```
let { name = n; age = a; sex = s } = barsik
printfn "%d %s %c" a n s // 5 Barsik M
```

Символ "_" может использоваться для сопоставления любому значению.

```
let cat_age { name = _; age = a; sex = _ } = a
printfn "%d" (cat_age barsik) // 5
```

**24.4. Задание**

Время дня может быть представлено тройкой (часы, минуты, половина дня), где часы принимают значение в диапазоне от 0 до 11, минуты -- от 0 до 59, и половина дня -- это либо "AM" (первые 12 часов), либо "PM" (вторые 12 часов).

Реализуйте инфиксный оператор .>. , который сравнивает два корректных значения типа TimeOfDay.

Шаблон для отправки на сервер:

```
type TimeOfDay = { hours: int; minutes: int; f: string }

let (.>.) x y = ...
```

### 25. Генерация исключений

Функции во время работы могут генерировать исключительные ситуации.

Пользовательский тип исключения задаётся инструкцией

```
exception тип-исключения
```

Генерация исключения выполняется командой

```
raise тип-исключения
```

```
exception CatExc

let cat_age { name = _; age = a; sex = _ } = 
       if a >= 0 then a * 4 else raise CatExc
```

Встроенная функция failwith принимает параметром строку и формирует исключение с текстом-сообщением этой строки.

```
let cat_age { name = _; age = a; sex = _ } = 
       if a >= 0 then a * 4 else failwith "negative age"
```

### 26. Локальные идентификаторы

Внутри функций можно объявлять другие функции и идентификаторы, которые будут доступны (видны) только в пределах родительской функции.

```
let circleLenOrArea R getLen = 

    let pi = 3.14159 // локальный идентификатор

    // две локальные функции:
    let circleLen R = 2.0 * pi * R
    let circleArea R = pi * R * R

    if getLen then
       circleLen R       
    else
       circleArea R
```

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/e943405754.html)**

---

**Ответы на задания 23**

```
let rec iter = function
    | (a, b, c) when c > 11 -> iter (a, b + (c / 12), c % 12)
    | (a, b, c) when b > 19 -> iter (a + (b / 20), b % 20, c)
    | (a, b, c) when c < 0 && b > 0 -> iter (a, b - 1, c + 12)
    | (a, b, c) when b < 0 && a > 0 -> iter (a - 1, b + 20, c)
    | (a, b, c) when c < 0 && a > 0 -> iter (a - 1, b + 19, c + 12)
    | (a, b, c) -> (a, b, c)

let (.+.) (a, b, c) (x, y, z) = iter (a + x, b + y, c + z)
let (.-.) (a, b, c) (x, y, z) = iter (a - x, b - y, c - z)

let (.+) (a, b) (c, d) = (a + c, b + d)
let (.-) (a, b) (c, d) = (a - c, b - d)
let (.*) (a, b) (c, d) = (a * c - b * d, b  * c + a * d)
let (./) (a, b) (c, d) = (a, b) .* (c / (c * c + d * d) , -d / (c * c + d * d))
```
