В заключение ещё раз коснёмся темы поддержки плавающих обновлений. Типична ситуация, когда приходится постепенно развёртывать новую версию сервиса не на всех узлах одновременно, а лишь на нескольких узлах за один раз.

Плавающие обновления дают возможность выпускать новые версии сервисов без вынужденного простоя системы, тем самым поощряя частые небольшие выпуски, а не редко выполняемые большие. Таким образом они существенно снижают риск развёртывания -- благодаря обнаружению и откату сбойных выпусков ещё до того, как они затронут большое количество пользователей. Эти качества чрезвычайно благотворно влияют на возможность развития системы и простоту внесения в неё изменений.

В случае применения плавающих обновлений, или по другим схожим причинам  **всегда приходится допускать возможность того, что на разных узлах будут работать различные версии кода нашего приложения** . Следовательно, важно закодировать все протекающие по системе и перетекающие между её подсистемами данные с поддержкой и **обратной совместимости** (новый код мог читать старые данные), и **прямой совместимости** (старый код мог читать новые).


Итак, в последней части данного курса мы обсудили несколько форматов кодирования данных и их свойства совместимости.
Ориентированные на конкретный язык программирования форматы кодирования ограничены этим языком и зачастую не могут обеспечить обратной и прямой совместимости.
Текстовые форматы наподобие JSON, XML и CSV широко распространены, и их совместимость зависит от способа их использования. В них есть необязательные дополнительные языки описания схем, иногда полезные, а иногда лишь мешающие. В этих языках типы данных иногда довольно расплывчаты, так что лучше быть осторожными даже с такими базовыми вещами, как числа и двоичные строки.

Форматы, основанные на двоичных схемах (например, Thrift, Protocol Buffers и Avro), позволяют выполнять сжатое и эффективное кодирование с чётко определенной семантикой обратной и прямой совместимости. Их схемы могут оказаться полезны в целях документирования и генерации кода в языках программирования со статической типизацией. Однако у них есть недостаток: данные необходимо специально декодировать, чтобы люди смогли их читать.

Мы также обсудили несколько режимов движения потоков данных, в которых формат кодирования данных играет важную роль:

- базы данных, где записывающий в базу процесс кодирует данные, а читающий из нее -- декодирует;
- RPC и реализации REST API, в которых клиент кодирует запрос, сервер декодирует запрос и кодирует ответ, и наконец, клиент декодирует ответ;
- асинхронная передача сообщений (с помощью брокеров сообщений или акторов), где узлы взаимодействуют путем отправки друг другу сообщений, кодируемых отправителем и декодируемых получателем.


## Поздравляю с успешным завершением курса!

На следующих курсах, более детально : распределённая обработка данных, репликация, секционирование, согласованность, обработка сбоев и отказов, консистентность, транзакции и т. д. и т. п.
