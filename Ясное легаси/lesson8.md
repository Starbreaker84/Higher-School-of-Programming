### Продуктивное внесение изменений в легаси-код

18. Проблема. Мы изучили несколько основных способов разрыва зависимостей и написания тестов, делающих грядущие изменения в код более безопасными и понятными. Однако такая работа требует времени, и подчас довольно большого. Например, нередки ситуации, тесты для кода, который требуется изменить, пишутся два часа, а само изменение кода требует около 15 минут.

Решение. Неважно, сколько времени вы потратили в итоге: перед началом этой работы вы всё равно не можете заранее сказать, сколько времени у вас уйдёт. Вам, возможно, просто повезло, что получилось внести правки за 15 минут, но не исключено, что вы могли что-то поломать, и тогда на такую работу потребовалось бы в десятки раз больше времени.

Речь тут не только о времени, которое можно сэкономить, если тесты выловят ошибку, но и о том времени, которое тесты позволяют сэкономить в процессе как обнаружения будущих ошибок, так и понимания кода, подвергаемого изменению. Если же код хорошо окружён тестами, то практически всегда его функциональные недостатки выявить легче и проще. Сами разработчики со временем понимают, что это самый лучший способ продвигаться в работе вперед.

### Продуктивное внесение изменений в легаси-код

19. Проблема. Вы заранее никогда не знаете более-менее точно, сколько времени потребуется на добавление в проект новой фичи. Такая оценка особенно затруднительна для унаследованного кода.

Решение. Начинайте писать тесты по TDD для новой фичи, и модульные тесты для тех мест в существующем коде, которые эта фича потенциально затрагивает. В противном случае вы невольно поддаётесь искушению ввести эту фичу наспех и побыстрее, а тесты будут писаться уже по ходу внесения изменений -- но при этом придётся примириться с тем фактом, что со временем делать тесты для этой фичи будет всё труднее.

### Продуктивное внесение изменений в легаси-код

20. Проблема. В систему требуется ввести новое свойство, которое можно выразить в виде совершенно нового кода, но места его использования протестировать трудоёмко.

Решение. Оформите этот код в новом методе, применяя TDD, а затем вызывайте его из тех мест, где требуются новые функциональные возможности. Определите в точках его вызова все локальные переменные, и оформите их как аргументы в новом методе. По крайней мере, вы cможете в таком случае написать тесты для нового кода.

### Продуктивное внесение изменений в легаси-код

21. Проблема. Оформить новую функциональность полностью независимой от контекста её вызова нереально (например, требуется активно использовать унаследованные глобальные переменные).

Решение. Оформите этот код хотя бы как глобальный статический метод (или автономную функцию, если язык позволяет) с параметрами, чтобы не копипастить его везде.

### Продуктивное внесение изменений в легаси-код

22. Проблема. Новую функциональность удаётся оформить полностью независимой, в виде метода внутри класса, но для нужд тестирования отсутствует возможность создавать объекты этого класса (например, это требует много времени), а следовательно, нету и возможности для его тестирования.

Решение. Создайте другой класс, в котором будет независимо реализован нужный метод с аккуратно подобранными параметрами, и добавьте его методом композиции в оригинальный класс.

### Продуктивное внесение изменений в легаси-код

23. Проблема. Подобные "отпочковавшиеся" классы подчас превращаются из вторичных вспомогательных сущностей, которые не соответствуют никаким АТД, в полноценные новые и довольно странные "понятия" в проекте, которые имеют тенденцию к самостоятельному развитию. Отпочковавшийся класс нередко воспринимается совсем иначе, когда он только что создан, и несколько месяцев спустя. Сам факт наличия дополнительного нового класса в системе усложняет её. Если требуется внести изменение, косвенно затрагивающее этот класс, то следует вносить такое изменение в новую сущность, или же лучше изменить оригинальный класс?

Решение. Готового нету, это просто естественный непрерывный процесс (пере)проектирования системы.

### Продуктивное внесение изменений в легаси-код (задания)

======= 21. Когда добавляем в легаси-проект новую фичу, ошибкой будет ...

[ 1] писать тесты непосредственно в процессе изменения кода

[ ] покрывать юнит-тестами место потенциального изменения

[ ] применять TDD для новой фичи

======= 22. Если требуется внести изменение, косвенно затрагивающее существующий класс, то ...

[ ] новую функциональность оформляем полностью независимой

[ ] изменяем оригинальный класс

[ 1] смотрим по ситуации
