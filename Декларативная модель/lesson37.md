## Абстракция цикла

Как мы видели, циклы в декларативной модели как правило многословны, потому что им нужны явные рекурсивные вызовы. Эти рекурсивные петли можно сделать более лаконичными и универсальными, определяя их в виде абстракций. Существует много различных видов циклов, которые мы можем определить в декларативной модели.

В этом разделе мы сначала определим простые циклы в духе классических "for" в императивном программировании -- для работы с целыми числами и списками, а затем добавим к ним аккумуляторы, чтобы сделать их более полезными.

### 33. Целочисленный цикл

Классический цикл For получает четыре параметра: начальное и конечное значения цикла и шаг, и процедуру P, которая должна быть применена к каждому значению условного "счётчика" цикла.

```
function For(A, B, S, P)
   if A > B
      return
   end 
   P(A)
   For(A+S, B, S, P)   
end

For(1,10,3,println) # печать значений 1,4,7,10
```


### 34. Цикл по спискам

Цикл ForAll получает список и некоторую процедуру, которую применяет к каждому элементу списка.

```
function ForAll(Ls, P)
    if Ls == []
       return
    end
    head = Ls[1]
    tail = Ls[2:end]
    P(head)
    ForAll(tail, P)
end

ForAll([3,2,1],println) # печать каждого элемента списка [3,2,1]
```


### 35. Цикл с аккумулятором

Циклы For и ForAll сами по себе довольно бесполезны, если требуется не просто вывести данные, а выполнить над ними какие-либо вычисления (например, просуммировать элементы списка или целые значения в диапазоне). В декларативной модели циклы расширяются концепцией аккумулятора, который накапливает промежуточное значение.

Цикл для диапазона с шагом:

```
function ForAcc(A, B, S, P, Acc)
   if A > B
      return Acc
   end 
   Acc = P(Acc, A)
   ForAcc(A+S, B, S, P, Acc)   
end

function Sum(x,y)
  return x + y
end

# суммирование всех значении в диапазоне
println( ForAcc(1,5,1,Sum,0) ) 
```


Цикл для обработки списков:

```
function ForAllAcc(Ls, P, Acc)
    if Ls == []
       return Acc
    end
    head = Ls[1]
    tail = Ls[2:end]
    Acc = P(Acc, head)
    ForAllAcc(tail, P, Acc)
end

function Sum(x,y)
  return x + y
end

println( ForAllAcc([3,2,1],Sum, 0) ) # сумма всех элементов списка
```

Этот итеративный способ по сути работает как FoldL -- аналог FoldR, только с левой ассоциацией, когда мы не раскручиваем цепочку вычислений до конца, а вычисляем значения сразу, непосредственно начиная с самого левого элемента.

На самом деле, и FoldR – это тоже по сути цикл с аккумулятором, только аккумулятор там скрытый, добавляется компилятором.


### 36. Свёртка списка и дополнительные способы поддержки циклов

Существует ещё одна схема цикла с аккумулятором для списка. **Свёртка (folding)** фактически означает, что мы "вставляем" операцию между значениями списка:

```
"+" [1,2,3] = 1 + 2 + 3
```

Способ вычисления такой конструкции отдаётся компилятору, что позволяет достигать хорошей производительности -- например, за счёт распараллеливания.

В языках программирования, в том числе и декларативных, могут реализовываться самые разные лингвистические способы поддержки циклов. Классическая запись цикла
**for заголовок тело**
по сути эквивалентна схеме, когда тело выделяется в отдельную процедуру, и она многократно вызывается, получая в качестве параметра счётчик цикла.

Однако имеется фундаментальное различие между декларативным и императивным определениями циклов. В последнем случае счетчик циклов -- изменяемая переменная, которой присваивается разное значение для каждой итерации. Декларативный цикл совершенно другой: на каждой итерации он фактически объявляет новую переменную, хотя обращение к ней происходит по одному и тому же идентификатору. Такая разница даёт серьёзные последствия.

В частности, **итерации декларативного цикла полностью независимы от друг друга** -- таким образом, их можно выполнять одновременно, не меняя окончательный результат работы цикла. А так как никаких состояний в смысле классических переменных в декларативной модели нету, то и не возникают типовые проблемы конкуренции, которые мы изучали на первом курсе по парадигмам программирования.

А вот сделать так в императивном цикле практически невозможно: внутри каждой итерации больше нельзя быть уверенным, что она получает доступ к правильному значению счётчика цикла, если попытаться выполнять все итерации одновременно.

Аналогично во многих языках программирования имеется синтаксическая версия итерации по спискам -- например, цикл foreach, а что касается свёртки списка, то в стандартные библиотеки часто включаются функции map/reduce, выполняющие вычисления по свёртке и foldL/R.

В декларативной схеме цикла возможны конечно ещё многие другие дополнительные расширения. Например: немедленный выход из цикла (break), немедленный выход и возврат явного результата (return), немедленное выполнение следующей итерации (continue), итераторы по спискам наподобие foreach, и другие процедуры, "подразумевающие" цикл (нахождение суммы элементов списка, максимальное значение в списке и т. п.).


### Абстракция цикла (задания)

======= 74. Абстракция цикла в декларативной модели -- это ...

[x]рекурсия

[ ]синтаксический сахар For

[ ]FoldL

======= 75. Свёртка списка -- это ...

[ ] FoldR

[ ] FoldL

[x] версия цикла с аккумулятором

======= 76. Итерации цикла полностью независимы от друг друга...

[x] в декларативной модели

[ ] в императивной модели

[ ] в декларативной и императивной моделях
