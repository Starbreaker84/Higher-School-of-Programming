### Заключение

Отметим высокую практическую полезность dataflow-вычислений:

- Это очень мощный примитив не только в декларативной модели, но и во всём параллельном программировании. Он может
  использоваться и для синхронизации нитей, и для взаимодействия между ними, позволяя, в частности, существенно
  упростить многие классические низкоуровневые механизмы одновременных вычислений.
- Он устраняет зависимости порядка вычислений между частями программы. Точнее говоря, он заменяет статические
  зависимости (определяемые программистом) динамическими зависимостями (определяемыми данными). Это основная причина, по
  которой dataflow-вычисления так полезны в параллельном программировании. Выходные данные одной части программы могут
  быть переданы непосредственно в качестве входных данных для следующей части -- независимо от того, в каком порядке
  выполняются эти две части, что напрямую позволяет применять параллельную модель. Вторая часть заблокируется
  автоматически и только в случае необходимости, т. е. только если ей нужен результат первой части, а он ещё не
  доступен.
- Это мощный примитив для распределённого программирования. Dataflow-переменная может передаваться между сущностями
  произвольным образом. В любой момент времени она помнит свое "происхождение" в том смысле, что информация, необходимая
  для связывания переменной -- это часть самой переменной, а не программы, манипулирующей этой переменной.
- Он позволяет выполнять декларативные вычисления с частичной информацией (когда мы рассматриваем частичные значения как
  полные, которые известны лишь частично). Это мощная идея, которая в дальнейшем используется в программировании с
  ограничениями.
- Он позволяет декларативной модели поддерживать логическое программирование, то есть многим декларативным программам
  можно придать логическую семантику, что позволяет рассуждать о них на очень высоком уровне абстракции. С исторической
  точки зрения, dataflow-переменные потока данных были первоначально открыты (это научные находки, а не инженерные
  конструкции) в контексте параллельного логического программирования, где они называются логические переменные.

### 18. Синхронизация

======= 51. Синхронизация подразумевает ...

[ 1] взаимодействие нитей через общие dataflow-переменные

[ ] взаимодействие нитей с помощью внешнего по отношению к ним механизма

======= 52. Когда операция синхронизируется по доступности аргументов, это ...

[ 1] жадное выполнение

[ ] ленивое выполнение

======= 53. Когда операция синхронизируется по вычислению аргументов, это ...

[ ] жадное выполнение

[ 1] ленивое выполнение



### Заключение

Более глубокое видение dataflow-переменных заключается в том, чтобы рассматривать их как нечто среднее между отсутствием состояния и наличием состояния.

- **Dataflow-переменная имеет состояние** , поскольку она может менять своё состояние (т.е. либо быть несвязанной со значением, либо связанной) -- но она может быть связана только с одним значением на всё время своего существования. Такое dataflow-состояние может быть использовано для получения некоторых выгод stateful-программирования, оставаясь в рамках декларативной модели.
- **Dataflow-переменная не имеет состояния** , потому что её связывание монотонно. Под монотонностью подразумевается, что в саму концепцию связывания можно включить больше информации, но никакая информация в дальнейшем не может быть изменена или удалена. Предположим, что переменная связывается с частичным значением. По мере выполнения программы всё большая часть частичного значения будет "появляться" в этой переменной (потому что происходит связывание хвостовых несвязанных переменных внутри частичного значения). Но сами эти привязки не могут быть изменены или отменены.

Аспект stateless может быть использован для получения некоторых преимуществ декларативного программирования в рамках недекларативной модели (согласование импедансов). Например, можно легко добавить параллелизм как в декларативную, так и в недекларативную модель именно потому, что нити взаимодействуют через общие dataflow-переменные со своим уникальным поведением.

---

P. S. В качестве практики предлагаю разобрать [вот этот неплохой обзорный материал ](https://habr.com/ru/post/587750/)основных параллельных архитектур, их плюсы и минусы -- с точки зрения подхода, рассмотренного на данном курсе.
Сможете вы применить dataflow-парадигму к проблемам, упоминаемым в этой статье? Напишите ваше мнение.
