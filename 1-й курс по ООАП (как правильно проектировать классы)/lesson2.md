## АТД Stack

На основании [оригинального занятия по алгоритмам](https://skillsmart.ru/algo/15-121-cm/e192yed1ab.html) попробуем сформировать предварительный АТД Stack. Это будет стек целых чисел (обобщение на любой тип значений в стеке рассмотрим позже), и пять допустимых операций над ним:

- push(), добавляющая свой аргумент новым верхним элементом в стек;
- pop(), возвращающая верхний элемент стека и одновременно удаляющая его;
- peek(), возвращающая верхний элемент стека;
- size(), возвращающая количество элементов в стеке;
- clear(), очищающая весь стек.

Это пока не очень формальная, но вполне допустимая спецификация АТД, на основании которой любой программист успешно создаст реализующий её класс.

### Но в чём тогда разница между АТД и классом?

Почему бы сразу не записать в программе нужный класс?

Когда мы говорим про ООП, мы всё же подразумеваем в первую очередь **ООАП (объектно-ориентированный анализ и проектирование)**, потому что **программирование -- это всегда и прежде всего про проектирование**. Хорошие разработчики думают о системе всегда абстрактно, поднимаясь выше конкретных реализаций. Чем сильнее и опытнее проектировщик, тем более мощные и выразительные абстракции ему удаётся найти, придумать, задействовать.

АТД -- это самый первый шаг вверх, в мастерство проектирования, который доступен всем. В некотором смысле это и технический приём, когда мы принципиально отходим от уровня кода, чтобы думать о системе в более выразительных и более универсальных концепциях.

*В некотором смысле АТД можно понимать как абстрактные классы, явно поддерживаемые в ряде языков программирования.*

**Класс -- это базовая строительная единица в нашей программе**, она сочетает свойства и **типа данных** как семантической единицы, и **модуля**, объединяющего данные и вычисления, и выделяющего код в отдельную синтаксическую единицу.

В объектно-ориентированном программировании и проектировании за основу нашей программы, нашей системы мы берём не функции, а абстрактные типы данных, которые одновременно обеспечивают и модульную структуру системы. При этом модуль опирается на конкретный тип данных (класс), а не на набор функций, что очень позитивно сказывается на гибкости и расширяемости всей системы в целом.

**Класс -- это реализация АТД**,
или
**формально записанный в коде АТД, дополненный реализацией (возможно, не полной)**.

В классе общедоступна, публична только спецификация АТД, а всё остальное, все вспомогательные методы и поля, инкапсулировано, приватно и закрыто для внешнего мира.
Класс не отражает очевидные на первый взгляд объекты в программе напрямую -- он реализует, описывает АТД, где все операции чётко (в идеале, формально) заданы. **Добавление нового класса в программу определяется исключительно наличием в проекте определяющего этот класс АТД.** Во всех других случаях нужную логику, сущность, понятие надо реализовывать силами уже имеющейся в программе системы типов, не расширяя её.

*Тут надо избегать типичной ошибки новичков, когда пытаются создать новый класс, но нужна просто функция. Теме правильного нахождения, выделения классов (фаза анализа) посвящён отдельный курс.*

В частности, для удобства обычно вводятся три категории классов, или три категории АТД. Каждая категория подразумевает свои методы подбора классов при построении модели системы.

Во-первых, это **классы анализа** -- классы, реализующие АТД, непосредственно относящиеся к предметной области. Например, это может быть АТД Смартфон, или Гном, или Собака.

Во-вторых, это **классы реализации**, которые нужны, чтобы реализовывать некоторые внутренние понятия, непосредственно относящиеся к алгоритмам (например, АТД Список или Стек).

В-третьих, это **классы проектирования**, требуемые для реализации архитектуры системы в целом. Это наиболее трудно выявляемая категория, требующая хорошего опыта в проектировании систем. Нередко используют готовые классы проектирования, определённые в так называемых **паттернах проектирования**.

### Процесс проектирования классов

Процесс непосредственного проектирования классов подразумевает, что **у нас уже есть полный, но неформализованный перечень требований к классу**. Как эти требования выделять, как оценивать их полноту -- тема отдельного курса по объектно-ориентированному анализу и моделированию. Нередко подготовкой таких требований занимаются другие специалисты, но самый сильный подход конечно, когда разработчик уверенно владеет всем перечнем методик проектирования и реализации.

На данном курсе мы рассматриваем классы не как подсистемы (взаимосвязанные элементы более крупной системы), а как **автономные сущности, хорошо решающие одну конкретную задачу**, причём требования к ним уже кем-то хорошо сформулированы. Сейчас у нас цель -- научиться мыслить о классической программной реализации классов на более высоком уровне абстрактных типов данных.

В некотором смысле это подход, ориентированный на повторное использование компонентов при создании стандартных библиотек, однако именно поэтому он хорошо себя оправдывает в прикладных проектах. Мы создаём достаточно универсальные и независимые сущности, которые легко разрабатывать, применять, тестировать и повторно использовать в других проектах.
