## Исключения и частичные функции

**28. Исключения**

Исключительные ситуации отслеживаются в F# с помощью выражения try with, где после with через символ | задаются типы контролируемых исключений.

```
exception DivZero

let div x y = if y = 0 then raise DivZero else x / y
 
try
    div 2 0
with
    | DivZero ->
          printfn "Divide By Zero!"
          0
```

Если требуется отследить стандартную исключительную ситуацию .NET, в правиле сопоставления с шаблоном надо придерживаться следующего синтаксиса:

```
:? (exception имя-стандартного-исключения) as имя-идентификатора 
```

Имя идентификатора при возникновении исключения связывается с текстовым описанием ошибки.

```
try
  div 2 0
with
  | :? System.DivideByZeroException as ex -> 
        printfn "Divide By Zero!"
        1
  | _ as ex ->
        printfn "%s" (string ex)
        0
```

**29. Частичные функции**

Частичная функция -- это функция, определённая только на некотором подмножестве значений своих аргументов.

В F# возможны три случая, когда функция не определена:

1) вычисление функции не завершается (например, происходит бесконечная рекурсия);
2) вычисление функции завершается возникновением исключения (например, деление на ноль);
3) вычисление функции возвращает значение особого, опционального типа option, явно обозначающее её неопределённость для заданных аргументов.

Опциональный тип option (частный случай размеченного объединения) допускает всего два значения: None (отсутствие значения или неуспех) и Some, где Some -- полиморфный конструктор значений, принимающий любые типы.

```
let div x y = if y = 0 then None else Some(x / y)
let r = div 2 0 // r = None
printfn "%s" (string r) // ничего не будет напечатано
```

Извлечение конкретного значения из Some выполняет функция Option.get().

```
let div x y = if y = 0 then None else Some(x / y)
let r = div 4 2 // r = Some(2)
printfn "%d" (Option.get r) // 2
```

Пример использования option в частичной функции факториала:

```
let rec factorial = function 
 | 0  -> Some(1)
 | n when n > 0 -> Some(n * Option.get(factorial(n - 1)))
 | _  -> None
```

**[[ далее ]](https://skillsmart.ru/fp/fsh/ed44a53c6e.html)**

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/d0a0708sf7.html)**

---

**Ответы на задания 27**

```
type F = 
  | AM
  | PM

type TimeOfDay = { hours : int; minutes : int; f: F }

let transform (x: TimeOfDay) = 
    if x.f = PM then (x.hours + 12) * 60 + x.minutes
    else x.hours * 60 + x.minutes

let (.>.) x y = (transform x) > (transform y) 
```
