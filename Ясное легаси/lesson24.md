### Копипаста

74. Проблема. Нередко достаточно очевидное изменение в системе реализуется легко, но потом оказывается, что его приходится вносить снова и снова, поскольку в системе обнаруживаются десятки мест с аналогичным кодом. Однако логика напрашивающегося рефакторинга неочевидна.

Например, в легаси-проекте обнаружен метод

```
void c() 
{ a(); a(); b(); a(); b(); b(); } 
```

Его можно реорганизовать так:

```
void c() { aa(); b(); a(); bb(); } 
```

или же так:

```
void c() { a(); ab(); ab(); b(); }
```

Решение. Это, опять-таки, вопрос мышления не на втором, а на третьем уровне. Пока мы пытаемся решать такие проблемы на уровне кода, который по определению не содержит никакой мета-информации о своей логике, о своих абстракциях, ничего особо хорошего не выйдет.

Если в подобных случаях два метода/функции выглядят почти одинаково, или вызываются некоторой повторяемой комбинацией, примените SRP к уровню реализации: выделите общее из этих методов в один метод, а их явные различия переместите в другие методы. В результате и интерфейс приблизится к SRP.

### Для гигантского метода невозможно даже написать тесты

75. Проблема. Весьма часто в больших методах/функциях плохо всё: и форма (сплошняком написанный невразумительный код без отступов), и содержание (глубокие вложения условий и циклов). Написать для них тесты, позволяющие объективно продемонстрировать и проверить их поведение, очень трудно.

Решение. Сначала пишем регрессионные тесты для той логики, которая очевидна и уже существует "явно" (вызовы тестируемых методов по каким-то типичным сценариям внутри проекта), а затем пытаемся извлечь и выделить менее очевидную логику, которую эти тесты не покрывают.

### Для гигантского метода невозможно даже написать тесты

76. Проблема. Как лучше и безопаснее выполнять рефакторинг крупного метода?

Решение. После того, как созданы регрессионные тесты для ситуации as is, создаём новый класс, единственной ответственностью которого будет выполнение логики гигантского метода (принцип вымышленной абстракции) с возможностью её постепенной декомпозиции. Параметры крупного метода становятся параметрами конструктора нового класса, а сам его код переносится в метод с условным названием run или execute. Далее локальные переменные этого метода преобразуем в атрибуты класса, после чего начинаем аккуратное разделение метода на части (более мелкие методы с соблюдением SRP). В результате получается т.н. скелетное представление, потому что от исходного метода остается лишь скелет -- управляющая структура, а различная логика делегируется другим методам, которые удобно тестировать по раздельности. Код следует извлекать как минимум вначале небольшими фрагментами.

### Для гигантского метода невозможно даже написать тесты

77. Проблема. Когда извлекаем небольшой фрагмента кода из гигантского метода, создается впечатление, что это мало что дает, а класс быстро разрастается большим числом таких мелких методов.

Решение. Надо довести эту процедуру до конца: оставить от исходного метода только управляющий скелет. Да, возможно появится большое количество небольших методов, но зато будет сформировано полноценное представление об исходном методе. В частности, в нём можно обнаружить различные паттерны: последовательности операций, которые раньше были незаметными, или же выявить более совершенный способ организации данного метода. В результате мелкие методы, вполне возможно, получится вновь объединить в более крупные, тут главное -- получить итоговое понимание. В любом случае, это намного лучшая стратегия, нежели попытки разделения метода на "естественно" (и очень часто, ошибочно) напрашивающиеся крупные фрагменты с самого начала.

Этот же подход работает и применительно ко всей легаси-системе в целом. Выполняя её реорганизацию и рефакторинг сперва просто в целях покрытия тестами под требуемые изменения, вы получаете всё большее понимание и всё больший контроль над всей кодовой базой, и постепенно начнете писать всё более качественный код всё быстрее и быстрее.

### Сдаёмся

И вот когда вы добрались до данного момента, многократно применив все рекомендации курса на практике, и получили некоторое понимание легаси-базы (возможно 5%, возможно 50%, возможно 95%), и чувствуете, что дальнейшее её улучшение невозможно (ну или требует усилий, совершенно неадеватных результату) -- **сдайтесь** :)

Продолжайте вносить требуемые изменения тем темпом, который удалось достичь.

### Заключительные моменты (задания)

======= 64. В системе обнаруживается много мест с похожим кодом ...

[ 1] применяем SRP к уровню реализации

[ ] применяем SRP к интерфейсам

======= 65. В гигантском методе плохо всё: и форма, и содержание ...

[ ] начинаем с юнит-тестов

[ ] начинаем с интеграционных тестов

[ 1] начинаем с регрессионных тестов

======= 66. Как безопаснее выполнять рефакторинг гигантского метода?

[1 ] начинаем с вымышленной абстракции

[ ] начинаем с разделения метода с соблюдением SRP

[ ] начинаем с регрессионных тестов

======= 67. Когда декомпозируем гигантский метод, класс разрастается мелкими методами ...

[ ] мелкие методы вновь объединяем в более крупные

[ 1] оставляем от метода только управляющий скелет

[ ] "естественно" делим метод на крупные фрагменты

======= 68. Все возможности исчерпаны...

[1 ] сдавайтесь :)
