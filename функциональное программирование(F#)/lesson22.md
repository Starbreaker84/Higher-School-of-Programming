## Часть 6. Модули, ООП и императивный стиль

### 44. Модули

**44.1. Абстракция**

Ключевая концепция проектирования хорошей библиотеки -- это абстракция.

Абстракция говорит, что пользователь может делать, но скрывает от него, как это делается.

Абстракция на семантическом уровне описывается с помощью

1) интерфейса, задающегося набором типов,
2) реализации, состоящей из значений, функций, вычислений.

Модуль -- это удобное средство для создания абстракций и объединения логически связанных элементов программы в одно целое.

Модуль задаётся ключевым словом module в начале файла, и следующим за ним названием модуля.

```
module Test1
```

**44.2. Релизация модуля**

На синтаксическом уровне абстракция модуля задаётся спецификациями.

```
type имя-типа ...
val имя = тип
```

Эта часть называется сигнатурой модуля.

Можно указывать только одно имя типа, скрывая его реализацию.

```
type имя-типа
```

Модули могут состоять из нескольких файлов; компилируются модули в библиотеки.

Первый файл модуля с расширением .fsi содержит сигнатуру модуля (спецификация интерфейса), а другие, с исходным кодом, содержат реализацию модуля.

Сущности, объявленные только в реализации модуля, недоступны пользователям библиотеки.

**44.3. Пример модуля**

Создаётся модуль с определением двумерной точки Point, состоящей из двух вещественных значений x и y.

Реализация модуля:

```
module Point

type Point = P of float * float

let create (x,y) = P(x,y)
let (.+.) (P(x1,y1)) (P(x2,y2)) = P(x1+x2,y1+y2)
let getx (P(x1,y1)) = x1
let gety (P(x1,y1)) = y1
```

Сигнатура модуля:

```
module Point

type Point

val create : float * float -> Point
val (.+.) : Point -> Point -> Point
val getx : Point -> float
val gety : Point -> float
```

Для обращения к элементам модуля надо указать его название после ключевого слова open.

Использование модуля:

```
open Point
let p1 = create(1.0, 1.0)
let p2 = create(2.0, 2.0)
let p3 = p1 .+. p2
printfn "%f" (gety p3)
```

**44.4. Параметризованные модули**

Модуль может параметризоваться переменной типа, реализуя тем самым полиморфные типы, функции и значения.

Например, тип Очередь удобно реализовывать независимым от типов хранимых в очереди значений.

Сигнатура модуля может выглядеть так:

```
module Queue
type Queue<'a>
...
```

Реализация модуля:

```
module Queue
type Queue<'a> = {front: 'a list; rear: 'a list}
let empty = {front = []; rear = []}
...
```

Использование модуля:

```
let int_queue = Queue.empty : Queue.Queue<int>
...
```

**[[ далее ]](https://skillsmart.ru/fp/fsh/f57f33c802.html)**

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/bc3d56c4b4.html)**

---

**Ответы на задания 43**

```
let rec search (list, key) = 
     match list with 
         | (k, v) :: tail when k = key -> Some(v) 
         | (k, v) :: tail -> search (tail, key) 
         | [] -> None
let try_find key m = search (Map.toList m, key)
```
