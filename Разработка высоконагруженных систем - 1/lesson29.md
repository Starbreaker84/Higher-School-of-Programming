### 22. Эволюция схемы

Схемы в проекте неизбежно меняются с течением времени. Такой процесс называется  **эволюцией схемы** .

Рассмотрим её на примере проекта [Avro](https://avro.apache.org/) – системы сериализации данных, развиваемой в рамках проекта Hadoop (распределённая работа с Big Data). Avro во многом ориентирована на принцип динамически генерируемых схем. Например, имеется реляционная база данных и необходимо выполнить дамп её содержимого в файл, причём хотелось бы задействовать двоичный формат во избежание вышеупомянутых проблем с текстовыми форматами (JSON, CSV, SQL). С помощью Avro можно довольно легко из реляционной схемы сгенерировать схему Avro (в JSON-представлении) и далее закодировать содержимое БД с помощью этой схемы, выгрузив его полностью в объектный файл-контейнер. Для каждой таблицы БД генерируется своя схема записей, а каждый столбец становится полем в этих записях. Названию столбца в базе ставится в соответствие название поля в Avro.

Теперь, если схема оригинальной базы данных поменяется (например, в таблице один столбец будет добавлен, а другой — удалён), то можно просто сгенерировать новую схему Avro на основе обновленной схемы БД и экспортировать данные в этой новой схеме. Изменения схемы на процесс экспорта данных, очевидно, не влияют: достаточно просто выполнять преобразование схемы при каждом экспорте. Тогда все, кто будет читать новые файлы данных, увидят, что поля записей изменились, но поскольку они идентифицируются по именам, обновленную схему для записи можно будет без проблем сопоставить со старой схемой для чтения.

Другие форматы (например, Thrift и Protocol Buffers) основываются на генерации кода: после описания схемы можно сгенерировать код, «реализующий» её (обеспечивающий сериализацию и десериализацию) на выбранном языке программирования. Это удобно для языков программирования со статической типизацией (Java, C++, C#), поскольку можно использовать для декодированных данных эффективные структуры данных в оперативной памяти.

В языках программирования с динамической типизацией (JavaScript, Ruby или Python) смысла в кодогенерации кода практически нет, поскольку типы во время компиляции не проверяются. К генерации кода поддержки схем на таких языках лучше относиться неодобрительно.

Итак, хотя текстовые форматы данных JSON, XML и CSV широко распространены, форматы двоичного кодирования, основанные на схемах -- тоже вполне приемлемое решение, хотя и менее распространённое и поэтому хуже формализованное. Но зато они обеспечивают гораздо лучшую компактность, чем например «двоичный JSON», поскольку не требуют включать названия полей в закодированные данные.

Схема сама по себе -- важный вид проектной спецификации и «автоматической» документации, и поскольку она постоянно необходима для декодирования, вы всегда можете быть уверены в её актуальности (в то время как поддерживаемая вручную документация легко может оказаться устаревшей).

СУБД, поддерживающая схемы, позволяет проверять прямую и обратную совместимость изменений схемы до развертывания приложения.

Если в проекте используются языки программирования со статической типизацией, может оказаться полезной возможность генерировать код на основе схемы, обеспечивающая проверку типов во время компиляции.

Поддержка схем, допускающая их корректную эволюцию, предоставляет разработчикам фактически такую же гибкость, что и бессхемные (или «схема при чтении») базы данных, обеспечивая при этом гораздо лучший инструментарий и гораздо эффективнее защищая целостность и корректность данных.


## Эволюция схемы (задания)

======= 96. Эволюция схемы важна больше всего ...

[ ] для экспорта данных

[1] для импорта данных

[] и для того, и для того

[ ] ни для того, ни для другого

======= 97. Непосредственную поддержку схем в приложении правильно делать, если используются языки ...

[ ] с динамической типизацией

[ 1] со статической типизацией

[ ] любые

======= 98. Двоичное кодирование на базе схем ...

[] лучше, чем двоичные форматы JSON/XML

[ ] хуже, чем двоичные форматы JSON/XML

[ ] одинаково по эффективности
