### Неизвестно даже, какие вообще методы тестировать

43. Проблема. Тесты надо писать для каждого изменяемого метода, но этого достаточно, только если код простой и понятный. Практически всегда в унаследованным коде ситуация совершенно другая: изменение в одном месте может повлиять на поведение в совершенно другом месте, и если там не подготовлен подходящий тест, то мы не узнаем о том, что что-то где-то сломалось.

Решение. Пока что мы рассматривали проблемы в основном в формате "от следствия к причине, от проблемы к ее источнику". Однако для хорошего понимания унаследованного кода полезно задавать и другой вопрос: если мы внесем вот это конкретное изменение, то как оно повлияет на результаты работы каких-то других частей проекта? Тут требуется осмысление уже в прямом направлении -- от точек весения изменений к следствиям этого изменения. Посмотрите, в частности, материал из Сильных Идей "44 правильных вопроса при разбирательстве с легаси" (как постепенно погружаться в понимание кода, расширяя это понимание).


### Неизвестно даже, какие вообще методы тестировать

Воздействия распространяются в коде тремя основными путями:

1. Возвращаемые значения, используемые в вызывающей части программы.
2. Модификация объектов, передаваемых по ссылке в качестве параметров.
3. Модификация статических или глобальных данных (наиболее трудно выявляемые и самые незаметные способы воздействия одного фрагмента кода на другой).

И наоборот, если код хорошо структурирован, все компоненты независимы, то у методов будут простые и понятные схемы влияния на окружение. **Идеальная система спроектирована так, что любое сложное воздействие на внешнее окружение легко декомпозируется в линейную сумму более простых и прозрачных воздействий.** Для этого надо максимально придерживаться практик декларативной вычислительной парадигмы.


### Неизвестно даже, какие вообще методы тестировать

Одно из несомненных преимуществ ООП -- инкапсуляция. В качественно инкапсулированном коде оказывается совсем немного простых и понятных путей для понимания его логики.

44. Проблема. Некоторые (многие) способы разрыва зависимостей приводят к нарушению инкапсуляции, так как подразумевают вытаскивание "наружу" различных атрибутов, отвечающих за состояние, которые надо тестировать. Например, добавление в конструктор нового параметра для разрывания зависимости в свою очередь добавляет ещё один путь, который придётся прослеживать при осмыслении воздействий.

Решение. Нарушение инкапсуляции иногда усложняет осмысление кода, но оно может его и упростить, если мы создадим тесты, наглядно и непосредственно объясняющие логику этого кода. Между хорошей инкапсуляцией в парадигме АТД и покрытием тестами конечно существует антагонистическое противоречие, и хотя оно не всегда проявляется явно, на практике, **при разбирательстве с легаси-системой, выбор всё же лучше делать в пользу покрытия тестами** -- проще всего, через добавление геттеров (а иногда и сеттеров). Главное, не допускать потенциальной возможности прямой модификации полей класса в обход его методов, где можно хотя бы инвариант класса удерживать в корректном состоянии.


### Неизвестно даже, какие вообще методы тестировать (задания)

======= 37. Какая схема распространения воздействий в коде наиболее естественна?

[ 1] возвращаемые значения, используемые вызывающим кодом

[ ] модификация объектов, передаваемых по ссылке в качестве параметров

[ ] модификация статических или глобальных данных

======= 38. Между инкапсуляцией и покрытием тестами существует антагонистическое противоречие. Выбираем ...[ ] в пользу инкапсуляции

[ 1] в пользу покрытия тестами

[ ] в пользу геттеров-сеттеров
