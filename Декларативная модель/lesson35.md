## Программирование высшего порядка

Программирование высшего порядка представляет собой набор методов программирования, которые становятся доступными при использовании **значений процедур** в программах. Под значениями процедур понимается, во-первых, наличие в системе типа данных "процедура", и соответственно, во-вторых, любая реальная процедура, определённая в программе, автоматически становится значением (как число, строка, список), которое можно передавать в другие процедуры в качестве аргумента, или получать в качестве результата их работы.

Как правило, программирование высшего порядка связано с понятием  **лексического замыкания** , когда функция существует в программе как объект и может обращаться к внешнему контенту (например, локальным переменным в текущем блоке).

Термин "высший порядок" происходит от концепции  **порядка процедуры** . Процедура, все аргументы которой не являются процедурами, имеет нулевой порядок. Процедура, имеющая в аргументах хотя бы одну процедуру нулевого порядка, считается процедурой первого порядка.

И так далее: процедура имеет порядок n + 1, если у неё есть, по крайней мере, один аргумент порядка n и ни одного аргумента более высокого порядка.

По сути, программирование высшего порядка означает просто, что процедуры теперь могут быть любого порядка, а не только нулевого.

Существуют четыре основные операции, которые лежат в основе всех техник программирования высшего порядка:

1) **Процедурная абстракция** : способность преобразовывать любую программную логику в значение процедуры.
2) **Обобщение (Genericity)** : возможность передавать значения процедур в качестве аргументов при вызове другой процедуры.
3) **Инстанцирование** : возможность возврата процедурного значения как результата вызова процедуры.
4) **Встраивание** : возможность помещать значения процедур в структуры данных.

### 30. Процедурная абстракция

Процедурная абстракция подразумевает, что мы "упаковываем" инструкции в процедуру, помещая их внутрь заголовка процедуры, и получаем конструкцию (определение процедуры), которая сама по себе не выполняется, но считается процедурным значением (замыканием).

Выполнение процедуры даёт точно такой же результат, как и выполнение команд из её тела. Фактически процедура имеет смысл отложенного выполнения инструкций.

У процедурных значений имеются параметры, которые влияют на работу тела процедуры.

Процедурная абстракция чрезвычайно сильна. Она лежит в основе парадигмы программирования высших порядков, сегодня поддерживаемой многими популярными языками, и даже в основе объектно-ориентированного программирования, и поэтому чрезвычайно полезна для построения программистских абстракций.

*Ряд старых императивных языков поддерживает ограниченную форму процедурной абстракции. Процедуры в них либо все глобальны (не могут быть вложены друг в друга), либо видны только в пределах своего файла, что не позволяет полноценно применять программирование высших порядков, а из-за того, что замыкания реализованы неполноценно, наличие локальных переменных внутри процедур нередко приводит к висячим ссылкам, и к багам, когда программа становится достаточно крупной.*


### 31. Обобщения

Сделать функцию "общей" -- значит, позволить любой конкретной сущности (т.е. любой операции или значению) становиться аргументом в теле функции. Такая сущность абстрагируется от функционального тела, а конкретно задается, когда функция вызывается непосредственно. Каждый раз при вызове функции может быть задана другая сущность.

Например:

```
function SumList(Ls)
    if Ls == []
        return 0
    end

    head = Ls[1]
    tail = Ls[2:end]
    return head + SumList(tail)
end

println(SumList([1,5,3,7,9]))
```

В функции SumList имеется нейтральный элемент 0, не влияющий на результат, и операция "+", которые можно обобщить до любого нейтрального элемента и любой операции (функции с двумя аргументами).

```
function FoldR(Ls, F, U)
    if Ls == []
        return U
    end

    head = Ls[1]
    tail = Ls[2:end]
    return F(head, FoldR(tail, F, U))
end

function Plus(x, y)
    return x+y
end

function Mul(x, y)
    return x*y
end

println(FoldR([1,5,3,7,9], Plus, 0))
println(FoldR([1,5,3,7,9], Mul, 1))
```

Функция FoldR обобщила исходный код суммирования до универсального: она получает в дополнение к списку саму операцию (функцию F) и нейтральный элемент U, и теперь мы можем использовать её для всех похожих ассоциативных вычислений (когда порядок аргументов функции F не важен для её результата).

**FoldR** -- функция с таким названием существует во многих языках функционального программирования. Это  **функция-свёртка** , а буква R в её конце означает **правую ассоциацию** – схема её вызовов развёртывается в цепочку, пока не будет достигнуто самое крайнее (правое) значение в списке, после чего начнутся непосредственные вычисления.

FoldR часто используется для универсальной обработки списков. Например, создадим функцию, которая возвращает true, если хотя бы один элемент списка – true.

```
function tru(x, y)
    return x || y
end

function Some(L)
    return FoldR(L, tru, false)
end

println(Some([false,false,false,true]))
```

FoldR – это пример **абстракции цикла** (рассматривается далее).


### Программирование высшего порядка (задания)

======= 69. Программирование высшего порядка -- это ...

[ ]использование лексического замыкания

[ x]использование процедур/функций как значений

[ ]использование процедур нулевого порядка

======= 70. Процедурная абстракция -- это ...

[ ] глобальная видимость всех процедур в проекте

[x ] "упаковка" инструкций в тело процедуры/функции

[ ] параметризация процедурных значений "чем угодно"

======= 71. Обобщение -- это ...

[ ] использование FoldR

[ ] генерализация исходного кода до универсального

[x ] параметризация процедурных значений "чем угодно"
