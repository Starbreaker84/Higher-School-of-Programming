## Связный (связанный) список

Прочитайте обязательно:
[Введение](https://skillsmart.ru/algo/)
[Асимптотический анализ](https://skillsmart.ru/algo/15-121-cm/obabc2b3xd.html)

Связный список -- это набор "элементарных" данных (например, чисел или строк), каждое из которых связано с другим данным "связью", извините за тавтологию. Каждое элементарное данное вместе со своей "связью" называется узел.

*Надо сделать отступление для тех, кто не знаком с понятием указателя.
Во многих языках программирования принято, что значение любого типа -- это объект, который хранится где-то в памяти, а переменная, в которую мы "записываем" этот объект, на самом деле хранит не его, а **указатель** на место в памяти, где реальный объект находится (адрес в памяти, номер ячейки памяти условно, ссылка). Поэтому когда мы записали в переменную x объект (экземпляр класса, список, ...), а потом делаем*

*y = x*

*то мы не копируем сам объект, а копируем только его адрес в памяти. По сути, и x и y указывают на один и тот же объект! И при обращении к любой из них будет меняться один и тот же объект. Это так называемая  **передача значения (объекта) по ссылке** .*

*Исключение делается обычно для чисел и строк -- они действительно в присваивании полноценно копируются (это так называемая  **передача по значению** ).*

В простейшем случае узел просто связывается со следующим узлом, получается цепочка узлов, по которой мы можем передвигаться от начала к концу (от конца к началу не можем, так как связь организована только в одну сторону). Конец списка обозначается так: связь последнего узла указывает на отсутствие значения, обычно реализованное в той или иной форме во всех языках. Условимся это отсутствие значения обозначать null.

Отличие связного списка от массива, например, в том, что в связном списке мы можем легко вычленить его часть, взяв за начало любой элемент списка. Кроме того, операции добавления и удаления элементов выполняются очень эффективно, всего за два шага. И в памяти связный список хранится иначе, нежели массив: узлы списка могут быть разбросаны в памяти произвольно, а массив обычно занимает непрерывную область памяти.

Нам потребуется определить два класса: Node, который определяет узел, и LinkedList, который собственно и задаёт связный список.

В классе Node будут два элемента: value (само данное) и next -- "связь", по сути указатель на следующий узел (объект типа Node). Если данный узел финальный, поле next будет хранить null.

**Далее в этом курсе при записи алгоритмов или иных демонстрационных частей программы мы будем придерживаться некоторого условного псевдокода, напоминающего основной синтаксис популярных языков программирования.
Псевдокод -- это упрощенный вариант синтаксиса C++, Java, C# и им подобных. Для простоты мы используем отступы вместо фигурных скобок, не ставим ";" и т. д.**

Класс LinkedList -- это по сути "обёртка", синтаксический сахар для узлов. Ведь мы уже можем работать с узлами напрямую:

```
n1 = new Node(12)
n2 = new Node(55)
n1.next = n2 
```

В классе LinkedList нам понадобятся два поля: head и tail. В конструкторе этого класса зададим им значения null.

Поле head -- это по сути указатель на узел-голову списка, а поле tail -- это указатель на завершающий узел.

Добавим в класс LinkedList метод add_in_tail(), который добавляет новый узел в конец списка:

```
void add_in_tail(Node item)
    if (head == null)
        head = item
    else
        tail.next = item
    tail = item
```

Перебор всех элементов списка запишется примерно так:

```
node = head
while (node != null)
    node = node.next
```

Сформируем тестовый список из трёх элементов:

```
s_list = new LinkedList()
s_list.add_in_tail(n1)
s_list.add_in_tail(n2)
s_list.add_in_tail(new Node(128))
```

Объект s_list будет хранить список 12 55 128

Теперь нам надо найти нужный узел по заданному значению:

```
Node find(int val)
    node = head
    while (node != null)
        if (node.value == val)
            return node
        node = node.next
    return null
```

```
my_node = s_list.find(55)
```

Разрешать ли изменять значение некоторого узла в списке (менять значение его поля value)? В общем случае это нежелательно -- всегда лучше исходить из того, что наш связный список иммутабелен, и любые операции над ним не меняют содержимое его узлов. Вместо изменения значения узла лучше пользоваться комбинацией методов удаления и вставки нового узла.

**Задание** . Реализуйте соответствующий код на выбранном вами языке программирования.

Пункты, помеченные * сделайте отдельно.

1. Добавьте в класс LinkedList метод удаления одного узла по его значению.
2. Добавьте в класс LinkedList метод удаления всех узлов по конкретному значению.
3. Добавьте в класс LinkedList метод очистки всего содержимого (создание пустого списка).
4. Добавьте в класс LinkedList метод поиска всех узлов по конкретному значению (возвращается список/массив найденных узлов).
5. Добавьте в класс LinkedList метод вычисления длины списка.
6. Добавьте в класс LinkedList метод вставки узла после заданного узла.

* 7. Напишите проверочные тесты для каждого из предыдущих заданий.
* 8. Напишите функцию, которая получает на вход два связных списка, состоящие из целых значений, и если их длины равны, возвращает список, каждый элемент которого равен сумме соответствующих элементов входных списков.

**Рекомендации по тестированию.**
Проверяйте случаи, когда список пустой, содержит много элементов и один элемент: как в таких ситуациях будет работать удаление одного и нескольких элементов, вставка, поиск. Особое внимание уделите корректности полей head и tail после всех этих операций.

---

## заготовка классов C# для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
using System;
using System.Collections.Generic;

namespace AlgorithmsDataStructures
{

   public class Node
   {
     public int value;
     public Node next;
     public Node(int _value) { value = _value; }
   }

   public class LinkedList
   {
     public Node head;
     public Node tail;

     public LinkedList()
     {
       head = null;
       tail = null;
     }

     public void AddInTail(Node _item)
     {
       if (head == null) head = _item;
       else              tail.next = _item;
       tail = _item;
     }

     public Node Find(int _value)
     {
       Node node = head;
       while (node != null)
       {
         if (node.value == _value) return node;
         node = node.next;
       }
       return null;
     }

     public List<Node> FindAll(int _value)
     {
       List<Node> nodes = new List<Node>();
       // здесь будет ваш код поиска всех узлов по заданному значению
       return nodes;
     }

     public bool Remove(int _value)
     {
       // здесь будет ваш код удаления одного узла по заданному значению
       return true; // если узел был удалён
     }

     public void RemoveAll(int _value)
     {
       // здесь будет ваш код удаления всех узлов по заданному значению
     }

     public void Clear()
     {
       // здесь будет ваш код очистки всего списка
     }

     public int Count()
     {
       return 0; // здесь будет ваш код подсчёта количества элементов в списке
     }

     public void InsertAfter(Node _nodeAfter, Node _nodeToInsert)
     {
       // здесь будет ваш код вставки узла после заданного

       // если _nodeAfter = null , 
       // добавьте новый элемент первым в списке 
     }

    }
}
```

---

## заготовка классов Java для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
import java.util.*;

public class LinkedList
{
     public Node head;
     public Node tail;

     public LinkedList()
     {
       head = null;
       tail = null;
     }

    public void addInTail(Node item) {
        if (this.head == null)
            this.head = item;
        else
            this.tail.next = item;
        this.tail = item;
    }

    public Node find(int value) {
        Node node = this.head;
        while (node != null) {
            if (node.value == value)
                return node;
            node = node.next;
        }
        return null;
    }

    public ArrayList<Node> findAll(int _value) {
        ArrayList<Node> nodes = new ArrayList<Node>();
        // здесь будет ваш код поиска всех узлов 
        return nodes;
     }

     public boolean remove(int _value)
     {
       // здесь будет ваш код удаления одного узла по заданному значению
       return true; // если узел был удалён
     }

     public void removeAll(int _value)
     {
      // здесь будет ваш код удаления всех узлов по заданному значению
     }

     public void clear()
     {
      // здесь будет ваш код очистки всего списка
     }

     public int count()
     {
       return 0; // здесь будет ваш код подсчёта количества элементов в списке
     }

     public void insertAfter(Node _nodeAfter, Node _nodeToInsert)
     {
       // здесь будет ваш код вставки узла после заданного

       // если _nodeAfter = null , 
       // добавьте новый элемент первым в списке    
     }

}

class Node
{
     public int value;
     public Node next;
     public Node(int _value) 
     {  
       value = _value;
       next = null;
     }
}
```

---

## заготовка классов C++ для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
#include <stdio.h>

class Node                                                  
{  
  public:
    int value;
    Node* next;

    Node(int valueNode) {  
        value = valueNode;
        next = NULL;
    }
};

class LinkedList
{  
  public:
    Node* head;
    Node* tail;

    LinkedList()
    {  
        head = NULL;
        tail = NULL;
    }

    void add_in_tail(Node* item)
    {
        if (head == NULL) head = item;
        else tail->next = item;
        tail = item;
        tail->next = NULL;
    }
  
    Node* find(int val)
    {   
        Node *node = head;
        while (node != NULL) {
            if (node->value == val) return node;
            node = node->next;
        }
        return NULL;
    }

    bool remove(int val)
    {
       // здесь будет ваш код удаления одного узла по заданному значению
       return true; // если узел был удалён
    }

    void remove_all(int val)
    {
       // здесь будет ваш код удаления всех узлов по заданному значению
    }

    void clear()
    {
       // здесь будет ваш код очистки всего списка
    }

    int size()
    {
        // здесь будет ваш код подсчёта количества элементов в списке
        return 0;
    }

    void insert_after(Node* nodeAfter, Node* nodeToInsert)
    {
       // здесь будет ваш код вставки узла после заданного

       // если nodeAfter = NULL , 
       // добавьте новый элемент первым в списке  
    }

};
```
