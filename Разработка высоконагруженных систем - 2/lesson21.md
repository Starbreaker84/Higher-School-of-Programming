## Секционирование

Проблема 67. При использовании для секционирования хеша ключа мы теряем удобную возможность эффективно выполнять запросы по диапазонам. Некогда смежные ключи оказываются разбросаны по всем секциям, и их хранение в отсортированном виде невозможно.

Решение. Cassandra, например, прибегает к компромиссу: в ней допустимо объявление таблиц с  **составным первичным ключом (compound primary key)** , состоящим из нескольких столбцов. Для определения секции берётся хеш первой части ключа, а остальные используются в качестве сцеплённого индекса для сортировки данных в SS-таблицах Cassandra.

Искать запросом диапазон значений первого столбца составного ключа невозможно, но задание для первого столбца конкретного значения позволяет выполнять эффективный поиск по диапазонам значений других столбцов ключа.

Например, в соцсети пользователь может отправлять в свой блог множество сообщений. Если выбрать в качестве первичного ключа для сообщений пару (user_id, update_timestamp), то можно эффективно извлекать все сообщения от конкретного пользователя за определенный промежуток времени, которые будут отсортированы по метке даты/времени. Сообщения от разных пользователей могут храниться в разных секциях, но в границах одного пользователя все сообщения хранятся в одной секции -- отсортированными по этой метке.

## Секционирование

Проблема 68. Хеширование ключа для определения секции может несколько исправить ситуацию с горячими точками, но не избавиться от них полностью. В предельном случае, когда все операции записи и чтения выполняются для одного ключа, все запросы всё равно приходятся на одну секцию. Например, в соцсетях посты знаменитостей с миллионами подписчиков могут вызывать бурю активности. В результате возникают огромные объёмы операций записи для одного ключа (где ключом обычно выбирается Id этой знаменитости или Id популярного поста, который активно комментируется). Хеширование ключа не поможет, ведь хеш двух одинаковых ключей по определению одинаковый.

Решение. На сегодня подавляющее большинство СУБД не умеют автоматически выравнивать высоко-асимметричную нагрузку, поэтому снижение асимметрии возлагается на прикладную систему.

Например, если известно, что конкретный ключ -- горячий, простейшим решением будет добавление в начало или конец этого ключа случайного числа. Простое двузначное десятичное число приведёт к разбиению операций записи для ключа равномерно по 100 различным ключам, что распределит их по разным секциям.

## Секционирование

Проблема 69. При разбиении операций записи по различным ключам операциям чтения придется совершать дополнительные действия по чтению и объединению данных для всех этих ключей.

Решение. Добавлять случайное число имеет смысл только для небольшого числа горячих ключей -- для условных "знаменитостей". Для абсолютного большинства ключей с низкими объёмами операций записи это не потребуется.

### Секционирование (задания)

======= 58. Cоставной первичный ключ -- это ...

[ ] сцеплённый индекс + хеш

[ 1] хеш + сцеплённый индекс

[ ] хеш + метка даты/времени

[ ] метка даты/времени + хеш

======= 59. Если все операции записи и чтения выполняются для одного ключа, запросы всё равно приходятся на одну секцию

[ ] использовать случайное число в качестве ключа

[ 1] добавить случайное число в начало или конец ключа
