### Объекты и явное состояние

Подход **"объекты без состояния" (stateless)** считается хорошей идеей, потому что, имея в общем случае некоторый stateful-объект с явным состоянием, всегда важно понимать и уметь предсказывать в системе его будущее поведение. Оно зависит от двух факторов:

1. Внутреннее состояние объекта, которое потенциально зависит от всех прошлых обращений к нему. Эти обращения могут быть сделаны из множества самых разных частей программы.
2. Текстовое определение объекта, которое зависит от всех классов, от которых он наследуется. Эти классы могут быть определены в множестве самых разных мест в тексте программы.

Таким образом,  **семантика stateful-объекта оказывается распределённой во времени и пространстве** , что делает объект куда более трудным для понимания, нежели функцию. Семантика функции сосредоточена в одном месте -- а именно, в её определении в коде. У функции нет истории; она зависит только от своего текстового определения и своих параметров.

Возьмём классический пример, который традиционно очень любим в computer science:  **реализация стандарта IEEE 754 по выполнению арифметических операций с плавающей запятой** . Для него характерны определённые сложности, связанные например, с точностью вычислений, с накоплением погрешности, с реализацией на процессорах разных типов, и т. д. Рассмотрим в частности, почему объекты в подобных задачах сложнее программировать, когда у них есть состояние.

Предположим, что мы выполняем арифметические действия по стандарту IEEE 754, и что мы полностью реализовали этот стандарт: можем изменять режим округления арифметических операций во время выполнения (до ближайшего целого, округлить вверх/вниз и т.д.). Если мы будем использовать эту возможность неосторожно, то всякий раз при выполнении сложения X+Y мы не будем знать, что из этого получится, если только не проследим за всем ходом расчётов.

Любая часть программы могла изменить режим округления, что может создать полный хаос в числовых вычислениях, качество которые напрямую зависит от предсказуемого округления. Одно из решений заключается в том, чтобы все числовые методы устанавливали способ округления явно при каждом внешнем вызове, однако когда их в коде много, разобраться во всех возможных цепочках и путях вызовов практически невозможно.

Для максимального исключения подобных проблем  **желательно максимально усложнить в языке использование явного состояния и наследования** . В отношении наследования это уже так и есть:  **всегда труднее использовать наследование, нежели избегать его** . Что касается явного состояния, то это зависит от языка. В объектно-ориентированной модели определение функций без состояния на самом деле определённо проще, нежели определение stateful-объекта. Объекты должны быть определены как экземпляры классов, которые сами по себе определяются достаточно сложно с помощью инструкции class. Функции же просто задаются своей сигнатурой.

В популярных объектно-ориентированных языках, к сожалению, ситуация противоположная: явное состояние почти всегда используется "по умолчанию", а вот функции обычно синтаксически громоздки, если их вообще разрешено определять. В Java и C# например вообще нет синтаксической поддержки функций, а атрибуты объектов по умолчанию stateful, если не объявлены явно как final.

### Унифицированный объектный синтаксис

Синтаксис языка должен помогать, а не мешать программистам в разработке и написании кода и рассуждениях о программе. Важный принцип при разработке синтаксиса языка -- это когда форма отражает содержание, и наоборот.  **Различия в семантике должны быть заметны как различия в синтаксисе, и наоборот** . Например, условный оператор цикла практически всегда записывается примерно так: while условие do тело. Синтаксис записи условия до тела отражает тот семантический факт, что условие будет вычислено и оценено до выполнения цикла.

Должны ли все операции над сущностями языка иметь единый синтаксис? Это не обязательно улучшает читабельность кода; выразительность в таком случае перемещается на второй слой синтаксиса -- например, в наглядные имена объектов и классов, однако и язык делается более многословным. Ещё больше увеличивается многословность кода при параллельном программировании в объектном синтаксисе, потому что унифицированный синтаксис подразумевает явную синхронизацию.

### Явное состояние и унифицированный синтаксис

======= 36. Какой негативный фактор объекта с состоянием второстепенный?

[ ] обращение к состоянию объекта может быть сделано из множества мест программы

[ ] обращение к определению объекта может быть сделано из множества мест программы

[ 1] обращение к методам объекта может быть сделано из множества мест программы

======= 37. Для исключения запутывания кода желательно ...

[ ] усложнить использование полиморфизма и наследования

[ ] усложнить использование явного состояния и полиморфизма

[ 1] усложнить использование явного состояния и наследования

======= 38. Должны ли все операции над сущностями языка иметь единый синтаксис?

[ 1] различия в семантике должны быть заметны как различия в синтаксисе, и наоборот

[ ] различия в семантике должны быть зависимы от различий в синтаксисе

[ ] различия в синтаксисе должны быть зависимы от различий в семантике
