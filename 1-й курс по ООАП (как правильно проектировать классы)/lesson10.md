## Финальная версия АТД Stack

Итак, финальная версия АТД Stack запишется так:

```
abstract class Stack<T>

    public const int POP_NIL = 0; // push() ещё не вызывалась
    public const int POP_OK = 1; // последняя pop() отработала нормально
    public const int POP_ERR = 2; // стек пуст

    public const int PEEK_NIL = 0; // push() ещё не вызывалась
    public const int PEEK_OK = 1; // последняя peek() вернула корректное значение 
    public const int PEEK_ERR = 2; // стек пуст

    // конструктор
    public Stack<T> Stack(); // постусловие: создан новый пустой стек


    // команды:
// постусловие: в стек добавлено новое значение
    public void push(T value); 

// предусловие: стек не пустой; 
// постусловие: из стека удалён верхний элемент
    public void pop(); 

// постусловие: из стека удалятся все значения
    public void clear();


    // запросы:
// предусловие: стек не пустой
    public T peek(); 

    public int size();


    // дополнительные запросы:
    public int get_pop_status(); // возвращает значение POP_*
    public int get_peek_status(); // возвращает значение PEEK_*

```

Для команды push() статусы, в принципе, не нужны, так как она всегда отрабатывает корректно. Но для полноты можно добавить статусы PUSH\_OK и PUSH\_NIL, если push() выполняется в самый первый раз.

### Полнота спецификации АТД

*Теоретическое необязательное отступление.*

Можно ли как-то убедиться, что созданная спецификация АТД полностью описывает все свойства определяемых ей объектов? АТД мы основываем, как договорились, на некотором условно уже готовом техническом задании, или наборе требований. Если оно неформально, то, понятно, никаких критериев полноты АТД тут не существует. Но если оно формально, тогда возникает вопрос полноты применительно к самому этому документу.

В идеале можно построить математическую теорию для разрабатываемой системы, которая будет формально определять допустимое множество правильных выражений -- комбинаций вызовов функций АТД с корректными аргументами с применением аксиом. При этом различают **правильно построенные выражения** и **корректные выражения**. Первые -- это те, которые компилируются, но в процессе работы могут вызывать ошибки времени выполнения из-за недопустимых операций. Корректные выражения работают всегда корректно, без ошибок времени выполнения (хотя, возможно, и выдают не тот результат, которого от них ожидает разработчик и спецификация).

На практике ограничиваются прагматичным понятием **достаточной полноты АТД**, подразумевающей достаточно сильные аксиомы. Они позволяют в частности выполнять вывод типа результата для функций АТД и гарантируют, что **мы получим хотя бы один результат для каждой из них**. Другими словами, всё, что определено нашей спецификацией АТД, обеспечивает корректное вычисление результата для всех функций, и поиск дополнительных характеристик АТД можно прекратить. Однако теоретически не исключено, что аксиомы могут приводить к выводу нескольких значений выражения, поэтому второе свойство достаточной полноты -- это **непротиворечивость**. Она гарантирует, что для каждого выражения будет выведено не более одного значения.

Проблема, что в общем случае доказать достаточную полноту, и даже непротиворечивость, невозможно -- эта задача алгоритмически неразрешима за конечное время. Однако для конкретной спецификации АТД это доказать, как правило, возможно.
