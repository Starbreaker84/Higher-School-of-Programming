### Декларативная параллельная вычислительная модель

К данному моменту определена декларативная модель вычислений, в которой имеется и ленивое вычисление, и параллелизм.
Важно понимать, что это независимые понятия. В конкретном языке может не быть ни того, ни другого; например, язык с
ленивым вычислением, но без параллелизма, может хорошо выполнять "короутинг" между поставщиком и потребителем.

К строгому функциональному программированию были добавлены три концепции, которые сохраняют декларативность и
одновременно увеличивают выразительность: dataflow-переменные, декларативный параллелизм и ленивые вычисления.
Добавление этих концепций в различных комбинациях дает шесть различных практических моделей вычислений.

Dataflow-переменные -- необходимое условие для декларативного параллелизма, поскольку они фактически представляют собой
ключевой механизм, с помощью которого нити синхронизируются и обмениваются данными. Однако и "последовательный" язык
также может иметь dataflow-переменные и использовать их продуктивно.

В частности, когда ленивые вычисления объединяются в одной модели с dataflow-переменными, возникает обязательное
требование потенциальной допустимости одновременного вычисления аргументов ленивых функций. В противном случае (как в
последовательной версии), когда аргументы вычисляются последовательно (в формате сопрограмм), могут возникнуть тупиковые
ситуации (deadlocks), если связывание значений одних аргументов зависит от связывания других аргументов (когда например
для расчёта очередного аргумента должна быть вызвана функция, ожидающая связывания некоторой глобальной
dataflow-переменной).

### Декларативная параллельная вычислительная модель

Так как ленивые вычисления и dataflow-переменные -- понятия независимые, это означает, что есть три особых момента в
жизни переменной:

1) Создание переменной как физической сущности, когда её можно помещать в структуры данных и передавать в функцию, или
   возвращать из неё. Переменная ещё не связана со своим значением. Мы называем такую переменную dataflow-переменная.
2) Спецификация вызова функции в коде, которая во время выполнения будет оценивать/запрашивать значение переменной (но в
   момент определения вызова функции в коде такая оценка значения не выполняется; как правило, этот пункт, в отличие от
   предыдущего, относится к моменту компиляции).
3) Вычисление значения и связывание. Когда сформирован результат некоторого выражения, он связывается с переменной. Само
   формирование результата может происходить явно/жадно или неявно/лениво (по запросу), однако момент формирования
   значения и момент связывания значения с переменной -- формально разные. Но так как связывание -- это логическое
   следствие физического "создания" значения, принимаем, что случаются они одновременно.

Сами эти три момента также могут физически "случаться" по отдельности или одновременно (причём как на фазе выполнения,
так и на фазе компиляции). В итоге шесть упомянутых выше вариантов сводятся к четырём вариантам моделей вычислений в
конкретных языках.

### Декларативная параллельная вычислительная модель

Обычные последовательные вычисления могут происходить либо жадно, либо лениво. Жадные языки -- это например F# и Scheme,
где все три момента совпадают. Ленивый функциональный язык -- это Haskell, где, соответственно, совпадают первые два
момента, но само вычисление значения (и связывание) откладывается непосредственно до того момента, как оно будет
запрошено (возможно, никогда).

Остаются четыре варианта -- последовательные/параллельные вычисления с поддержкой dataflow-переменных в жадном/ленивом
формате. Однако в жадном случае мы в обоих случаях получаем вариант, когда первый момент отдельный, а второй и третий
связаны: отдельно выполняется объявление переменной в программе, а запрос вычисления значения и его связывание
происходят сразу вместе. В последовательной декларативной модели это поддерживается, например, в языке Пролог, а
параллельная модель, управляемая данными, требует отдельного фреймворка.

И наконец, в четвёртом варианте все три момента разнесены. Это и последовательное ленивое функциональное
программирование с dataflow-переменными, и параллельная декларативная модель, управляемая запросами. Данный случай --
самый общий. Единственно, что связывает все эти три момента -- что они имеют отношение к одной конкретной переменной.

### Ленивые потоки

В схеме с поставщиком/потребителем именно поставщик решает, сколько элементов списка нужно сгенерировать, т. е.
выполнение жадное. Это разумный подход, если общий объём работы конечен и не использует много системных ресурсов. Но
если объём работы подразумевает, что потребуется много ресурсов (требуется чрезвычайно большое или потенциально
неограниченное количество элементов списка), лучше использовать ленивое выполнение, когда потребитель решает, сколько
элементов списка требуется на данный момент. С другой стороны, ленивое выполнение может использовать гораздо больше
общих ресурсов в целом -- из-за стоимости его реализации.

Ленивое выполнение в декларативной параллельной модели может быть реализовано двумя способами: с явно программируемыми
триггерами, или с внутренними/скрытыми триггерами. Программируемые триггеры требуют явного общения потребителя с
производителем. В случае скрытых триггеров сама семантика языка гарантирует, что функция вычисляется только в том
случае, если ее результат стал реально необходим.

В параллельной модели, управляемой запросами, предлагается явная синтаксическая поддержка: функция может быть
аннотирована как "ленивая" -- это упрощает работу как программиста, так и компилятора. Жадное вычисление само по себе не
требует реализации внутренних триггеров, и язык, где ленивое вычисление надо задавать явно, существенно легче расширять
недекларативными концепциями (например, исключения или работа с состояниями). По этой причине такие популярные
функциональные языки, как F#, по умолчанию придерживаются жадной стратегии вычислений.

### Ленивая специфика

Ленивость проявляется повсеместно, это важно замечать. Например, даже в стандартных библиотеках обычных императивных
языков работа с двоичными файлами фактически ленива: мы получаем дескриптор файла, который где-то в системе хранит
физическую текущую позицию в файле, после чего запрашиваем "очередную" порцию байтов, и позиция автоматически сдвигается
дальше.

Всевозможные итераторы, генераторы (list comprehensions), поддерживаемые во многих популярных языках, также работают
лениво.

Ленивость способна сильно "перетасовать" вычисления, разбросать их или сгруппировать вместе, но без изменения итогового
результата. Поэтому ленивость -- мощный инструмент для разработки декларативных алгоритмов. Однако использовать его
нужно осторожно. Используемая "в лоб", ленивость может поломать хорошие теоретические границы оценки сложности
O-большое, превратив их в амортизационные. А при разумном использовании ленивость может существенно улучшить
амортизационные оценки, и даже иногда преобразовать амортизационную границу в наихудшую O-большое.

### 13. Ленивое выполнение

======= 37. Вычисление выражений в декларативной модели по умолчанию ...

[ 1] жадное

[ ] ленивое

[ ] голодное

======= 38. В параллельной модели, управляемой запросами ...

[ ] нить выполняется по запросу

[ 1] код выполняется по запросу

======= 39. Ленивое выполнение само по себе может применяться как реализация ...

[ ] статического связывания

[1 ] динамического связывания

[ ] полиморфизма
