### Модель шва

11. Проблема. В начале работы по написанию юнит-тестов для легаси-проекта приходится разрывать немало зависимостей почти независимо от того, насколько хорошо написан сам код системы. Извлечение из существующего кода отдельных классов для тестирования наглядно демонстрирует, что такое хорошее проектирование. Чем лучше оно выполнено, тем легче тестировать каждый класс по отдельности (этой теме посвящён цикл курсов по ООАП).
    Какую абстракцию применять при разрыве зависимостей?

Решение. Вводим ключевое понятие в разрешении зависимостей --  **шов** .

Например, в методе B тестируемого класса A имеется вызов метода C() глобального статического класса D (в общем случае -- вызов любой функции, внешней по отношению к классу A). По некоторым причинам сам класс D протестировать сложно (как поступать в случае таких статических синглтонов, рассматриваем далее). То есть нам требуется выполнить в тестах метод B(), не вызывая во время тестирования метод C(). В идеале хотелось бы это сделать, не правя исходный код класса A.

Для этого будем использовать  **модель шва** .

**Шов -- это место в коде, где можно изменить поведение программы, не правя ее в этом месте** .


### Модель шва

12. Проблема. Казалось бы, как же можно изменить поведение, не меняя конкретный код?

Решение. На самом деле, в программной инженерии известно несколько хороших способов.

Например, не меняя код метода B, создаём в классе A новый метод TestB, в который копируем содержимое метода B, и подменяя код вызова C() на какую-то подходящую для задач тестирования заглушку.

Другой способ -- изменить код самого метода C так, чтобы он позволял полноценно вызывать B() в тестах (что, скорее всего, потребует определенного рефакторинга класса D, что в свою очередь чревато другими проблемами).

Такой шов называется  **объектным** : мы изменили вызываемый метод, не меняя вызывающий его метод.

Думание о проекте в парадигме швов хорошо помогает увидеть различные внутренние построения, структуры, схемы, абстракции в системе. Заменяя поведение системы в швах, мы сможем выборочно разрывать и исключать зависимости, делая их немногочисленными и хорошо локализованными.


### Модель шва

13. Проблема. Один из популярных способов работы со швами -- использование препроцессора или макрокоманд (#if, #ifdef и т. д.).

С помощью, например, директив условной компиляции мы меняем поведение, просто подставляя вместо рабочего код код, предназначенный для тестирования. Это так называемые **швы предварительной обработки** кода.

Однако чрезмерное использование предварительной обработки приводит к снижению ясности кода: фактически, мы храним несколько разных программ в одном и том же файле, и надо прикладывать дополнительные усилия для их синхронизации и сопровождения. Вдобавок, активное использование макрокоманд нередко приводит к серьёзным ошибкам, которые находить очень трудно. Но несмотря на приведенные выше оговорки, наличие препроцессора в языках C и C++ не может не радовать, поскольку препроцессор предоставляет нам больше швов.

Решение. По возможности, избегать швов предварительной обработки.

Когда имеется шов, то соответственно имеется место в коде, где можно изменить поведение программы. Но мы не можем менять код только ради его тестирования: исходный код должен оставаться одинаковым и для эксплуатации, и для тестирования.


### Компоновочные швы

Компиляция -- далеко не всегда последняя стадия формирования исполняемой программы. Компилятор может порождать промежуточное двоичное представление кода (часто называемое объектным, например, в С++), в котором содержатся вызовы кода из других файлов. Такие объектные файлы далее объединяются в одно целое сборщиками или компоновщиками (linkers), которые разрешают каждый вызов в объектных файлах. Соответственно, в целях тестирования вызовы некоторых функций и методов можно подменять на этапе сборки. Такой шов называется  **компоновочным** .


### Модель шва (задания)

======= 13. Шов -- это место в коде, где ...

[ ] можно изменить поведение программы, правя её в этом месте

[ ] нельзя изменить поведение программы, правя ее в этом месте

[1 ] можно изменить поведение программы, не правя её в этом месте

[ ] нельзя изменить поведение программы, не правя ее в этом месте

======= 14. Объектный код -- это ... (выберите неверное утверждение)

[ ] модификация вызываемого метода без изменения вызывающего метода

[ 1] модификация вызывающего метода без изменения вызываемого метода

[ ] создание нового метода, в который скопирован с правками тестируемый метод

======= 15. Шов предварительной обработки -- это ...

[1 ] подстановка кода для тестирования вместо рабочего кода

[ ] подстановка рабочего кода вместо кода для тестирования

[ ] использование директив условной компиляции

======= 16. Компоновочный шов -- это ...

[1 ] подмена функций на этапе сборки

[ ] подмена функций препроцессором
