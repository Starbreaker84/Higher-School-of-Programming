### 26. Распределённые акторные фреймворки

**Акторная модель (actor model)** -- модель программирования для создания конкурентного/одновременного доступа в пределах одного процесса. Мы отказываемся от непосредственной работы с потоками выполнения (что обычно приводит к сопутствующим проблемам состояния гонки, блокировок и взаимных блокировок, которые мы изучали на курсе по парадигмам программирования), вся логика инкапсулируется в акторах.

**Актор -- это объект, который взаимодействует с другими объектами исключительно через отправку и получение сообщений.**

У каждого актора может быть своё **локальное внутреннее состояние** (не разделяемое ни с какими другими акторами), и он взаимодействует с другими акторами только путём отправки и получения асинхронных сообщений. Доставка сообщений не гарантируется: при определенных сценариях сообщения могут теряться.

**Каждый актор обрабатывает одновременно только одно сообщение** , поэтому не нужно заботиться о потоках выполнения: выполнение каждого актора может планироваться фреймворком независимо от других.


В распределённых акторных фреймворках данная модель программирования используется для масштабирования приложения на много узлов. При этом применяется тот же самый механизм передачи сообщений, вне зависимости от того, на одном узле расположены отправитель и получатель, или на разных. Если они расположены на разных узлах, то сообщение явным образом кодируется в байтовую последовательность, пересылается по сети и декодируется на другой стороне.

Независимость от расположения гораздо лучше развита в акторной модели, чем в RPC, поскольку эта модель изначально допускает возможность потери сообщений даже в пределах одного процесса. Хотя задержка передачи сообщений по сети, вероятно, будет выше, нежели в пределах одного процесса, при использовании акторной модели различия между локальным и удалённым обменом сообщениями на практике оказываются невелики.

Распределённые акторные фреймворки, по сути, объединяют в одном подходе и брокер сообщений, и акторную модель программирования.

Однако при необходимости выполнять плавающие обновления приложения, основанного на акторах, всё равно приходится заботиться и о прямой, и об обратной совместимости, так как сообщение может быть отправлено с узла, на котором запущена новая версия системы, на узел, где ещё работает старая версия, и наоборот.

Три популярных и широко используемых распределённых акторных фреймворка:

- фреймворк [Akka](https://akka.io/) применяет по умолчанию встроенную сериализацию языка Java, не обеспечивающую прямой или обратной совместимости. Однако её можно заменить технологиями наподобие Protocol Buffers и получить возможность выполнять плавающие обновления;
- фреймворк [Orleans](https://github.com/dotnet/orleans) для платформы .NET задействует пользовательский формат кодирования данных, не поддерживающий развёртывание плавающих обновлений; для развёртывания новой версии приложения придется настроить новый кластер, перенаправить трафик со старого кластера на новый кластер, и затем отключить старый. Как и в случае с Akka, есть возможность применять пользовательские плагины для сериализации;
- фреймворк [Erlang OTP](https://erlang.org/) , фактически встроенный в экосистему языка Erlang, сам по себе очень продуктивный, к сожалению, не позволяет легко менять схемы записей -- несмотря на наличие в системе множества возможностей, предназначенных для обеспечения высокой доступности данных. Плавающие обновления возможны, но их нужно очень тщательно планировать.


## Акторная модель (задания)

======= 121. Акторная модель -- это ...

[ ] модель синхронного взаимодействия в рамках одного или нескольких потоков

[ ] модель синхронного взаимодействия раздельно в множестве потоков

[ 1] модель одновременного взаимодействия в рамках одного потока

[ ] модель одновременного взаимодействия раздельно в множестве потоков

======= 122. Акторы обмениваются ...

[ ] синхронными сообщениями с гарантированной доставкой сообщений

[ ] синхронными сообщениями без гарантированной доставки

[1 ] асинхронными сообщениями с гарантированной доставкой сообщений

[ ]асинхронными сообщениями без гарантированной доставки

======= 123. Как распределённые акторные фреймворки поддерживают плавающие обновления?

[ ] только прямая совместимость

[ ] только обратная совместимость

[1 ] оба вида совместимости
