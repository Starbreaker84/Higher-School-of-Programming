## Ключевой паттерн Visitor в ООП и ФП

В Сильных Идеях есть отдельный материал, почему  **паттерн Visitor единственно актуальный из классических паттернов проектирования** . Формально он упоминается практически во всех учебниках в контексте ситуации, когда существует АТД, который мы не хотим изменять в плане добавления новых методов (и это в общем всегда правильно), однако в проекте такое добавление по каким-то причинам требуется. Строго говоря, потребность в Visitor возникает именно в языках ООП.

Однако "не добавлять новые методы" -- это не очень корректное утверждение, и собственно, примеры из учебников и статей сами этому и противоречат. Скорее, речь о том, что **мы хотим иметь возможность расширения классов как интерфейсов** -- отвязывая новые добавляемые им методы от их реализации. Вот реализация уже может меняться свободно, не затрагивая исходный код классов.

Во-первых, **программирование в парадигме ООП по умолчанию подразумевает, что мы можем легко добавлять в систему новые типы** (классы-наследники), однако добавление новых методов в классе идеологически затруднено и не рекомендуется: достаточно легко нарушить принцип SRP, а возможно, и инвариант класса (целостность АТД). Вот паттерн Visitor -- это такая по сути приляпка, компенсирующая этот качественный недостаток ООП.

**В функциональном программировании наоборот мы можем без проблем добавить новую функцию без изменения остального проекта** -- но не новый тип, как-то связанный с существующей логикой, особенно если активно применяются алгебраические типы данных (тогда придётся исправлять много самых разных функций, наверняка разбросанных по проекту).


## Ключевой паттерн Visitor в ООП и ФП

Во-вторых, в Julia и многих других языках с поддержкой функционального программирования применяется потенциально более мощный механизм, называемый  **multiple dispatch** . В программе допускается определить сколько угодно функций с одинаковыми именами и одинаковым количеством параметров, которые будут отличаться только типами своих параметров (и возможно типом возвращаемого значения). Выбор подходящей функции в момент её вызова будет выполнен автоматически в зависимости от типов конкретных аргументов. В классической реализации ООП такой полиморфизм реализуется в более примитивной форме -- на основании типа только одного (первого) параметра метода (this, self, ...).

Таким образом, для обработки некоторой структуры данных новым способом (в некотором смысле, отправкой ей сообщения другого типа) -- ничего при этом не меняя во всём остальном коде! -- достаточно лишь добавить новую функцию с тем же именем, но с иным списком аргументов. Но в ООП такое невозможно.


## Ключевой паттерн Visitor в ООП и ФП

Идея Visitor в ООП, как говорилось, в том, чтобы добавить некоторый промежуточный уровень для определения операций/методов/поведения класса в одном месте (в интерфейсе), не затрагивая при этом оригинальную реализацию класса. Мы задаём поведение или операции в одном интерфейсе (который легко расширять), а затем используем этот интерфейс с помощью полиморфизма для обеспечения нужного поведения оригинального класса (или даже группы классов, с учётом иерархии).

Например, в программе есть определения иерархии из трёх классов Велосипед, Шоссейник и Маунтинбайк. Мы хотим определять самые разные специфические методы для двух классов-наследников Велосипед (например, ТаймТриал и БанниХоп), но при этом не хотим (сильно) трогать код самих классов.

Для этого мы определяем отдельный интерфейс IВелосипедVisitor, в котором задаём все нужные функции (скорее всего, это будут просто сигнатуры в большинстве языков ООП), каждая из которых в качестве параметра получает экземпляр конкретного класса Шоссейник или Маунтинбайк, и выполняет соответствующую его обработку.


## Ключевой паттерн Visitor в ООП и ФП

Для реализации нужных функций в конкретном языке скорее всего потребуется добавить класс, реализующий этот интерфейс -- например, ВелосипедVisitor. Соответственно, класс Велосипед потребуется связать с ним, для чего в Велосипед добавляется один "универсальный" метод (например, operate), единственным параметром которого будет экземпляр класса ВелосипедVisitor. На уровне класса Велосипед его лучше оформить абстрактным.

И в заключение, в классах Шоссейник и Маунтинбайк мы реализуем operate(), внутри которого выполняем обращение к нужному методу интерфейса IВелосипедVisitor, передавая ему себя (this/self) в качестве параметра:

```
visitor. ТаймТриал(this)
или
visitor. БанниХоп(this)
```

Проблема тут очевидна в том, как уже говорилось, что

1) внутрь "универсального" по своей сути метода operate мы пихаем в разных классах качественно разную специфическую логику,
2) вызов operate() выглядит красиво, но он поддерживает только одну конкретную логику, а когда интерфейс класса расширяется достаточно регулярно, начинают плодиться бессмысленные названия методов вроде operate1, operate2, ...


## Ключевой паттерн Visitor в ООП и ФП

Корень проблемы в том, что в ООП данные и методы/поведение хранятся вместе по определению самой парадигмы, а наследование надо выполнять строго и аккуратно -- чтобы не поломать родительский интерфейс по принципу LSP.

Так, если добавлять новый метод непосредственно в классы-наследники, потребуется в коде соответствующие сущности явно приводить к конкретному типу, потому что объекты, как подразумевает принцип полиморфизма, правильно хранить в различных контейнерах (массивах, списках...) приведёнными к базовому типу. Но явное приведение типа -- это всегда плохо, это уязвимость в системе типов проекта (а если вы ошибётесь и приведёте не тот объект?). В современных языках, уже не только ФП, но и ООП, добавляется такой удобный механизм, как pattern matching, который впрочем лишь повышает выразительность соответствующего кода, не предоставляя никаких семантических страховок.

В целом, паттерн Visitor конечно бывает локально полезен, когда некоторое поведение мы выносим во внешний класс. Например, operate может реализовывать сериализацию в заданный формат, а отдельный класс-visitor (объект-visitor как аргумент operate) содержит только набор разных методов сериализации. В принципе, выбор подходящего метода можно даже организовать динамически, однако тут начнут плодиться цепочки условий, что всегда плохо.


## Ключевой паттерн Visitor в ООП и ФП

С другой стороны, подобная проблема, только в профиль, присутствует и в ФП. Например, обход дерева и формирование списка всех листьев записывается в рекурсивном виде естественно и наглядно. Однако если например появится задача добавить в итоговый список только те листья, значения которых нечётны, придётся фактически скопипастить эту функцию только ради того, чтобы лишь немного её подправить. А если таких задач будет много? В результате в проекте появится множество очень похожих функций.

Очевидное решение --  **функции второго порядка** . Передаём функции обхода дерева функцию-предикат, которая и укажет для узла, надо ли его включать в результат. Эта функция-предикат в некотором смысле эквивалентна паттерну Visitor, когда мы делегируем конкретную логику принципиально другой сущности.

И вроде бы в ФП получается гораздо более элегантно, нежели в ООП (просто добавился новый параметр-предикат), однако ситуация также резко усложняется, если, допустим, мы захотим получить агрегированный результат (сумму значений заданных узлов), или найти конкретный узел (для чего желательны ленивые вычисления с автоматическим прерыванием обхода, когда узел обнаружен). Да и саму схему обхода желательно в разных ситуациях менять (например, выполнять поиск в ширину или в глубину -- в зависимости от примерной структуры дерева).

В ФП мы сможем достичь подобного эффекта, когда абстрагируемся от всех прямых рекурсивных вызовов исходной функции обхода дерева, используя для этой цели дополнительные абстрактные функции-расширения. Причём такие расширения можно комбинировать, строить цепочки таких расширений, когда итоговая расширенная функция формируется (вычисляется) динамически.


## Ключевой паттерн Visitor в ООП и ФП

В ООП схожая (только менее мощная) техника называется [смешивание/примеси/миксины](https://en.wikipedia.org/wiki/Mixin) (mixins), когда некоторое расширение может применяться сразу к нескольким различным суперклассам в разных иерархиях (своеобразная замена множественному наследованию). Сами миксины не предназначены для создания экземпляров своих классов, не наследуются от других миксинов, и в идеале они stateless. В некотором смысле миксины разделяют состояние и функции (методы обработки состояния), и им близки интерфейсы, которые обычно не подразумевают реализацию. Хотя тут надо быть очень осторожным, потому что парадигма тайпклассов, близкая к интерфейсам и миксинам, на самом деле приводит в крупном проекте скорее [к его усложнению](https://t.me/lambda_brain/322).
