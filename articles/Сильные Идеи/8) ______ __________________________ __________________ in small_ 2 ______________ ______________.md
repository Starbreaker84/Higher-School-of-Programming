## Как проектировать программы in small

(два научных подхода)

### Как проектировать ко-рекурсивные программы

На курсах по парадигмам программирования, в частности, при изучении декларативной вычислительной модели, рассматривался важнейший принцип проектирования:
**структура программы следует за используемой ей структурой данных** .

То есть хорошие идеи для возможного дизайна можно найти, внимательно изучив структуру входных данных, а так как многие классические структуры данных (типы) обычно хорошо описываются рекурсивно (списки, деревья, ...), то обычно и получаются в итоге рекурсивные программы.

Очень интересная работа оксфордских учёных **[&#34;How to design co-programs&#34;](http://www.cs.ox.ac.uk/jeremy.gibbons/publications/copro.pdf)** предлагает альтернативный, и в чём-то даже более продуктивный подход:  **основывать структуру программы на структуре выходных данных** , что приведёт к ко-рекурсивным программам.

****

### Как проектировать ко-рекурсивные программы

Рассмотрим базовую стратегию решения из легендарного учебника **[&#34;How to Design Programs&#34;](https://htdp.org/)** (Felleisen, Findler, Flatt, and Krishnamurthi) -- анализ структуры входных данных. Если тип входных данных рекурсивный (например, список или дерево), реализуем прямую рекурсивную обработку этого типа. Если он более сложный, применяем разные виды (рекурсивной) обработки отдельных его частей.

Схема решения состоит из таких шагов:
1 анализируем входные данные, строим соответствующий тип данных;
2 задаём сигнатуру функции, эти данные обрабатывающей: список типов параметров и тип результата;
3 готовим несколько примеров её работы, учитывая различные краевые случаи;
4 разрабатываем общий шаблон функции -- какие форматы входных данных ей надо рассмотреть на самом верхнем уровне;
5 пишем тело функции;
6 готовим и выполняем тесты.


### Как проектировать ко-рекурсивные программы

Допустим, надо написать функцию, сортирующую входной список.

1. Список -- это такой рекурсивный тип (структура) данных, который может быть либо пустым, либо состоять из головы и хвоста, где голова -- это целое значение самого первого элемента в списке, а хвост -- это оставшаяся часть списка без головы.
2. Функция insertSort получает на вход список целых чисел, и возвращает тоже список целых чисел, которые будут отсортированы в возрастающем порядке, но это в обычном типе не задаётся (но может быть задано, например, в зависимых типах).
3. Например:

```
insertSort [ ] = [ ]
insertSort [3, 2, 1] = [1, 2, 3]
insertSort [1, 2, 3] = [1, 2, 3]
insertSort [12, 20, -5] = [-5, 12, 20 ]
insertSort [1, 1, 2] = [1, 1, 2]
```


### Как проектировать ко-рекурсивные программы

4. В шаблоне разбираются два случая: когда на входе пустой список, и когда непустой (в этом случае список представлен как голова и хвост).

В HtDP подробно разбирается решение данной задачи через постпенный ввод дополнительной функции insert.

```
insertSort [ ] = [ ]
insertSort (a : x) = insert a (insertSort x)
```

a - это голова, x - это хвост.

Так как insertSort по определению возвращает отсортированный список, операция insert выполняет рекурсивное добавление нового значения в уже отсортированный список.

```
insert b [ ] = [b] 
insert b (a : x) 
если b <= a то 
b : a : x 
иначе 
a : insert b x
```

Так как второй аргумент insert отсортирован, то и результат insert тоже гарантированно будет отсортирован.

5. Наконец, эту функцию следует протестировать, что выполняется штатным образом.


### Как проектировать ко-рекурсивные программы

Вторая, более продвинутая стратегия, предложенная HtDP -- это  **генеративная (порождающая) рекурсия (generative recursion)** , применяемая, когда задача более сложная и требует подходов в духе "разделяй и властвуй". Шаблон проверяет тривиальный вариант, а в нетривиальных случаях разбивает проблему на одну или несколько подпроблем, рекурсивно их решает и собирает промежуточные результаты в итоговый результат.

Никакие другие подходы, кроме структурной и генеративной рекурсий, в HtDP не рассматриваются. Другие приёмы в ней конечно предлагаются, включая императивные функции (которые впрочем из второй редакции были окончательно удалены), но они не задают дизайн, общую структуру результирующей программы.


### Как проектировать ко-рекурсивные программы

Принцип **"program structure follows data structure"** безусловно очень хорош, однако он ограничен тем, что по сути завязан полностью на входные данные (их типы). Обрабатывая входной список, мы ориентируем структуру программы по структуре именно входных данных, а выходные данные получаются как бы вторичными, что в общем случае, конечно, далеко не всегда корректно.

Соответственно, оксфордские специалисты по computer science предложили расширить схему, предлагаемую HtDP, ещё одним шагом: после структурной рекурсии, перед переходом к генеративной рекурсии, предлагается освоить структурную ко-рекурсию.

А именно, есть функция, которая по своей сигнатуре генерирует некоторый условный "смешанный выход" -- запись с полями различных типов. Она декомпозируется в функции, каждая из которых генерирует значение одного конкретного поля этой записи (строго говоря, используем конструкторы алгебраического типа данных) -- вместо того, чтобы выполнять сопоставления с образцом входных данных.

Функция, которая формирует на выходе рекурсивную структуру данных из некоторых входных данных, может быть определена так же: через анализ случая, когда результат тривиальный, и для нетривиальных случаев -- с рекурсивными вызовами для генерации отдельных подструктур результата.


### Как проектировать ко-рекурсивные программы

Рассмотрим простейший случай создания функции safeDiv, которая выполняет безопасное деление двух целых чисел. В оригинальной работе предлагается использовать монаду MayBe из функциональных языков; для простоты договоримся, что safeDiv возвращает либо целое число (результат корректного деления), либо null/None, если делитель равен нулю.

Таким образом, мы имеем тривиальный случай -- когда на выходе null (который выбирается, когда делитель нулевой), и условно нетривиальный -- когда на выходе целое число (то есть надо выполнить конкретные и заведомо корректные вычисления).

Чем такой подход лучше? Прежде всего тем, что  **для пользователя функции, очевидно, важен прежде всего её результат, и программисту полезно думать именно в терминах результата** , поэтому мы и проектируем структуру функции именно исходя из результата. Конечно, эта структура зависит от от входных данных, но она не определяется их типом, а только их значением (в частности, тем, равен ли делитель нулю).

В целом, гораздо лучшее понимание схемы программы чаще всего формируется не структурой входных данных, а структурой её выхода, результата.


### Как проектировать ко-рекурсивные программы

Другой пример: функция получает на вход строку и должна вернуть запись типа Date {day :: Day, month :: Month, year :: Year}. Как начинает думать над решением программист, обученный классическому подходу в духе HtDP?

Он изучает прежде всего формат входной строки, прикидывает, как его лучше распарсить, выделяет из разбитой строки отдельные кусочки, и потом собирает их вместе в итоговый результат. В случае же ко-рекурсивного подхода готовим три функции, каждая из которых возвращает значение одного из трёх полей итоговой записи, и только потом смотрим, какие им параметры надо передавать после разбиения исходной строки.


### Как проектировать ко-рекурсивные программы

Более сложный и более наглядный пример -- реализация функции, склеивающей (т.н. zipping) два списка попарно (по длине кратчайшего списка):

```
[1, 2, 3] + [4, 5, 6, 7] = [ (1, 4), (2, 5), (3, 6) ]
```

По типичной схеме анализа входных списков сразу возникает проблема уже на 4-м шаге: например, какой список (или оба сразу) обрабатывать в шаблоне? Получаем что-то вроде

```
если первый список пустой, то выдаём [ ] иначе 
если второй список пустой, то выдаём [ ] иначе 
zip (a : x) (b : y) = (a, b) : zip x y
```

где ":" -- операция представления списка в формате "голова-значение : хвост-список"

Возможно, потребуется ещё добавить случай, когда оба входных списка пусты -- и это только для двух параметров.

Применим схему игры в вопросы и ответы из HtDP для входных данных к нашей ко-рекурсивной схеме -- к выходным данным.

1. Когда выход будет пуст?
2. Если выход не пуст, то какова его голова?
3. Из каких данных рекурсивно строится хвост выхода?
4. Когда выход будет пуст? Когда хотя бы один из входных списков пуст.
5. Если выход не пуст, то какова его голова? Пара из голов входных списков.
6. Из каких данных рекурсивно строится хвост выхода? zip, применённая к хвостам входных списков.

Получаем что-то вроде

```
если первый или второй список пустой, то выдаём [] иначе
zip x y = (head x, head y) : zip (tail x) (tail y)
```


### Как проектировать ко-рекурсивные программы

Следующий пример -- сортировка выбором. В ко-рекурсивном подходе игра в вопросы-ответы будет такой:

1. Когда выход будет пуст? Когда вход пуст.
2. Если выход не пуст, то какова его голова? Минимальное значение из входного списка.
3. Из каких данных рекурсивно строится хвост выхода? Входной список без минимального элемента.

Это структурная ко-рекурсия, многократно извлекающая минимальный оставшийся элемент из входного списка в качестве следующего элемента выходного результата.


### Как проектировать ко-рекурсивные программы: генеративная рекурсия

Генеративную рекурсию следует изучать только после изучения структурной рекурсии и ко-рекурсии, потому что в ней удобно использовать оба эти подхода. Структурно-рекурсивные и ко-рекурсивные функции могут комбинироваться по паттерну "хиломорфизм" (hylomorphism) -- фактически, это классическая схема "разделяй и властвуй", или же через промежуточные виртуальные типы данных (которые формально в коде не задаются, а определяются только логикой работы рекурсивной функции). Но и обратный паттерн -- свёртывание от некоторого структурированного входа к некоторому промежуточному значению с последующим разворачиванием к другому структурированному выходу, также важен. Такой подход можно рассматривать как изменение структурной репрезентации, а называется он метаморфизм.

Один из простых примеров -- преобразование числа из входной системы счисления в число в выходной системе счисления. Это выполняется через некоторое промежуточное представление значения (в десятичном или двоичном формате, например), которое неструктурировано (не привязано к конкретной системе счисления), и наличествуют две фазы преобразования, отражающие структуры входных и выходных данных.


### Как проектировать ко-рекурсивные программы: генеративная рекурсия

В HtDP приводится простой пример, для которого структурный подход не работает. Это функция bundle, которая получает на вход строку и длину её разбиения, и возвращает список кусочков строк:

bundle "abcdefg" 3 = ["abc", "def", "g"]

Структурный подход тут не работает в том смысле, что входные данные тривиальны, и логики обработки входной строки из них никак не следует. Впрочем, и для сложных типов входных данных тоже конечно логика их обработки будет "естественно" следовать далеко не всегда.

Однако структурная ко-рекурсия тут работает вполне хорошо:

1. Когда выход будет пуст? Когда вход пуст.
2. Если выход не пуст, то какова его голова? Первая часть входной строки длиной n символов, или вся входная строка целиком, если её длина меньше или равна n.
3. Из каких данных рекурсивно строится хвост выхода? Входная строка без её первой части из n символов.

В итоге мы получаем ко-рекурсивную программу -- точно такую же, как в HtDP. Но в нашем процессе проектирования нет ничего хитрого или специального, и никакого инсайта или алгоритмического размышления не требуется, и мощь генеративной рекурсии не нужна. Программа формируется непосредственно по структурной ко-рекурсии.


### Как проектировать ко-рекурсивные программы: ленивость

Математические структуры, лежащие в основе структурных рекурсии и ко-рекурсии, получаются красивее, если допускать бесконечные структуры данных (которые, естественно, подразумевают ленивые вычисления), а без них некоторые рекурсивные определения не имеют решения. Однако на практике вполне можно (и удобнее) обходиться без бесконечных структур. HtDP предлагает особую схему проектирования для генеративной рекурсии, которую можно применить и к структурной ко-рекурсии.

Но так как структурная рекурсия над конечными структурами данных обязательно завершается, то в и ко-подходе вполне можно обойтись без ленивых вычислений.


### Как проектировать ко-рекурсивные программы: cтруктурное программирование

Важность чёткого определения выходной структуры данных известна довольно давно. Один из активных преподавателей программирования по книге HtDP -- Ramsey (2014), отмечает, что обычно разработчики редко проектируют функции по типу результата, но зря. В частности, в тестах всегда полезно разбирать, действительно ли результат (все его поля) полностью формируется внутри функции?

Всё важное в computer science было придумано в 1960-1970-е, сегодня просто понемногу отрывают даже не хорошо забытое, а просто хорошо проигнорированное.

"Существуют определенные тесные аналогии между методами, непосредственно применяемыми в функции для структурирования данных, и методами структурирования самой функций, которая обрабатывает эти данные."
Хоар "Notes on Data Structuring" 1972

"Если вы покажете мне код и скроете структуры данных, я ничего не пойму в вашей программе. Однако, если вы покажете мне структуры данных, код скорее всего не понадобится. Он будет очевиден."
Брукс "Мифический человекомесяц" 1975


### Как проектировать ко-рекурсивные программы: cтруктурное программирование

"Центральная тема этой книги -- взаимосвязь между данными и программными структурами. Данные определяют модель предметной области, и, основывая структуру наших программ на структурах данных, мы гарантируем, что наши программы получатся понятными и простыми в сопровождении... Структура программы должна определяться структурой её входных и выходных данных..."
Michael A. Jackson "Principles of Program Design" 1975

На Jackson structured programming (JSP) кстати в HtDP есть прямая отсылка.

В разборе одной из типичных задачек Джексон отмечает необходимость обращать внимание на структуру выходных данных так же, как и на структуру входных данных. На входе поток данных размером 80 символов в строке (перфокарты), на выходе поток данных размером 132 символа (принтер). Это прекрасный пример метаморфизма, представляющего собой структурную ко-рекурсию (выход шириной 132) после структурной рекурсии (конкатенация входа). Подход JSP был придуман для преобразования последовательных потоков входных записей в аналогичные потоки выходных записей. Суть этого подхода заключается в том, чтобы определить структуру каждой записи (входной и выходной) в терминах последовательностей, выборов и итераций, доработать их до некоторой общей структуры, которая соответствует всем им одновременно, и использовать эту общую структуру данных в качестве структуры программы.


### Как проектировать ко-рекурсивные программы: итоги

Felleisen в HtDP особо отмечает, и фактически извиняется за то, что генеративная рекурсия получается в значительной степени научным занятием в сравнении с проектированием структурно рекурсивных функций на основе данных. Правильнее назвать её научным "изобретением" алгоритма, нежели инженерным проектированием алгоритма. А изобретение подразумевает озарение, инсайт. Felleisen и говорит, что от простого программиста конечно нельзя ожидать такой алгоритмической проницательности: на практике новые сложные алгоритмы часто разрабатываются математиками и специалистами по computer science. Однако сильные программисты всё же должны хорошо понимать идеи, лежащие в основе этих алгоритмов, чтобы самостоятельно придумывать простые алгоритмы и общаться со специалистами по поводу сложных.

Но такое пораженческое настроение относительно генеративной рекурсии связано с тем, что мы не следуем основной идее "структура программы следует структуре данных". Например, структура вроде бы "чистых" алгоритмов быстрой сортировки или сортировки слиянием всё же достаточно явно следует некоторой структуре данных. Хотя конечно следует признать, что подобные алгоритмы требуют определённой практики и некоторой проницательности, чтобы выявить структуру, которая не присутствует явно ни на входе, ни на выходе. Но как только такая структура определена, в решении более не будет никакой дальнейшей загадки.


### Как проектировать ко-рекурсивные программы: итоги

Некоторые проблемы (та же сортировка) хорошо поддаются обоим подходам (рекурсия и ко-рекурсия), какой же из них лучше выбрать? Может даже показаться, что подобный выбор только усложняет решение задачи, но дело не в том, что один из подходов лучше другого. Скорее, программист должен быть всегда открыт для обеих возможностей, и выбирает одну из них только после изучения последствий. Вполне возможно, одно из них приведет к более аккуратному, более наглядному коду, или к выразительным абстракциям.

Начинающие программисты (под ними авторы подразумевают студентов Оксфорда :) нуждаются в хорошем руководстве по разработке на уровне programming in small; один из важных уроков --  **руководствоваться структурой данных** .

Структурная рекурсия и структурная ко-рекурсия -- это инструменты, но если мы предоставим программистам только молоток, они, естественно, будут относиться к каждой проблеме как к гвоздю; если же мы дадим им ещё и гаечный ключ, то по крайней мере, побудим их спросить себя, похож ли тот или иной металлический предмет больше на гвоздь или на болт. HtDP хорошо объясняет, как руководствоваться при написании программ структурой входных данных, но не учит программистов учитывать также и структуру выходных данных. Это упущенная возможность, которую мы только что исправили.
