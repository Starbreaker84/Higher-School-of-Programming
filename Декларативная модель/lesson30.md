### 24. Аккумуляторы

Мы выяснили, как создавать простые рекурсивные функции для обработки списков, как превращать их в итеративные, как правильно писать и использовать рекурсивные типы данных. Но на практике разработка в декларативной модели обычно исключает первый шаг: функция сразу же пишется итеративной. Идея такого подхода в том, чтобы передавать состояние всё дальше и дальше через вычисления, и никогда не возвращаться обратно через return.

Для этого любое состояние S расширяется парой аргументов S1 и Sn, которая называется  **аккумулятор** . Этот аккумулятор передаётся в процедуру, которая, напомню, подразумевает возвращение значения через свои параметры. S1 тут становится входным состоянием, а Sn -- выходным (результирующим) состоянием. Внутри такой процедуры происходит рекурсивный вызов, который выполняет последовательные преобразования S-i в S-i+1.

```
P(S, S1, Sn)
  если S заключительное (вычисления не требуются) то 
    Sn = S1
  иначе
    // рекурсивные вызовы 
    P1(S1, S2)
    P2(S2, S3)
    ...
    Pn(Sn-1, Sn)
```

Выход каждой процедуры Pi служит входом для следующей процедуры Pi+1.

Как правило, качественное отличие этого подхода от рекурсивных функций в том, что за счёт передачи результата по ссылке можно не создавать множество промежуточных копий состояний, указывать только, например, границы (диапазон) обработанных элементов в исходной структуре.

Так, рассмотренная ранее функция IterLen потенциально использует схему с аккумулятором, так как передаёт результат (текущую длину) в следующий вызов -- только не так явно, так как в ней используется return вместо записи результата в аргумент, переданный в параметр по ссылке.
В данном случае удаётся обойтись одним рекурсивным вызовом, но когда требуются вызовы нескольких других "процедур"? Например, если мы обрабатываем дерево, где явно разделяются левое и правое поддеревья, для каждого из них потребуется явный отдельный рекурсивный вызов.


Более наглядный пример -- это версия функции LengthL с аккумулятором. В ней мы делим список на две (или больше) примерно равные части, вызываем функцию рекурсивно для каждой из них, после чего возвращаем итог.

```
function LengthLA(Xs)

    l = length(Xs)
    if l == 0
        return 0
    elseif l == 1
        if isa(Xs,Array)
           return LengthLA(Xs[1])
        else
           return 1
        end 
    end

    head = Xs[1:div(l,2)]
    tail = Xs[div(l,2)+1:end]

    n1 = LengthLA(head)
    n2 = n1 + LengthLA(tail)
    return n2

end
```

Преимущество её в том, что рекурсивные вызовы для анализа примерно равных частей head и tail могут выполняться параллельно.


Однако недостаток подхода с равными частями в том, что требуется создавать множество копий частей исходного списка, как и в оригинальной версии. Аккумуляторы позволяют избавиться от этого существенного недостатка: мы можем передавать основной список по ссылке, а также дополнительно указывать диапазон (начало и конец) в этом списке, который требуется проанализировать. Таким образом мы получаем огромный выигрыш в производительности и экономии памяти.

```
function LengthLA2(Xs, from, to)
    l = to-from+1
    if l == 0
        return 0
    elseif l == 1
        if isa(Xs,Array)
           return LengthLA2(Xs[from][1],1,length(Xs[from]))
        else
           return 1
        end 
    end

    n1 = LengthLA2(Xs,from,from+div(l,2)-1)
    n2 = n1 + LengthLA2(Xs,from+div(l,2),to)
    return n2
end
```

В практических проектах количество аккумуляторов в функциях достигает подчас нескольких десятков, что существенно затрудняет программирование. Сегодня схема с аккумуляторами считается устаревшей, её имеет смысл использовать, когда удаётся обойтись не более чем 1-2 аккумуляторами.


### Аккумуляторы (задания)

======= 54. На практике разработка в декларативной модели подразумевает, что ...

[ ]функция сразу же пишется рекурсивной

[X]функция сразу же пишется итеративной

======= 55. Аккумулятор -- это ...

[X] пара дополнительных аргументов (входное и выходное состояния)

[ ] аргумент, передающийся по ссылке

======= 56. Аккумуляторы позволяют избавиться от ...

[ ] рекурсивных вызовов для анализа примерно равных частей

[] указания диапазона для анализа

[X] создания множества копий частей исходного списка
