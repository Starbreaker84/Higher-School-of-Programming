### Деревья

Общая операция для дерева, как упоминалось выше – это обход всех его узлов в некотором заданном порядке, и выполнение некоторой операции над каждым узлом (в частности, при его посещении во время обхода). Например, если это абстрактное синтаксическое дерево, то при его обходе можно сразу генерировать результирующий программный код.

**Стандартная процедура обхода дерева DFS** (depth-first search) очень проста: находясь в некотором узле, мы последовательно вызываем DFS для каждого из его дочерних узлов. Сама по себе она не очень полезна, так как ничего не вычисляет. Можно например её использовать для вывода дерева на печать, но для какого-то реального применения потребуется версия DFS с аккумулятором.

В таком случае появятся три версии DFS:
– сверху вниз (результат накапливается по мере движения от родительских узлов к дочерним, это по сути FoldL),

- снизу вверх (результат накапливается при подъеме от дочерних узлов, когда мы рекурсивно спустились к ним, обратно к родителям, это по сути FoldR),
- или в каком-то другом порядке (например, по уровням дерева).

### 40. Явное ленивое оценивание

Во многих современных языках программирования применяется встроенная стратегия "вычисления" кода, называемая  **ленивое оценивание или ленивое исполнение** , которое немного упоминалось раньше. Скрытое ленивое оценивание практически всегда связано с параллельным выполнением, а вот явное ленивое оценивание хорошо реализуется с помощью программирования высшего порядка.

Ленивое исполнение/оценивание подразумевает, что некоторая структура данных (например, список) формируется последовательно. Например, очередной элемент списка "готовится" непосредственно в тот момент, когда он реально потребовался в каких-то вычислениях. При этом вполне возможна ситуация, когда например элементы списка с миллионом объектов вообще не будут востребованы, или будут востребовано лишь малое их количество, что позволит сэкономить много ресурсов. Это так называемое  **вычисление/исполнение по запросу** .
Классическая же реализация предполагает, что все структуры данных к моменту начала программы полностью сформированы независимо от того, будут ли они вообще востребованы.

Реализация ленивого исполнения подразумевает наличие некоторого механизма запроса нового элемента. Назовём такой механизм  **триггером** . Есть два способа выразить триггеры в декларативной модели: **переменные dataflow** (используются в декларативном параллелизме, который мы немного рассматривали во вступительных статьях), и  **программирование высшего порядка** . Во втором случае триггером выступает функция, которая возвращает пару значений: элемент списка и новую функцию. Новая функция – это новый триггер: вызов её даёт следующий элемент данных и следующую новую функцию, и так далее.

### 41. Карринг (Currying)

Эта техника упрощает программы, где активно применяется программирование высшего порядка. Идея карринга –  **записать одну функцию с n параметрами как n функций с одним параметром** .

Напрямую в Julia отсутствует карринг (а во многих функциональных языках Haskell, OCaml и др. все функции по умолчанию каррированы), и в декларативной модели в целом какой-либо специальной его поддержки нету. Но интенсивное применение программирования высшего порядка на практике обычно подразумевает поддержку карринга.

Например можно установить поддерживающий карринг в Julia пакет Currier. Перейдите в менеджер пакетов Pkg (запустите командную строку Julia и нажмите "]") и введите

```
add https://github.com/MasonProtter/Currier.jl
```

Пример использования пакета Currier:

```
using Currier

@curried function foo(x, y, z)
    return x + y + z
end

a = foo(1, 2, 4) # 7
a = foo(1)(2)(4) # 7

f = foo(1)(2) # f – функция с одним параметром
a = f(4) # 7

f = foo(1) # f - функция с двумя параметрами
a = f(2)(4) # 7
```


### Разное (задания)

======= 80. Стандартная процедура обхода дерева depth-first search ...

[ ]полезна, так как обходит всё дерево в строгом порядке

[x]бесполезна, так как не содержит аккумулятор для промежуточных вычислений

======= 81. Ленивое вычисление подразумевает, что ...

[ ]структура данных формируется полностью, но выдаётся постепенно

[x]структура данных формируется постепенно по мере обращения к ней

======= 82. Карринг -- это ...

[ ]записать n функций с одним параметром как одну функцию с n параметрами

[x]записать одну функцию с n параметрами как n функций с одним параметром
