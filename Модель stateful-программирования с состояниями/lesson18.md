### 18. Пример выбора между stateful-моделью с состояниями и декларативной stateless-моделью

Рассмотрим  **пример создания генератора случайных чисел** . Этой теме посвящено огромное количество работ, в частности, глубокое погружение в тему имеется в "Искусстве программирования" Кнута.

На практике применяются три основных подхода к созданию таких генераторов.

1. **Использование неких непредсказуемых событий на уровне ОС** -- например, связанных с параллелизмом. Увы, такая непредсказуемость не подчиняется простым законам. Например, использование планировщика потоков в качестве источника случайности даёт некоторые случайные "колебания", однако они не характеризуются качественным распределением вероятности. Более того, они тесно связаны с вычислениями столь неочевидными способами, что даже если бы их распределение было подходящим, оно всё равно зависело бы от вычислений. Таким образом, это не лучший источник случайных чисел.
2. **Использование готового источника истинной случайности** . Например, электронные схемы генерируют шум, который представляет собой практически непредсказуемый сигнал, приблизительное распределение вероятности которого известно. Фактически, для всех практических целей он действительно случаен. Но есть две проблемы.

Во-первых,  **само по себе распределение вероятности точно не известно** : оно может слегка меняться от одной схемы к другой, или в зависимости от температуры окружающей среды. Да, есть способы "нормализовать" случайные числа так, чтобы их распределение стало известным. Но существует вторая, более серьезная проблема:  **случайность нельзя воспроизвести иначе, нежели просто сохранив серию случайных чисел от источника, и воспроизведя их в коде** .

Но **требование повторной воспроизводимости некоторой случайной последовательности в программировании возникает постоянно** -- например, при отладке некоторого симулятора или игры. Мы хотели бы варьировать некоторый параметр генератора так, чтобы каждый раз получать разные, но повторяемые для конкретного значения параметра последовательности. По этой причине в обычных компьютерах обычно не используются действительно случайные генераторы.

Может показаться, что мы старательно загоняем сами себя в угол. Мы хотим истинной случайности, и при этом хотим, чтобы она была воспроизводимой.

**3. Решение простое: мы вычисляем случайные числа по некоторому алгоритму** . Каким образом можно генерировать действительно случайные числа? Простой ответ -- никак. Но числа могут "казаться" случайными для подавляющего большинства практических задач. Они называются псевдослучайными числами. Что это значит? Это не так просто определить. Грубо говоря, программно сгенерированные числа должны давать такое же поведение, как и истинно случайные числа.

Однако алгоритмы генерации псевдослучайных чисел почти всегда имеют существенные недостатки. Мы не можем гарантировать, что случайные числа будут достаточно хорошими, но мы можем попытаться получить то, что возможно. Например, сгенерированные случайные числа должны удовлетворять определённым качественным статистическим характеристикам, иметь подходящее распределение, а их период должен быть достаточно длинным. Поскольку генератор случайных чисел производит вычисления с конечным объемом информации, в конечном итоге последовательность будет повторяться. Очевидно, что при этом период повторения должен быть очень длинным.

### Генератор равномерно распределённых случайных чисел

Генератор случайных чисел хранит внутреннее состояние, с помощью которого он вычисляет следующее случайное число и следующее внутреннее состояние. Состояние должно быть достаточно большим, чтобы обеспечить длительный период повторения. Генератор инициализируется значением, называемым "зёрнышко" (seed). Повторная инициализация с тем же самым зёрнышком должна дать ту же самую последовательность случайных чисел. Если нам не нужна одна и та же последовательность, мы можем инициализировать генератор информацией, которая никогда не будет одинаковой -- например, текущей датой/времем в секундах (или их долях), начиная с некоторой точки отсчёта. Во всех современных ОС есть операция для получения такой информацию о времени.

Определим абстрактный тип данных для генератора псевдослучайных чисел.

Конструктор с параметром Max создаёт экземпляр генератора с внутренним состоянием. Max задаёт максимальное значение случайных чисел, если явных требований к верхней границе нету, лучше выбирать его побольше.

Метод Init с параметром Seed инициализирует генератор заданным зёрнышком, которое располагается в диапазоне 0,1,...,Max. Отсюда понятно, что Max желательно выбирать достаточно большим, чтобы избегать повторяющихся последовательностей. Init может быть вызван в любой момент.

Метод Rand возвращает случайное число и обновляет внутреннее состояние. Число генерируется в диапазоне 0,1,...,Max-1. Все числа в этом диапазоне имеют равную вероятность генерации.

Как вычислить очередное случайное число? Например, популярный и простой -- так называемый линейный конгруэнтный метод, где

```
X(i) = (a * X(i-1) + c) % m.
```

Возможный набор констант: m = 10 (все числа получаются в диапазоне 0..9), X(0) = a = c = 7, последовательность формируется такая: 7,6,9,0,7,6,9,0,...

Период в такой последовательности не превышает m.

Внутреннее состояние -- это X(i).

Более реалистичные значения: a = 333667, c = 213453321, m = 1000000000.

---

В виде АТД данный алгоритм в stateful-модели реализуется просто и прозрачно. Однако если вы попытаетесь реализовать данный алгоритм в виде обычной функции, то сразу возникнет вопрос, где хранить её промежуточное состояние? В языках типа Си это решалось добавлением глобальной переменной внутри модуля стандартной библиотеки, где располагалась соответствующая функция, но этот подход нарушает сразу несколько принципов хорошего стиля разработки. Поэтому в современных языках в качестве генераторов случайных значений используется не функция, а объект (например, в C# это класс Random).

Однако линейный конгруэнтный алгоритм может быть реализован и без состояния, в декларативной модели -- как ленивая функция или итератор. Например, в Python такой генератор без внутреннего состояния легко программируется с помощью yield.

**Общие выводы**

И модель с состояниями, и декларативная модель в целом смотрятся одинаково разумными для прикладного использования.

Качественное проектирование АТД или выбор готовой структуры данных в реализации некоторого компонента существенно важнее, нежели выбор вычислительной модели (stateful, stateless, ...).

Декларативные программы обычно менее читабельны, нежели программы с состояниями, потому что они должны быть написаны, как правило, в конвейерном виде (данные передаются между функциями).

Программы с состояниями обычно получаются более монолитными, нежели декларативные, потому что явное состояние может модифицироваться достаточно свободно. Для борьбы с излишней монолитностью применяются например соответствующие подходы ОО-проектирования.

Существенно легче распараллеливать декларативный код, потому что между его частями существенно меньше зависимостей, нежели в случае stateful-модели.

### 19. Управление ресурсами

Сборка мусора -- классическая техника автоматического управления памятью и освобождения её от неиспользуемых сущностей. Однако она может плохо работать, если эти сущности не входят в используемую вычислительную модель -- например, они просто взаимодействуют с нашей системой из внешнего мира, и при этом могут "ломаться" (например, становиться недоступными, отключаться по таймауту и т. д.).

Тут возможны два подхода:

1. Внутри вычислительной модели хранится ссылка на внешнюю сущность -- назовём её указатель на ресурс. Например, это:

- дескриптор файла ОС, через который мы закрываем файл, обработка которого завершена;
- сущность, связывающая приложение с СУБД, через которую мы закрываем соединение с базой данных;
- указатель на блок памяти, выделенный ОС -- когда работа с ним завершена, мы явно освобождаем память.

2. Внутри вычислительной модели хранится ссылка, полученная из внешнего мира -- она называется  **ярлык (ticket)** . Ярлыки применяются в распределённом программировании для связывания процессов вместе. В общем случае в этом подходе нету безопасного способа для освобождения памяти или другого ресурса по окончании его использования. Один из приёмов -- **механизм временной аренды (time-lease mechanism)** внутри применяемого языка программирования, который предполагает доступ к таким внешним сущностям на ограниченный период времени, после чего этот доступ надо обновлять (получать новый ярлык). В таком случае приложение сразу проектируется с учётом того, что время "аренды" внешнего ресурса может истечь.

Первый подход в языках программирования нередко поддерживается так называемой **финализацией** -- возможностью выполнить определённые инструкции, когда соответствующая сущность перестала быть доступной (например, файл был закрыт). Обычно это явно реализуется в коде дополнительной инструкцией (например, finalize), закрывающей блок, который начинается командой открытия файла. За finalize соответственно следует код, который обязательно вызовется, когда обработка файла полностью завершится.

С помощью однократного вызова финализации, например, можно реализовать ленивую обработку файла. Имеется компонент с внутренним состоянием (например, функция с замыканием), который представляет собой своеобразный итератор по содержимому файла. Он хранит внутри дескриптор файла, и при очередном обращении к такому итератору файл открывается, если ещё не был открыт, из него считывается очередной блок данных (текущая позиция в файле также сохраняется во внутреннем состоянии), и так продолжается, пока файл не будет считан полностью. А когда он закончится, однократно вызывается финализация, которая закрывает файл и выдаёт нужное сообщение о завершении работы.

### 20. Некоторые важные моменты

**Оператор break**

Это известный во многих массовых императивных языках оператор немедленно прерывает некоторый блок кода (на концепции блока кода основаны Java, C#, C++...), передавая управление внешнему блоку. Проблема в контексте современных трендов движения в параллелизм в том, что break может выполняться внутри некоторой "нити", которая работает одновременно с другими. Например, break вызывается из тела цикла, которое в модели одновременного выполнения потенциально может выполняться "параллельно" с другими итерациями (пример на Julia мы разбирали в первом курсе "как понять в программировании всё"). В таком случае непонятно, что делать, если работа цикла в одной из нитей прерывается, однако другие итерации, другие "тела" цикла в других нитях ещё продолжают работу. Надо ли прерывать их работу?

Правильный ответ: нет, прерывать работу других нитей в таком случае нельзя, однако в целом такое неоднозначное выполнение цикла желательно завершать исключительной ситуацией.

**Декларативные объекты и идентичность**

Мы рассматривали, как строить декларативный объект, который объединяет состояние и операции безопасным способом. Однако упущен такой аспект декларативных объектов, как их идентичность. Так как декларативные объекты иммутабельны -- после выполнения операции модификации каждый раз создаётся новый экземпляр, часто требуется понимать, что этот новый экземпляр -- фактически "тот же самый" по смыслу объект, который был и до этой операции. В императивном программировании с состояниями это реализуется прозрачно -- хранением ссылки на однократно созданный объект в переменной на протяжении всей программы. В случае декларативного подхода оказывается полезным добавлять в декларативные АТД операции, которые выдают некоторый уникальный идентификатор (число или строку) этого объекта.

**Эмуляция состояния в декларативной модели**

Некоторые мутабельные структуры данных можно эмулировать в декларативной модели. Имеется обновляемый контейнер (например, список/массив ячеек, значения которых можно как считывать, так и менять). Считывание значения i-й ячейки декларативно реализуется прозрачно с помощью рекурсии. Обновление значения i-й ячейки декларативно реализуется также рекурсивно созданием новой копии списка, где вместо i-й ячейки создаётся и подставляется новая ячейка с новым значением.

### 21. Ограничения программирования с состояниями

ООП как развитию stateful-парадигмы присущи также соответственно все эти ограничения.

**Реальный мир параллелен**

Основное ограничение stateful-модели заключается в том, что программы последовательны (императивны). В реальном мире сущности одновременно и имеют внутреннее состояние, и действуют параллельно. Последовательное программирование никак не моделирует параллельное исполнение. Иногда такое ограничение уместно, например, при написании систем, где все события скоординированы (переход из одного глобального состояния в другое происходит контролируемым образом). В других случаях, например, при взаимодействии с реальным миром (живыми пользователями), это ограничение становится серьёзным препятствием.

Чтобы его снять, модели надо поддерживать как состояние, так и параллелизм, что мы изучим на отдельном курсе.


### Поздравляю! Курс по императивной модели программирования успешно завершён!

**Реальный мир -- распределённый**

Явное состояние трудно продуктивно использовать в распределенной системе, где хранилище данных часто разделено на отдельные части. В пределах одной части хранилище ведет себя эффективно, однако организация связи между его частями обходится уже на порядки дороже. Частям надо координироваться друг с другом для поддержания желаемого уровня глобальной согласованности. Это может быть дорогостоящим, поскольку содержимое ячеек может измениться в любое время и в любой части системы. Программисту нужно обеспечить как уровень согласованности, так и эффективный алгоритм координации, что существенно усложняет распределённое программирование с состояниями. Многие такие проблемы и технические способы их решения рассматриваются на курсах по highload-системам.

Основной подход --  **разделение системы на независимые подсистемы, которые общаются друг с другом через обмен сообщениями** . Он очень хорошо сочетается с разделенным хранилищем данных. При программировании распределенной системы рекомендуется всегда использовать модель передачи сообщений для координации работы её частей. Напомню, из изученных чуть ранее шести наиболее популярных протоколов для взаимодействия между компонентами, надо придерживаться как минимум четвёртой схемы ([асинхронность](https://vk.com/wall-152484379_3401)).

---

На следующем курсе рассмотрим, как на основе императивной модели реализуется **парадигма объектно-ориентированного программирования** -- добавлением всего одного нового понятия.
