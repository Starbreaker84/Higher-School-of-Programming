### 13. SS-таблицы и LSM-деревья

Изменим формат файлов сегментов:  **потребуем, чтобы последовательность пар «ключ-значение» была отсортирована по ключу** . На первый взгляд, это требование помешает вести последовательную запись в файл, и вроде бы возникнут другие проблемы, связанные с работой с журналом. Но давайте сперва посмотрим, какие мы получаем плюсы.

Новый формат называется  **отсортированная строковая таблица (sorted string table, SSTable), сокращенно -- SS-таблица** . Мы требуем при этом, чтобы каждый ключ встречался лишь один раз в каждом объединённом файле сегмента (а это гарантируется процессом уплотнения).

У SS-таблиц есть несколько больших преимуществ перед журнальными сегментами с хэш-индексами.

Чтобы найти в файле конкретный ключ, не нужно больше хранить индексы всех ключей в оперативной памяти -- ведь ключи отсортированы, и доступ к ним получается существенно быстрее.

Объединение сегментов теперь выполняется просто и эффективно, даже если размер файлов превышает объем доступной оперативной памяти. Этот подход близок к используемому в алгоритме сортировки слиянием, который мы проходили на курсе по сортировкам и поиску.

Поддержка отсортированной структуры на диске возможна (например с помощью B-деревьев, см. далее), но гораздо проще делать это в оперативной памяти. Для этого существует множество хорошо известных древовидных структур данных, например [красно-чёрные деревья](http://skillsmart.ru/algo/15-121-cm/ubd85a3720.html) или сбалансированные двоичные деревья.

При использовании этих структур можно быстро добавлять ключи в любой последовательности и затем читать их в нужном порядке.

Но есть одна проблема: если происходит фатальный сбой БД, то данные, записанные позже всего (физически находящиеся пока в памяти, и ещё не записанные на диск) теряются. Чтобы избежать этого, можно вести на диске отдельный журнал, в который немедленно добавляются все записываемые данные. Сам журнал неупорядочен, но это неважно, ведь его единственное назначение — восстановление структуры в памяти после сбоя.

Изначально такая индексная структура была описана Патриком О’Нилом как  **журналированное дерево слияния (Log-Structured Merge-Tree, LSM-Tree)** . Поэтому подсистемы хранения, основанные на принципе слияния и уплотнения отсортированных файлов, часто называются LSM-подсистемами хранения.

Алгоритм на основе LSM-дерева может работать медленно при поиске отсутствующих в базе данных ключей: приходится просматривать всю структуру в памяти, и затем все сегменты вплоть до самого старого (вероятно, читая каждый из них с диска), прежде чем удастся убедиться, что ключ отсутствует. Чтобы оптимизировать подобную разновидность доступа, подсистемы хранения часто применяют знакомые вам фильтры Блума. Он позволяет быстро (почти за O(1)) установить, встречается ли ключ в базе данных, экономя таким образом множество лишних чтений диска для несуществующих ключей.


## SS-таблицы и LSM-деревья (задания)

======= 44. SS-таблица -- это ...

[ 1] отсортированная таблица строковых ключей

[ ] отсортированная таблица строковых значений

[ ] таблица всех ключей в оперативной памяти

[ ] таблица ключей c поддержкой сортировки слиянием

======= 45. SS-таблица реализуется как ...

[ ] уплотнённые файлы

[ ] B-деревья

[1 ] красно-чёрные и подобные деревья

[ ] слияния и уплотнения отсортированных файлов

======= 46. LSM-дерево -- это ...

[ ] уплотнённые файлы

[ ] B-деревья

[ ] красно-чёрные и подобные деревья

[ 1] слияния и уплотнения отсортированных файлов

======= 47. LSM-дерево работает быстро, когда ...

[1 ] ключ в базе есть

[ ] ключа в базе нету, но проверяем фильтром Блума

[ ] всегда
