### Секционирование и вторичные индексы

Обсуждавшиеся до сих пор схемы секционирования основывались на модели данных "ключ — значение".

Проблема 70. Если обращение к записям происходит исключительно по их первичному ключу, то выяснение секции и оптимизация маршрутизации запросов выполняется достаточно хорошо. Однако ситуация сильно осложняется в случае применения вторичных индексов.

Дело в том, что некоторые хранилища данных (например, Riak) добавляют вторичные индексы в силу их исключительного удобства для моделирования данных. Кроме того, вторичные индексы -- суть поисковых серверов наподобие Solr и Elasticsearch.

Основная проблема вторичных индексов в том, что их невозможно поставить в чёткое соответствие секциям. Тут применяются два основных подхода: секционирование по документам (document-based partitioning) и секционирование по термам (term-based partitioning).

Решение.

1) **Секционирование вторичных индексов по документам** .

Пусть имеется сайт по продаже компьютеров. У каждого описания компьютера есть уникальный Id (идентификатор документа), и можно секционировать БД по этому идентификатору. Все секции тут самостоятельны: каждая секция поддерживает свои собственные вторичные индексы, охватывающие только документы из этой секции.

При необходимости выполнить добавление, удаление или обновление документа приходится работать только с той секцией, в которой содержится идентификатор записываемого документа. Поэтому секционированный по документам индекс также называется  **локальным индексом (local index)** .

### Секционирование и вторичные индексы

Проблема 71. Cовершенно не обязательно, что все компьютеры конкретной сборки или конкретного производителя окажутся в одной секции. Следовательно, при поиске таких компьютеров придётся выполнять запрос ко всем секциям -- с объединением полученных результатов.

Подобная методика называется  **фрагментированной (scatter/gather)** , и запросы на чтение в ней могут оказаться весьма затратными. Даже при параллельном выполнении запросов к секциям фрагментированное чтение часто приводит к увеличению времени ожидания. Тем не менее оно широко используется в MongoDb, Riak, Cassandra, Elasticsearch и др.

Однако при этом большинство производителей СУБД рекомендуют структурировать схему секционирования так, чтобы запросы по вторичным индексам могли выдаваться из одной секции.

Решение. Вместо локальных индексов можно сконструировать  **глобальный индекс (global index)** , охватывающий данные из всех секций.

### Секционирование и вторичные индексы

Проблема 72. Глобальный индекс нельзя хранить в одном узле, иначе он превратится в узкое место.

Решение. Глобальный индекс тоже надо секционировать. Например, компьютеры из всех секций заданы в индексе по значению производителя, но сам индекс секционирован так, что названия производителя, начинающиеся с букв от a до r, находятся в секции 0, а названия, начинающиеся с букв от s до z -- в секции 1. Индекс по другим характеристикам автомобилей секционирован аналогично.

2) Такая разновидность индекса называется  **секционированной по терму (term partitioned)** , поскольку искомый терм определяет секционирование индекса.

Преимущество секционированных по терму индексов -- это повышение производительности чтения: вместо фрагментированного чтения по всем секциям теперь достаточно выполнить запрос к секции, содержащей нужный терм. Однако при этом возможно замедление и усложнение операций записи, так как запись может затронуть несколько секций индекса: все термы в записи могут находиться в разных секциях и в разных узлах (например, по марке и по цвету автомобиля).

### Секционирование и вторичные индексы (задания)

======= 60. Секционирование вторичных индексов по документам -- это ...

[1 ] в каждой секции свои собственные вторичные индексы только по документам из этой секции

[ ] ведётся глобальный индекс по данным из всех секций

[ ] глобальный индекс секционируется по данным из всех секций

======= 61. Секционирование по терму -- это ...

[ ] в каждой секции свои собственные вторичные индексы только по документам из этой секции

[ ] ведётся глобальный индекс по данным из всех секций

[1 ] глобальный индекс секционируется по данным из всех секций
