### Метод не вызывается в тестах

Как уже говорилось, если удаётся получить отдельный экземпляр класса для тестирования, то можно считать, что вам просто повезло. Но главные трудности впереди: ведь задача -- написать тесты для методов, в которые требуется внести изменения, а вызвать их подчас бывает ещё сложнее, чем конструктор.

36. Проблема. Но для начала отметим универсальный приём, который подходит и для случаев, когда тяжело создавать экземпляр класса, где находится вызываемый объект.

Решение. Иногда вызвать метод возможно, вообще не создавая экземпляр класса, если в этом методе не используются внутренние атрибуты класса, или такую логику можно как-то изолировать. Тогда можно оформить этот метод как статический.

### Метод не вызывается в тестах

37. Проблема. Нередко создание экземпляра нужного класса для тестирования конкретного метода оказывается слишком трудоёмким.

Решение. Выносим метод в отдельный класс, экземпляр которого получить легко: либо в наследник владельца метода (если этот класс формируется только для тестов), либо в родительский класс (с сохранением принципа подстановки Лисков).

### Метод не вызывается в тестах

38. Проблема. Метод скрытый/приватный, и напрямую вызывать его из объекта невозможно.

Решение. Тестируем public-метод, в котором используется данный приватный метод. Таким образом мы избавляемся от всех хлопот, связанных с организацией доступа к приватному методу. А тестируя общедоступные методы, мы гарантированно проверяем метод в том виде, в каком он реально используется в коде.

### Метод не вызывается в тестах

39. Проблема. Иногда протестировать public-метод, в котором используется нужный приватный метод, очень трудоёмко. Сам приватный метод напрашивается сделать public/общедоступным, но такой перевод приватного метода в public вызывает неоднозначные подозрения, сомнения... Например, метод выполняет какие-то второстепенные, вспомогательные функции, и не нужен пользователям данного класса. А если вдруг программисты действительно начнут этим открытым методом пользоваться, то вполне могут наломать дров.

Решение. Обычно это означает, что соответствующий класс выполняет слишком много задач, нарушая принцип единственной ответственности. Переносим соответствующие приватные методы в новый класс, где делаем их общедоступными, и обращаемся к ним из исходного класса. Благодаря этому все методы становятся хорошо тестируемыми, и дизайн кода также улучшается.

### Метод не вызывается в тестах

40. Проблема. Если проектировщики классов не придерживаются правильных принципов построения АТД (что очень характерно для легаси), получается, что многие объекты работают автономно в том смысле, что их методы вообще ничего не возвращают, и никакие флажки результата не устанавливаются. Вызывающей программе фактически ничего не известно о том, что происходит внутри таких методов, и как изменился объект, если все атрибуты скрыты внутри него.

Решение. Правильная схема проектирования классов рассматривалась на первом курсе по ООАП. Напомню, выполняем разделение команд и запросов -- принцип, сформулированный Бертраном Мейером. Метод может быть либо командным, либо запросным, но не тем и не другим одновременно. Командный метод изменяет состояние объекта, но не возвращает значение, однако в классе возводится флажок, показывающий успешность выполнения команды. А запросный метод просто возвращает некоторое значение, но никак не изменяет объект.

### Метод не вызывается в тестах

41. Проблема. В некоторых классах, где наличествуют зависимости, препятствующие созданию экземпляра класса, имеются явные смысловые совокупности нескольких методов класса, а в них отсутствуют какие-либо труднопреодолимые зависимости.

Решение. Подобную совокупность методов можно вынести в абстрактный родительский класс или интерфейс, и затем добавить ему класс-наследник, экземпляры которого будут использоваться в тестах.

42. Проблема. Зачем в таком случае делать родительский класс абстрактным?

Решение. Всегда очень полезно знать, что в проекте используется каждый конкретный класс, в противном случае вполне может появиться "мёртвый" невыполняемый код.

### Метод не вызывается в тестах (задания)

======= 33. Выберите плохой способ тестироания конкретного метода:

1[ ] выносим метод в новый абстрактный класс

[ ] выносим метод в класс-наследник

[ ] выносим метод в родительский класс

[ ] делаем метод статическим

======= 34. Метод приватный, и напрямую вызывать его из объекта невозможно. Какой подход тут будет ошибочным?

[] тестируем public-метод, использующий данный приватный метод

[ ] переносим приватный метод в новый класс, и делаем его публичным по SRP

[ 1] делаем приватный метод публичным в текущем классе

======= 35. Легаси-объекты часто работают автономно: их методы ничего не возвращают, и доступа к атрибутам нету. Как быть?

[1 ] выполняем разделение команд и запросов по Бертрану Мейеру

[ ] выносим группы методов по SRP в абстрактный класс

[ ] выносим группы методов по SRP в класс-наследник

[ ] создаём геттеры в исходном классе для нужных атрибутов

======= 36. Некоторые группы методов в классе логически явно связаны в одно целое.

[ ] выполняем разделение команд и запросов по Бертрану Мейеру

[1 ] выносим группы методов по SRP в абстрактный класс

[ ] выносим группы методов по SRP в класс-наследник

[ ] создаём геттеры в исходном классе для нужных атрибутов
