### 13. Архитектура на монадах состояний

В нашем случае обрабатывать/вычислять по цепочке мы будем то самое состояние **RobotState** из функционального примера -- внутреннее состояние в терминах нашей архитектуры, а не понятие "состояние" из монад состояний.

В качестве монады мы задействуем некий список, который будет накапливать "лог", предназначенный для функции transfer_to_cleaner(), непосредственно управляющей роботом.

В соответствии с концепцией монад состояний, каждая наша (в идеале каррированная) функция (move, turn, start/stop, ...) будет получать входное значение, полученное от предыдущей функции в цепочке, и дополнительные параметры, если требуются. Корректнее конечно говорить, что у нас есть функция с одним параметром, которая получает входное значение и возвращает функцию с одним параметром -- стейтом. Эта возвращаемая штуковина, по сути, и является строительным кирпичиком всей нашей архитектуры. Как связаны каррированная функция, и стейт-функция, будет наглядно видно в примере кода.

В функциональных языках со статической типизацией в цепочке вычислений можно единообразно/генерализованно использовать функции с переменным количеством параметров и разными типами (например, move получает значение типа "расстояние", turn -- значение типа "угол", а stop вообще не имеет параметра), которые возвращают упомянутый выше функциональный "кирпичик" единого типа. Для этого их требуется обычно вручную сделать монадическими (выполнить так называемый  **lifting** ).

В нашем случае, во-первых, реализация монад в будет довольно условна, а во-вторых, Python -- язык динамический, и парадоксальным образом нам вообще не надо волноваться по этим поводам. Для поддержки монад мы используем отличную библиотечку [PyMonad](https://pypi.org/project/PyMonad/).


### 13. Архитектура на монадах состояний

Вот как будут выглядеть все наши функции в монадическом формате:

```
import math
from collections import namedtuple
from pymonad import *

RobotState = namedtuple("RobotState", "x y angle state")

# режимы работы устройства очистки
WATER = 1 # полив водой
SOAP  = 2 # полив мыльной пеной
BRUSH = 3 # чистка щётками

def transfer_to_cleaner(message):
    print (message)
    return None

# перемещение
@curry
def move(dist,old_state):
    @State
    def state_computation(x):
        angle_rads = old_state.angle * (math.pi/180.0)
        new_state = RobotState(
                old_state.x + dist * math.cos(angle_rads),
                old_state.y + dist * math.sin(angle_rads),
                old_state.angle,
                old_state.state)
        s = 'POS(%d,%d)' % (new_state.x,new_state.y)
        z = x + List(s)
        return (new_state,z)
    return state_computation

# поворот
@curry
def turn(turn_angle,old_state):
    @State
    def state_computation(x):
        new_state = RobotState(
            old_state.x,
            old_state.y,
            old_state.angle + turn_angle,
            old_state.state)
        s = 'ANGLE %d' % new_state.angle
        z = x + List(s)
        return (new_state,z)
    return state_computation

# установка режима работы
@curry
def set_state(self_state,old_state):
    @State
    def state_computation(x):
        new_state = RobotState(
            old_state.x,
            old_state.y,
            old_state.angle,
            self_state)
        s = 'STATE %d' % self_state
        z = x + List(s)
        return (new_state,z)
    return state_computation

# начало чистки
@curry
def start(old_state):
    @State
    def state_computation(y):
        z = y + List('START')
        return (old_state,z)
    return state_computation

# конец чистки
@curry
def stop(old_state):
    @State
    def state_computation(y):
        z = y + List('STOP')
        return (old_state,z)
    return state_computation

x = unit(State, RobotState(0.0, 0.0, 0, WATER)) >> move(100) >> turn(-90) >> 
set_state(SOAP) >> start >> move(50) >> stop

print (x(List('')))
```

Например, функция move() получает на вход параметр дистанции dist и старое внутреннее состояние -- наш "объект" RobotState, над которым производятся основные вычисления. А возвращаемая функция state_computation() получает на вход единственную монаду-список, в котором мы храним лог действий, добавляет в неё новый элемент лога, и передаёт по цепочке новое рассчитанное значение и монаду-стейт.

В функциональных языках многие эти моменты скрыты внутри реализации, но зато в Python они получаются очень наглядны в плане внутреннего устройства.

Чтобы начать вычисление нашей цепочки, на вход ей требуется подать начальное значение. В PyMonad для этого используется функция unit() (аналог return из монад в функциональных языках).

```
unit(State, RobotState(0.0, 0.0, 0, WATER))
```

Теперь мы можем выстроить очень наглядную цепочку:

```
x = unit(State, RobotState(0.0, 0.0, 0, WATER)) >> move(100) >> turn(-90) >> 
                set_state(SOAP) >> start >> move(50) >> stop
```

Причём она не будет выполнена сразу -- в x хранится лишь функция, которую надо вызвать на выполнение с параметром-монадой (стартовым элементом нашего лога):

```
x(List(''))
```

Возвращено будет как финальное рассчитанное значение:

```
RobotState(x=100.0, y=-50.0, angle=-90, state=2)
```

так и наш лог:

```
['', 'POS(100,0)', 'ANGLE -90', 'STATE 2', 'START', 'POS(100,-50)', 'STOP']
```


### 13. Архитектура на монадах состояний

**Плюсы.**

Мы полностью избавились от мутабельности! Нигде в коде мы явно не храним промежуточные результаты, а только осуществляем над ними вычисления.

Мы получили очень наглядный синтаксис организации вычислений.

В дополнение к основным расчётам мы получаем мощный механизм выполнения всяческих дополнительных вычислений. Например, мы вполне могли заменить тип входного значения на лог, а RobotState превратить в монаду-стейт.

Ещё один сильнейший бонус -- возможность компоновки наших отложенных вычислений. Например, вполне можно записать так:

```
x = unit(State, RobotState(0.0, 0.0, 0, WATER)) >> move(100) >> turn(-90)
y = x >> set_state(SOAP) >> start >> move(50) >> stop
y(List(''))
```

**Минусы.**

Мы по-прежнему завязаны на конкретные имплементации функций move, turn, ...

Комбинирование отложенных вычислений тяжело отлаживать, а в целом код получается более сложным и требует определённого понимания монад :)


### В заключение

Я надеюсь, что данный курс, перечень стилей и архитектур, будет со временем расширяться и дополняться, и вы сможете познакомиться с наиболее сильными идеями в этой важнейшей области ИТ-разработки.

Далее, из модных тем порекомендую, во-первых,
[**"Когда монолитные архитектуры лучше микросервисных"**](https://vk.com/wall-152484379_1537) -- разбираемся с монолитной и микросервисной архитектурами, их плюсами и минусами.

Во-вторых,
[**"Про архитектуры будущего"**](https://vk.com/@lambda_brain-the-future-of-computing) (важно!)

В-третьих,
[**за асинхронными архитектурами будущее**](https://vk.com/wall-152484379_704), это доказано математически

В четвёртых, разбираемся,
[**что такое безсерверность/serverless**](https://vk.com/wall-152484379_227)
