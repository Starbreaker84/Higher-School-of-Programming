## Разработка, управляемая тестированием

У меня неоднозначное отношение к методике  **TDD (разработка, управляемая тестированием) и к модульному тестированию** : я их и люблю, и ненавижу.

Я бывал и очень горячим сторонником этих "best practices", но я также периодически воспринимал их более чем скептически – в зависимости от проекта.

Одна из больших проблем в разработке – это когда сеньоры или менеджеры принуждают к применению "лучших практик" просто потому, что так принято, не понимая истинной причины их пользы или фактически не умея применять правильно. Ну, вроде как пытаться вкрутить винт крестообразной отвёрткой.

В одном проектов, который я консультировал, насчитывалось огромное количество юнит-тестов – несколько тысяч.

Ну, вообще это хороший знак.

Вероятно, это означает, что разработчики реализовали в проекте и другие лучшие практики, и в коде будет некое подобие целостной логической структуры или осмысленной архитектуры.

Я порадовался такому моменту, так как это означало, что моя работа в качестве ментора/консультанта в команде будет проще. У нас уже были модульные тесты, и всё, что мне нужно было сделать первым шагом -- это заставить новую команду продолжать как следует поддерживать их и начать писать новые тесты по новым тикетам.

Я получил доступ к проекту, запустил все тесты, они поработали несколько минут и, к моему удивлению, всё закончились успехом. Они все прошли.

Несколько тысяч юнит-тестов, и все они прошли успешно?

Зачем тогда меня вообще позвали?

Поймите меня правильно.  **Версия проекта, выкатываемая в продакшен, в промышленную эксплуатацию, должна конечно проходить все связанные с ней тесты** .

Но пока ведётся разработка, пресловутый «спринт», существенная часть кода находится в отлаживаемом состоянии, и практически всегда находится куча неудачных тестов, если вообще они имеются в проекте.

Я решил проверить один тест случайным образом.

Это был далеко не идеально сделанный тест, но я смог разобраться, что он делает.

Но потом я заметил кое-что...

В нём не было ни одного assert-а.

Фактически в тесте ничего не тестировалось.

В тесте были шаги, и эти шаги были выполнены, и он что-то выводил на экран, но никаких проверок правильности в нём не было.

"Тест" ничего не проверял.

Я открыл другой тест.

Ещё хуже.

Assert, который что-то проверял, был закомментирован.

Вот вам отличный способ сделать так, чтобы ваш код проходил тест: просто закомментируйте код, который делает этот тест неудачным.

Я начал проверять другие тесты, один за другим.

Ни один из них ничего не проверял.

Тысячи тестов, и все они были бесполезны.

Есть огромная разница между написанием юнит-тестов и пониманием принципов модульного тестирования и разработкой, управляемой тестированием.

### Что же такое модульное тестирование?

**Основная идея модульного (юнит-) тестирования заключается в написании тестов, каждый из которых проверяет наименьшую "единицу" кода (юнит)** .

Юнит-тесты, как правило, пишутся на том же языке программирования, что и исходный код самого приложения, и для непосредственной проверки этого рабочего кода.

Считайте юнит-тесты кодом, который проверяет другой код.

Когда я использую здесь слово "тест", я использую его довольно либерально, потому что юнит-тесты на самом деле не являются тестами в понимании классической парадигмы тестирования:  **они ничего не тестируют** .

Ну, я имею в виду, что когда вы запускаете юнит-тесты, вы обычно не обнаруживаете, что какой-то код не работает.

Да, код может измениться позже, и этот тест может дать сбой, поэтому в этом смысле юнит-тест -- это регрессионный тест. В целом, однако, юнит-тест не похож на обычный тест, где вы проверяете, правильно ли ведет себя программа.

Когда вы пишете юнит-тест, вы обычно постоянно модифицируете код до тех пор, пока юнит-тест не пройдёт полностью.

Вы не можете быть уверены, что юнит-тест пройдёт, когда вы его пишете.

Если думать о проекте таким образом (очень правильным, отмечу), то получается, что  **юнит-тестирование -- это скорее задание абсолютных требований к конкретным единицам кода на очень низком уровне** .

Юнит-тест можно и нужно рассматривать как почти абсолютную, почти формальную  **спецификацию** .

Юнит-тест указывает на то, что при таких-то условиях с таким-то конкретным набором входных данных, будет получен точно такой-то результат, который разработчик ожидает получить из тестируемой единицы кода.

**Юнит-тестирование проверяет наименьшую возможную единицу кода в проекте** , которой в большинстве языков программирования будет либо класс, либо модуль, либо функция.

**Если у вас есть опыт тестирования, вы закономерно можете уточнить, а не путаю ли я модульное и регрессионное тестирование?**

Точно.  **Ваши юнит-тесты должны, в частности, быть регрессионными** .

Одна из главных причин написания юнит-тестов, помимо уточнения, что именно должен делать код (которого часто в такой момент ещё нету) -- и быстрого его выявления, когда он не делает то что должен – это уверенность в том, что код продолжает стабильно делать то, что он должен делать и делал и раньше.

По сути,  **юнит-тесты превращаются в регрессионные тесты, которые позволяют убедиться, что новые изменения в коде не нарушают существующей функциональности** .
Думайте о юнит-тестах, как о тех маленьких подпорках, которые вы видите около молодых деревьев, которые помогают им расти прямыми и высокими.

То, что вы посадили дерево прямо в землю, ещё совсем не означает, что оно не согнётся со временем, или не станет совсем кривым.

То же самое и с вашим кодом.

Юнит-тесты могут сначала сообщить вам, что ваш код успешно посажен прямо в землю, а затем помогут вам сохранить его таким же прочным и прямым, даже если какой-нибудь джуниор организует проливной дождь на ваш хрупкий код.

### Что ещё называют модульным тестированием?

Часто юнит-тестирование путают с интеграционным тестированием.

Некоторые "юнит-тесты" проверяют более чем один класс или тестируют более крупные семантические единицы кода.

Многие разработчики будут утверждать, что это всё равно юнит-тесты, так как они проверяют код на низком уровне.

С этими людьми спорить не стоит.

Просто знайте, что это уже действительно будут интеграционные тесты, и что настоящие юнит-тесты проверяют по отдельности самую маленькую единицу кода.

Другая вещь, которую часто называют юнит-тестированием, но на самом деле это вообще не пойми что -- это написание юнит-тестов, которые не содержат проверок assert. Другими словами, это юнит-тесты, которые на самом деле ничего не тестируют.

Любой тест, юнит-тест или какой-то другой, обязательно должен иметь какую-то проверку - мы называем это assertion - которая определяет, пройдет тест или нет.

Тест, который всегда проходит, бесполезен.

Тест, который всегда проваливается, бесполезен.

### Важность модульного тестирования

Я довольно сильно зациклен на тестировании, и уделяю этому большое внимание на многих моих курсах, как вы наверняка заметили.

Что плохого в том, чтобы называть юнит-тестирование "настоящим тестированием", а не тестировать самый маленький кусочек кода по отдельности?

Ну и что с того, что некоторые из тестов не содержат assert? Они, по крайней мере, исполняют код.

Ну, давайте, я попробую объяснить.

Есть два основных преимущества, или две главные причины, в пользу классических юнит-тестирования.

Первая -- это  **улучшение дизайна, стиля, качества вашего кода** .

Когда вы пишете качественные юнит-тесты, в которых заставляете себя изолировать, инкапсулировать каждую самую маленькую единицу кода, вы наверняка столкнётесь с проблемами при проектировании такого кода.

Вам может показаться чрезвычайно сложным сделать класс полностью изолированным и не включать в тесты его зависимости, и это заставит вас понять, что в вашем коде слишком много тесных связей.

Как этого избегать, я подробно объясняю на первом курсе по объектно-ориентированному проектированию (как правильно проектировать классы на основе абстрактных типов данных).

Вы можете также обнаружить, что основная функциональность, которую вы пытаетесь проверить, размазана между несколькими модулями, что поможет вам понять, что ваш код наоборот недостаточно связен.

Как этого избегать, я подробно объясняю на втором и третьем курсах по объектно-ориентированному проектированию.

Вы также можете внезапно обнаружить, что сидите перед чистым редактором, собираясь написать юнит-тест, и понимаете -- поверьте мне, такое случается -- что вы не знаете, что должен делать тестируемый код, поэтому вы не можете просто взять и написать для него юнит-тест.

И, конечно же, вы можете обнаружить реальную ошибку в реализации, поскольку модульный тест заставляет вас задуматься о некоторых граничных случаях и протестировать код на таких значениях, которые вы, возможно, не учли.

Делая юнит-тесты и строго придерживаясь принципа, что они проверяют простейшие единицы кода по отдельности, вы будете регулярно обнаруживать всевозможные проблемы с этим кодом и структурой этих проектных единиц.

По этой причине в жизненном цикле разработки программного обеспечения модульное тестирование является не столько классическим тестированием, сколько, немного парадоксально, скорее оценочной/аттестационной деятельностью.

Вторая основная цель модульного тестирования --  **создание автоматизированного набора регрессионных тестов, которые будут выступать как спецификация низкоуровневого поведения вашего проекта** .

Что это означает?

Когда вы рефакторите или улучшаете говнокод, вы не можете его сломать, потому что это говнокод :)

Юнит-тесты -- это также тесты: регрессионные тесты.

Но цель юнит-тестирования -- не просто подготовить регрессионные тесты.

На практике юнит-тесты ловят весьма мало «регрессий» (поломок того, что раньше нормально работало), так как изменение модуля кода, который вы тестируете, почти всегда сопряжено с изменением самого юнит-теста.

На более высоком уровне регрессионное тестирование само по себе намного эффективнее, так как внутренняя структура кода может быть изменена, а поведение внешних элементов останется прежним.

Но  **юнит-тесты проверяют именно внутреннюю структуру, реализацию** , поэтому при изменении этой структуры юнит-тесты не то что "не проходят", а естественным образом становятся недействительными и должны быть изменены, удалены или переписаны.

Ну вот -- теперь вы знаете об истинном назначении юнит-тестирования больше, чем большинство ветеранов с 10-летним опытом разработки.

### Что такое разработка, управляемая тестированием (TDD)?

В отдельном занятии мы обсуждаем методологии разработки программного обеспечения, и есть в частности такая, ранее очень популярная, методология водопада, которая сегодня часто практически не срабатывает, потому что у нас почти никогда не бывает полных спецификаций (полноценного технического задания по проекту) заранее.

**TDD -- это идея, что перед тем, как писать какой-либо код, вы пишете тест, который используется как спецификация того, что именно должен делать этот код** .

Это чрезвычайно мощная концепция в разработке софта, но, как и многие другие, она часто используется не по назначению.

Обычно TDD подразумевает юнит-тесты для создания кода, хотя его можно применять на любом уровне тестирования.

В данном занятии мы рассмотрим наиболее распространенный вариант TDD -- через юнит-тестирование.

TDD полностью переворачивает классический подход: вместо того, чтобы сначала писать код, а затем делать юнит-тесты для проверки этого кода (что, как мы знаем, всё равно так не работает), вы сначала пишете юнит-тест (по сути, спецификацию для того, что ещё не существует), а затем – сам код, обеспечивающий успешное выполнение этого теста.

Таким образом,  **юнит-тест напрямую "управляет" разработкой кода** .

Такой процесс повторяется снова и снова.

Вы пишете ещё один тест, который задаёт большую функциональность кода.

Вы изменяете существующий код или добавляете новый код, чтобы тест прошёл.

Наконец, вы рефакторите код -- вычищаете его до мелочей, чтобы сделать его более лаконичным и выразительным.

Эта схема часто называется  **"красный, зеленый, рефакторинг"** , потому что сначала юнит-тест проваливается (красный) – ведь код для него ещё не существует; затем пишется код, чтобы тест прошёл (зеленый); и, наконец, код улучшается и оптимизируется (рефакторинг).

### В чём фишка TDD?

Точно так же, как юнит-тестирование само по себе может быть отличной практикой, которая применяется неправильно, так и TDD может быть применяем неправильно.

Очень легко назвать то, что вы делаете, TDD, и даже следовать практике "красный, зеленый, рефакторинг"-- и при этом не понимать, зачем вы это всё делаете, или какую пользу это даёт.

Самая большая ценность TDD заключается в том, что  **тесты сами по себе выступают как отличные спецификации** .

Сама по себе TDD -- это, по сути, практика написания однозначных, почти формальных спецификаций, которые работают автоматически.

Почему тесты выступают в роли таких строгих спецификаций?

Потому что они не врут.

Они не заявляют, что код должен работать таким-то способом, а потом, спустя две недели, говорят, что на самом деле он должен работать совсем по-другому, и "это все сделано неправильно, это совсем не то, что я вам сказал".

Тесты, если они написаны корректно, либо выполняются успешно, либо терпят неудачу.
В тестах точно указывается, что именно должно работать при определенных обстоятельствах, в определённом состоянии.

Таким образом, можно сказать, что  **цель TDD состоит в том, чтобы убедиться, что мы полностью понимаем, а что мы вообще делаем, прежде чем мы это реализуем -- и что в итоге мы получим «то, что надо»** .

Если же вы садитесь за компьютер, чтобы начать работать по TDD, и при этом не можете понять, что же должен проверять ваш тест, это означает, что вам нужно пойти к старшему и позадавать ему побольше вопросов.

**Другая ценность TDD состоит в том, что он сохраняет код в компактном виде** .

Вообще, поддержка, сопровождение кодовой базы всегда обходится недёшево.

Как известно, лучший программист -- это тот, кто пишет минимальный объём кода, или даже находит способ удалять код, сокращать объём проекта, потому что такой программист нашел самый верный способ уменьшить количество ошибок и снизить стоимость обслуживания системы.

Когда вы используете TDD, то будете абсолютно уверены, что не напишете код, который не нужен -- так как  **вы будете писать код только для того, чтобы пройти тесты** .

В разработке программного обеспечения существует принцип, называемый YAGNI:  **вам это не понадобится** , не добавляйте в проект дополнительные сущности, дополнительную логику без явной необходимости.

TDD делает принцип YAGNI ненужным.

### Типичный процесс работы по TDD

Понять TDD теоретически может быть немного сложно, поэтому давайте рассмотрим, как может выглядеть типовая сессия TDD.

Вы берёте в руки блокнот и быстро делаете наброски того, что, по вашему мнению, будет представлять собой высокоуровневая структура логики, добавляющей в игру котиков.

В проекте имеется абстрактный класс SimpleNPC – наследник базового абстрактного класса NPC (компьютерный персонаж), который вводит новую «дизайнерскую» сущность, которая не оказывает никакого влияния на игровой процесс, но может активно перемещаться по локации, просто добавляя игре визуальное веселье.

Вы решили, что создадите класс Cat – наследник от SimpleNPC, и реализуете в нём нужные методы, связанные с отрисовкой котика на экране, и с манерой его передвижения по локации.

Вы открываете любимый редактор и создаёте юнит-тест под названием "в игру добавлен первый кот".

Вы пишете код юнит-теста для создания экземпляра класса Cat (сам класс вы ещё не создали).

Затем пишете тестовый код для вызова метода класса Cat, который задаёт котику целевую точку (0,0).

Наконец, вы пишете assert, который проверяет, что у кота действительно задана целевая точка (0,0).

Вы пытаетесь запустить тест, но он даже не компилируется, так как у вас нет класса Cat.

Вы исправляете эту ситуацию, создаёте класс Cat вместе с переопределёнными родительскими методами: задания целевой точки и получения этой целевой точки.

Вы оставляете функциональность в этих методах полностью пустыми или добавляете вызов исключения, если метод должен что-то возвращать.

Вы запускаете тест, и на этот раз он компилируется, однако сразу завершается неудачей.

Теперь наконец вы реализуете нужный функционал, достаточный для прохождения теста.

В этом случае это будет означать, что коту корректно задана целевая точка (0,0).

Или, например, если координаты на карте задаются, начиная от 1, такой метод вернёт false или иное другое сообщение об ошибке, что вы, соответственно, проверяете.

Вы запускаете тест снова, и он проходит.

Теперь вы переходите к следующему тесту.

На этот раз вы решили написать тест под названием "Котику задана целевая точка, когда у него уже есть ранее заданная целевая точка".

В зависимости от того, как подразумевает техническое задание, например если целевая точка уже задана, менять её не разрешается, и в таком случае метод должен вернуть, например, false.

Вы пишете модульный тест, который создает экземпляр класса Cat, задаёте коту целевую точку, проверяете, что она сформировалась корректно, и после этого пытаетесь сменить её на новую цель, проверяя, что метод смены цели вернёт false.

Вы запускаете этот новый тест, и, конечно же, он не работает, потому что пока метод задания целевой точки класса Cat всегда меняет целевую точку, не проверяя, была ли она задана ранее.

Вы возвращаетесь к своему классу Cat и реализуете некоторый код для проверки такой ситуации.

Вы решаете, например, хранить в поле Target (целевая точка) значение null, если цель ещё не задана, или была успешно достигнута (и проверку, что когда цель действительно была достигнута, Target корректно сбрасывается в null, потребуется дополнительно выполнять в отдельном тесте).

Вы вносите это изменение, запускаете оба теста, и они оба проходят.

Теперь вы смотрите на код, который вы создали, и думаете, что тут можно отрефакторить, чтобы сделать его более простым.

Очевидная потенциальная проблема, о которой я постоянно говорю – это использование null, чего надо всячески избегать.

В данном случае, для примера, в реализации Cat, когда было выполнено задание целевой точки, генерируется путь к цели – список точек, который сокращается по мере движения котика по этим точкам. В таком случае гораздо лучше удалить поле Target, и проверять только длину списка точек. Когда он пустой, можно задавать новую цель.

Итак, вы продолжаете создавать новые тесты, пишете достаточно кода, чтобы заставить их успешно выполняться, а затем рефакторите написанный код до тех пор, пока закончатся все тестовые случаи, которые вы только сможете придумать для функциональности, которую вы пытаетесь реализовать.

### Но это были только самые элементарные основы TDD

Итак, вы познакомились с основами TDD и юнит-тестирования, но это только самые основы.

TDD станет сложнее, когда вы действительно будете пытатьсь изолировать базовые единицы кода, потому что код в системе всегда как-то «соединён».

**Очень мало классов существуют в полной изоляции.**

У большинства из них имеются зависимости от других классов, а у этих зависимостей есть свои зависимости, и так далее.

Для работы с подобными ситуациями ветераны TDD используют так называемые «моки», «пустышки» ( **mocks** ), которые могут помочь вам изолировать отдельные классы, имитируя функциональность зависимостей предустановленными значениями.

Мы не будем останавливаться на «пустышках» и других техниках TDD, просто учтите, что то, что я представил в этом занятии, несколько упрощено.

Идея была в том, чтобы дать вам базовые понятия и принципы, лежащие в основе TDD и юнит-тестирования, которые, надеюсь, у вас теперь есть.

Я большой поклонник TDD, считаю её лучшим на сегодня методом не только тестирования, но и разработки (так как тесты выступают как строгие спецификации), и рекомендую изучить классическую книгу  **«Экстремальное программирование. Разработка через тестирование TDD» Кента Бека** .

### Надо ли писать тесты для старого кода, для которого ранее тесты никто не делал?

Ну... может быть.

Это вопрос на миллион долларов.

**Вы честно должны спросить себя, зачем вы это делаете.**

Вы делаете это потому, что тесты помогут вам чувствовать себя психологически хорошо, тепло и пушисто, когда вы наделаете кучу юнит-тестов и покроете весь ваш код?

Или... вы делаете это потому, что считаете, что создание этих юнит-тестов, скорее всего, поможет вам лучше понять свой код, добавит ему ясных спецификаций, сделает его более устойчивым к грядущей туче изменений, которые вы собираетесь в него внести, или же по каким-то другим действительно не менее веским причинам.

Не создавайте юнит-тесты просто потому, что вы где-то услышали или вычитали, что "это лучшая практика" или потому, что "весь код должен быть покрыт юнит-тесты".

**Постарайтесь хотя бы немного быть прагматичным** и сформулировать реальную причину, зачем вам возвращаться назад и создавать юнит-тесты.

### Имеет ли смысл писать юнит-тесты, не используя TDD?

Периодически мне задают такой вопрос, и мне кажется, что меня просто пытаются разозлить :) но это не сработает.

Я не заглочу наживку.

Но я скажу вот что:

Если вы вдумчиво прочитали это занятие и согласны с тем, что я пояснял по назначению юнит-тестов, то вы должны честно задаться вопросом, не будут ли цели этих тестов серьёзно нарушены, если вы вернетесь к их написанию уже после того, как сам код будет написан?

Да, в некоторых случаях такие тесты будут всё ещё актуальны -- в качестве регрессионных тестов, но действительно ли это разумное использование вашего времени?

Не будет ли гораздо мудрее использовать ваше время стратегически -- так, чтобы изучить и внедрить подход TDD?

Я не хочу, чтобы это выглядело так, будто я даю вам наводящие вопросы, потому что вы должны действительно ответить на эти вопросы -- сами и максимально честно.

Я встречал немало случаев, когда и TDD, и модульное тестирование имели большой смысл.

Я также встречал случаи, когда ни то, ни другое не имело никакого смысла.

И я также встречал случаи, когда TDD не имело смысла, но создание некоторых модульных тестов для уже существующего кода имело смысл.

Просто не делайте каких-то вещей только потому, что "вы должны их делать"; всегда будьте прагматиком.

Понятно?

Хорошо.

**Задание**

Потренируйтесь в TDD при создании проекта или какой-то его части объёмом хотя бы в тысячу строк, и расскажите свои впечатления.
