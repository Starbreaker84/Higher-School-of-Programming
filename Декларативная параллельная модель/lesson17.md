### Синхронизация

Нити могут взаимодействовать через общие dataflow-переменные. Когда нити нужен результат вычисления, выполненного другой
нитью, то она просто ждет, когда этот результат станет доступен. Говорят, что  **нить синхронизируется по доступности
результата** . Синхронизация -- это одна из самых фундаментальных концепций в параллельном программировании. Для её
более полного понимания введём базовую концепцию  **"точка синхронизации"** .

Пусть имеются две нити T1 и T2. Первая выполняет шаги вычислений a0 - a1 - a2 - a3 - ..., и вторая -- шаги b0 - b1 - b2
- b3 - ... При их конкретном выполнении будет, очевидно, только одна глобальная последовательность, которая содержит
шаги каждого потока, однако существует множество способов, которыми два этих потока вычислений могут чередоваться.

В тоже время не все эти варианты могут случаться на практике.

1) Исполнительная система считается глобально справедливой в том смысле, что не может возникать потенциально бесконечной
   последовательности шагов одной нити, не перемежающейся шагами других нитей.
2) Если нити каким-то образом зависят от результатов друг друга, то возникают дополнительные ограничения, называемые
   точками синхронизации. Точка синхронизации связывает два вычислительных шага a(i) и b(j). Говорят, что b(j)
   синхронизируется с a(i), если при любых вариантах чередования, которые могут случаться в реальном вычислении, b(j)
   всегда происходит после a(i).

Синхронизация -- это локальное свойство системы, которое поддерживается операциями, выполняющимися непосредственно
внутри нитей, а не каким-то внешним по отношению к нитям механизмом.

### Синхронизация

Есть два основных подхода к реализации синхронизации.

1) **Неявная синхронизация** . При таком подходе операции синхронизации не записываются явно в тексте программы; они --
   часть операционной семантики языка. Например, использование dataflow-переменной автоматически выполняет синхронизацию
   по привязке к значению.
2) **Явная синхронизация** . В этом случае программист явно записывает операции синхронизации в тексте программы.
   Например, при реализации схемы поставщик/потребитель, управляемой по запросу, используется триггер.

Есть также две схемы синхронизации как таковой:

- **Синхронизация, управляемая доставкой** / Supply-driven synchronization (жадное выполнение). При попытке выполнить
  операцию система будет ждать, когда все её аргументы будут доступны. Другими словами, операция синхронизируется по
  доступности аргументов. Ожидание само по себе никак не влияет на вычисление аргументов; пока какая-то другая нить не
  вычислит их, операция будет ждать неопределенное время.
- **Синхронизация по запросу** (ленивое выполнение). Попытка выполнить операцию вызывает непосредственное вычисление её
  аргументов. Другими словами, вычисление аргументов синхронизируется с операцией, в них нуждающейся.

Возможно, может показаться, что тут перепутаны ленивое и жадное вычисления? Нет, разница в том, что в случае жадного
выполнения фактически подразумеваются dataflow-переменные: нить просто останавливается на соответствующей операции и
ждёт их связывания. В случае же ленивого вычисления dataflow-переменных нету: аргументы вычисляются непосредственно, но
только тогда, когда в соответствующей операции (например, функции) к ним случится прямое обращение (возможно, никогда).
Но это случаи, когда соответствующие механики реализованы внутри языка, неявно, на уровне его семантики.

В явном же случае синхронизация, управляемая доставкой подразумевает использование в программе различных блокировщиков,
мониторов и т. п. А в случае синхронизации по запросу -- триггеры например. Оба этих подхода поддерживаются в Java, C#,
C++... А неявные схемы -- в языках наподобие Haskell (ленивые вычисления) или Prolog (dataflow-выполнение).

### Синхронизация

Van Roy отмечает, что системы параллельного программирования проще разрабатывать, когда в языке поддерживается неявная
синхронизация. В частности, проще всего строится работа с dataflow-вычислениями, только к сожалению она много лет
практически не поддерживалась в массовых языках программирования. Существовали неплохие самодельные расширения, которые
достаточно очевидно реализуются:
например, [dataflow-тип данных в C#](https://www.codeproject.com/Articles/107121/Basics-of-Dataflow-Programming-in-F-and-C)
, который по аналогии достаточно легко реализовать и в Java например. Потому что даже в модели с явным состоянием
дополнительная поддержка dataflow-выполнения становится несомненным преимуществом.

Профессор Henri Elle Bal сотоварищи из Vrije Universiteit Amsterdam провёл сравнение языков с явной и неявной
синхронизацией, и пришёл к такому же выводу: dataflow-переменные "впечатляюще выразительны" в параллельном
программировании по сравнению с явной синхронизацией, даже в модели без явного состояния.

P.S. На платформе .NET появилась весьма хорошая реализация dataflow-парадигмы в параллельных
вычислениях: [TPL Dataflow Library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library)

### 17. Исключения и каналы сообщений

======= 48. Исключительная ситуация свидетельствует о ... (выберите неверное утверждение)

[ 1] неявном недетерминизме

[ ] выполнении вне спецификации

[ ] явном недетерминизме

[ ] недекларативной работе

======= 49. Выберите неверное утверждение

[ ] связывание переменной соответствует асинхронной отправке сообщения

[ 1] связывание переменной соответствует синхронной отправке сообщения

[ ] ожидание связывания соответствует синхронному приёму

[ ] ожидание связывания соответствует асинхронному приёму

======= 50. Выберите неверное утверждение

[ 1] синхронный приём сообщения означает использование переменной до связывания

[ ] асинхронный приём сообщения означает использование переменной до связывания

[ ] асинхронная отправка сообщения означает явное ожидание связывания

[ ] синхронная отправка сообщения означает явное ожидание связывания
