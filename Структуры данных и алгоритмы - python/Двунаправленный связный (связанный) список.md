## 2. Двунаправленный связный (связанный) список

Обычный список мы можем проходить только в одну сторону, от головы к хвосту, но имеется немало задач, когда желательно оставаться в рамках модели связанного списка, но бегать по нему в обе стороны. Некоторые операции в результате становятся ещё более эффективными (например, удаление узла), однако приходится выделять дополнительную "ячейку" памяти под второй указатель.

Общая схема работы двунаправленного связанного списка (класс LinkedList2) сохраняется как в прошлом уроке.

Концепция узла расширяется полем prev, который теперь указывает на предыдущий элемент в списке.

```
class Node:
    def __init__(self, v):
        self.value = v
        self.prev = None
        self.next = None

n1 = Node(12)
n2 = Node(55)
n1.next = n2 # 12 -> 55
n2.prev = n1
```

Немного изменить нам потребуется лишь метод add_in_tail():

```
class LinkedList2:  
    def __init__(self):
        self.head = None
        self.tail = None

    def add_in_tail(self, item):
        if self.head is None:
            self.head = item
            item.prev = None
            item.next = None
        else:
            self.tail.next = item
            item.prev = self.tail
        self.tail = item
```

[[ предыдущее занятие ]](https://skillsmart.ru/algo/py-kf32y/fb50h6802e1s.html)

**Задания.**
2.1. Добавьте в класс LinkedList2 метод поиска первого узла по его значению.

```
find(val)
```

2.2. Добавьте в класс LinkedList2 метод поиска всех узлов по конкретному значению (возвращается список найденных узлов).

```
find_all(val)
```

2.3. Добавьте в класс LinkedList2 метод удаления одного узла по его значению.

```
delete(val, all=False)
```

где флажок all=False по умолчанию -- удаляем только первый нашедшийся элемент.

2.4. Дополните этот метод удалением всех узлов по конкретному значению (флажок all=True).

2.5. Добавьте в класс LinkedList2 метод вставки узла после заданного узла.

```
insert(afterNode, newNode)
```

Если afterNode = None и список пустой, добавьте новый элемент первым в списке.
Если afterNode = None и список непустой, добавьте новый элемент последним в списке.

2.6. Добавьте в класс LinkedList2 метод вставки узла самым первым элементом.

```
add_in_head(newNode)
```

2.7. Добавьте в класс LinkedList2 метод очистки всего содержимого (создание пустого списка) -- clean()

2.8. Добавьте в класс LinkedList2 метод вычисления текущей длины списка -- len()

2.9. Напишите проверочные тесты для каждого из предыдущих заданий.

* 2.10. Существует интересный финт, обсуждаемый на курсе Стэнфордского университета CS106B --  **фиктивный/пустой (dummy) узел** . Пока нам при любых модификациях списка (добавление/удаление узла) приходится рассматривать три отдельные ситуации: работа с серединой списка, с его головой и с его хвостом. Фиктивный узел позволяет избавиться от этих краевых ситуаций, оставив только по одной универсальной операции на добавление и удаление. Идея в том, что мы добавляем в список два искусственных узла -- голову и хвост, которые пользователю класса не видны (они отличаются от видимых узлов, например, булевым флажком, а лучше всего это делать через наследование и перегрузку). Теперь, добавляя или удаляя узлы, мы всегда будем уверены, что у каждого из них имеется и предыдущий узел, и последующий, и от дополнительных проверок и модификаций полей head и tail можно избавиться.
  В реализации для тестов на сервере такую схему применять не надо, сделайте отдельную реализацию, бонус до +500.

**[предыдущее](https://skillsmart.ru/algo/py-kf32y/fb50h6802e1s.html)**

---

## заготовка класса для автоматической проверки

```
class Node:
    def __init__(self, v):
        self.value = v
        self.prev = None
        self.next = None

class LinkedList2:  
    def __init__(self):
        self.head = None
        self.tail = None

    def add_in_tail(self, item):
        if self.head is None:
            self.head = item
            item.prev = None
            item.next = None
        else:
            self.tail.next = item
            item.prev = self.tail
        self.tail = item

    def find(self, val):
        return None # здесь будет ваш код

    def find_all(self, val):
        return [] # здесь будет ваш код

    def delete(self, val, all=False):
        pass # здесь будет ваш код

    def clean(self):
        pass # здесь будет ваш код

    def len(self):
        return 0 # здесь будет ваш код

    def insert(self, afterNode, newNode):
        pass # здесь будет ваш код

    def add_in_head(self, newNode):
        pass # здесь будет ваш код   
```
