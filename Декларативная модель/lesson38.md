## Программирование, управляемое данными (Data-driven)

Частой и даже универсальной задачей считается выполнение некоторой операции над структурой данных (на практике достаточно большой), итерация или обход этой структуры и вычисление некоторой другой структуры данных на основе такого обхода.
Эта схема чаще всего применяется к спискам и деревьям. Для списков обычно применяются операции FoldR и FoldL, есть и другие типовые техники.

Классическая универсальная операция над списками – это  **Map, которая вычисляет новый список такого же размера, как и исходный, применяя заданную функцию к каждому его элементу** . Реализация Map имеется практически во всех популярных языках программирования, в Julia например она называется map().

Допустим, мы хотим округлить с помощью функции round() все значения в списке:

```
map(round, [1.2, 3.5, 1.7]) # [1.0, 4.0, 2.0]
```


### 37. Map/Filter/Reduce

Реализация Map с помощью программирования высшего порядка может быть, например, такой:

```
function Map(Ls, F)

  function IterMap(Rs, Ys, F)
    if Ys == []
        return Rs
    end

    head = Ys[1]
    tail = Ys[2:end]
    return IterMap(push!(Rs,F(head)), tail, F)
  end

  return IterMap([], Ls, F)
end

function Square(x)
    return x*x
end

Map([1,5,3,7,9], Square) # [1, 25, 9, 49, 81]
```


### 38. Filter

Другая универсальная операция над списками – это  **Filter, которая формирует новый список, в который включаются только те элементы исходного списка, которые соответствуют некоторому предикату** . В Julia она называется filter().

Например, мы хотим выделить из исходного списка [1,2,3,4,5,6,7] только нечётные элементы; стандартная функция-предикат isodd() возвращает true, если её аргумент нечётный.

```
filter(isodd, [1,2,3,4,5,6,7]) # [1, 3, 5, 7]
```

Наша релизация Filter() может быть такой:

```
function Filter(Ls, F)

  function IterFilter(Rs, Ys, F)
    if Ys == []
        return Rs
    end

    head = Ys[1]
    tail = Ys[2:end]
    if F(head)
       return IterFilter(push!(Rs,head), tail, F)
    else
       return IterFilter(Rs, tail, F)
    end
  end

  return IterFilter([], Ls, F)
end

Filter([1,2,3,4,5,6,7], isodd) # [1, 3, 5, 7]
```


### 39. Fold/Reduce

Как уже отмечалось, FoldR и FoldL (свёртка folding в мэйнстриме часто называется reduce) работают как цикл for с аккумулятором, однако мы можем выразить его через универсальный итератор Iterate, который мы изучали ранее:

```
function Iterate(S, IsDone, Transform)
  if IsDone(S)
     return S
  end 

  S = Transform(S)
  return Iterate(S, IsDone, Transform) 
end

function is_done(Ls)
  return length(Ls) == 1
end

function transform(Ls)
  S1 = [Ls[1] * Ls[2]; Ls[3:end]] 
  return S1 
end

function FoldL(Ls, F, U)
    if Ls == []
       return []
    end
    if is_done(Ls)
       return Ls[1]
    end

    return Iterate(Ls, is_done, F)
end

println(FoldL([1,5,3,7,9], transform, 1))
```

На самом деле, Iterate -- это универсальная абстракция while-цикла с аккумулятором. Все абстракции цикла могут быть выражены через этот итератор.


### Программирование, управляемое данными (задания)

======= 77. Map -- это ...

[ ]вычисление новой структуры, в которую включены только те элементы, для которых предикат истинен

[x]вычисление новой структуры исходного размера с применением заданной функции к каждому элементу

[ ]свёртка-абстракция for/while-цикла с аккумулятором

======= 78. Filter -- это ...

[ ]вычисление новой структуры исходного размера с применением заданной функции к каждому элементу

[x]вычисление новой структуры, в которую включены только те элементы, для которых предикат истинен

[ ]свёртка-абстракция for/while-цикла с аккумулятором

======= 79. Fold/Reduce -- это ...

[x]свёртка-абстракция for/while-цикла с аккумулятором

[ ]вычисление новой структуры исходного размера с применением заданной функции к каждому элементу

[ ]вычисление новой структуры, в которую включены только те элементы, для которых предикат истинен
