## Причинно-следственная связь и конкурентный доступ

Проблема 56. Как вообще определить, конкурентны ли две операции?

Решение. Принимаем, что операция A происходит до другой операции B, если операции B известно про операцию A, или B зависит от или основана на A каким-либо образом.

**Совершение одной операции независимо от другой -- ключ к формализации понятия конкурентности** .

Фактически мы можем просто сказать: две операции конкурентны, если ни одна из них не происходит до другой в том смысле, что ни одна не знает про другую. Следовательно, для двух операций A и B есть три возможности: или A происходит до B, или B происходит до A, или A и B происходят конкурентно.

"До" или "после" имеются в виду не по физическому измерению времени, а по логической связи: на деле неважно, пересекаются ли они во времени, тем более, что проблемы с часами характерны для подавляющего количества распределенных систем, и реально довольно сложно определить, происходят ли два события фактически в одно и то же время (и что такое "фактически"? с точностью до погрешности? но тут тоже есть нюансы).

При определении конкурентного доступа физическое время неважно:  **две операции считаются конкурентными, если ни одна из них не знает о другой в логическом смысле** , независимо от физического порядка и физического времени их выполнения.


## Причинно-следственная связь и конкурентный доступ

Проблема 57. Что формально понимается под "происходит до"? Что значит, что операция "знает" о другой операции?

Решение. Одно из классических решений -- использовать номера версий значений (или какую-то иную мета-информацию), что удобно в том плане, что серверу не требуется интерпретировать сами значения, так что они могут представлять собой произвольные структуры данных.

Сервер хранит номера версий значений для всех ключей, увеличивая номер версии всякий раз при выполнении записи значения для этого ключа, и сохраняет новый номер версии вместе с записанным значением. При чтении ключа клиентом сервер возвращает все неперезаписанные значения, а также последний номер версии. А получив информацию об операции записи с конкретным номером версии, сервер может перезаписать все значения с этим или более низким номером версии (они все слиты воедино в новом значении), но должен сохранить все значения с более высоким номером версии (поскольку они конкурентны данной входящей операции записи).


## Причинно-следственная связь и конкурентный доступ

Проблема 58. Вышеприведенный алгоритм гарантирует, что данные не будут незаметно отбрасываться, но при этом на клиенты ложится дополнительная нагрузка, так как надо объединить конкурентные значения.

Решение. В некоторых системах (например, Riak) такие конкурентные значения называются  **родственными значениями (siblings)** . Слияние родственных значений представляет собой, по сути, аналог обсуждавшейся ранее задачи разрешения конфликтов при репликации с несколькими ведущими узлами. Простейший способ, очевидно: выбрать одно из значений на основе номера версии или метки даты/времени ("выигрывает последний").


## Причинно-следственная связь и конкурентный доступ

Проблема 59. Однако подобный простейший способ означает потенциальную потерю данных. Например, пользователь может удалять товар из корзины заказов, и результат объединения может оказаться неожиданным: при объединении двух родственных корзин, в одной (только одной) из которых выполнялось удаление товара, этот удалённый товар снова появится в итоговом объединении.

Решение. Нельзя просто удалять товар из базы данных при удалении его из корзины заказов. Вместо этого система должна добавить в базу маркер с соответствующим номером версии в качестве указания на то, что товар был удален при слиянии родственных значений. Подобный маркер называется  **"отметка об удалении" (tombstone)** .

Слияние родственных значений -- задача сама по себе сложная и подверженная потенциальным ошибкам, поэтому на практике иногда создаются специальные структуры данных для поддержки безопасного автоматического слияния.


### Репликация без ведущего узла (задания)

======= 49. Что формально означает, что две операции A и B конкурентны?

[ ] A происходит до B, или B происходит до A

[] B известно про операцию A, или B зависит от или основана на A

[1] A и B совершаются независимо

======= 50. Как формально определить факт конкуретных операций?

[ 1] использовать номера версий значений

[ ] использовать физическое время в качестве мета-информации

======= 51. Как избежать дополнительной нагрузки на клиенты при объединении конкурентных значений?

[ ] это невозможно

[ ] применять метод "выигрывает первый" FWW

[1 ] применять метод "выигрывает последний" LWW
