## Журналы репликации

Ведущий узел записывает в журнал репликации каждый выполняемый запрос на запись, и периодически отправляет этот журнал ведомым узлам. Как правило, записываются операторы INSERT, UPDATE или DELETE ( **операторная репликация** ), которые каждый ведомый узел выполняет у себя, как если бы они были получены от клиента.

Проблема 18. Если в операторе SQL имеются недетерминированные функции (например, NOW для получения текущего времени, или RAND для генерации случайного числа), скорее всего, будут cгенерированы разные значения в каждой реплике.

Если операторы используют столбец с автоматически увеличиваемым значением, или зависят от существующих данных из базы (например, UPDATE … WHERE ), то они должны выполняться на всех репликах в строго одинаковом порядке, иначе их результаты будут различными. Но когда выполняется множество параллельных транзакций, такое вряд ли возможно.

Операторы с побочными действиями (например, триггеры, хранимые процедуры, пользовательские функции) также могут приводить к различным побочным действиям на разных репликах.

Решение. Подобная операторная репликация использовалась, например, в MySQL до версии 5.1, иногда применяется и сейчас в силу своей простоты, но по умолчанию MySQL переключается на построчную репликацию при малейших признаках недетерминизма в операторах SQL.
**Построчная репликация** реплицирует каждую вставляемую, удаляемую или обновляемую строку отдельно, с теми конкретными значениями, которые участвовали в операции.

## Журналы репликации

На предыдущем курсе мы изучали, как подсистемы хранения представляют данные на диске; напомню, что практически все записываемые данные журналируются (SS-таблицы, LSM-деревья), причём этот журнал представляет собой основное место хранения информации. Сегменты его сжимаются и подвергаются сборке мусора в фоновом режиме, а в случае B-дерева, работающего с отдельными блоками на диске, все изменения сначала записываются в журнал упреждающей записи, чтобы индекс в случае фатального сбоя можно было вернуть в согласованное состояние.

В любом случае журнал репликации представляет собой последовательность байтов, содержащую результаты всех операций записи в БД и предназначенную только для расширения (записанные в журнал данные менять нельзя). Ввиду этого журнал неплохо подходит для создания реплики, и ведущий узел отправляет его по сети ведомым.

## Журналы репликации

Проблема 19. Журнал описывает данные на очень низком уровне: он содержит все подробности того, какие байты менялись в тех или иных дисковых блоках, что завязывает репликацию на конкретную подсистемую хранения. Если СУБД меняет формат хранения при переходе к следующей версии, то её согласованная работа на ведущем и ведомых узлах становится невозможной.

Решение. Напрашивается использовать разные форматы журнала для репликации и для подсистемы хранения, чтобы сделать его независимым от конкретной машины. "Независимый" журнал для репликации называется  **логический журнал (logical log)** .

Логический журнал для реляционных БД -- простая последовательность строк в файле, описывающих операции записи на уровне строк таблицы. При вставке в журнале фиксируются новые значения всех столбцов.
При удалении в журнале фиксируется информация, достаточная для однозначной идентификации удаляемой строки. Как правило это первичный ключ, но если он отсутствует, то сохраняются старые всех столбцов.
При обновлении строки в таблице в журнале фиксируется информация, достаточная для однозначной идентификации этой строки и, по крайней мере новые значения всех изменившихся столбцов.

За счёт того, что логический журнал расцеплен с внутренним устройством подсистемы хранения, удаётся довольно легко поддерживать его обратную совместимость, и благодаря этому на ведущем и ведомых узлах могут работать различные версии СУБД и даже различные подсистемы хранения.

Формат логического журнала (по сути, классический текстовый лог) также удобен для синтаксического разбора внешними приложениями и последующего автономного анализа.

## Журналы репликации

Проблема 20. На практике нередки ситуации, когда требуется реплицировать только подмножество данных, или провести репликацию между СУБД разных марок, и штатными средствами не обойтись.

Решение. В таких случаях, а также в нетривиальных ситуациях, связанных с логическими конфликтами, пишут прикладной код, обрабатывающий подобную проектную специфику. Чаще всего используют готовые возможности СУБД: триггеры и хранимые процедуры.

Триггеры -- это скрипты (как правило, на SQL), автоматически запускающиеся при возникновении в БД события изменения данных (транзакция записи). Триггер может, например, занести изменения в отдельную таблицу, из которой их затем сможет прочитать внешний процесс, и соответственно обработать любым запрограммированным способом (например, реплицировать изменения в другую систему, опубликовать их через API и т. п.).
Ресурсов для триггерной репликации обычно требуется больше, а по потенциальным она возможностями более ограничена, нежели встроенная репликация, а также сложна в сопровождении.

### Журналы репликации (задания)

======= 18. Если в операторной репликации возникают недетерминированные функции ...

[ ] их надо выполнять на всех репликах в строго одинаковом порядке

[ ] отбросить нереплицированные записи старого ведомого

[ 1] надо переходить на построчную репликацию

======= 19. Журнал репликации лучше реализовывать ...

[ ] с помощью SS-таблиц, LSM-деревьев...

[ ] точно как журнал для подсистем хранения

[1 ] как независимый от конкретной машины логический журнал
