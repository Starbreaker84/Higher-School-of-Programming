## Антипаттерн "Интерфейс должен быть проще реализации"

### универсальный ответ на множество проблем программной инженерии

Классическому понятию интерфейса в программировании типично учат так, что интерфейс -- это не только множество сигнатур функций, но и различные неформальные элементы: поведение на достаточно высоком уровне абстракции, ограничения на вызов функций, и всё остальное, что нужно знать разработчику, чтобы продуктивно использовать этот интерфейс.

Но при этом всегда подчёркивается, что интерфейс должен быть намного проще реализации (что уже само по себе противоречит предыдущему абзацу), т.е. содержащий его модуль (например, класс) "глубокий". Такое понятие "неформального интерфейса" предложил профессор Стэнфорда John Ousterhout, автор языка Tcl/Tk -- он считает, что хороший модуль должен быть глубоким.

Но в свете современных трендов в computer science "неформальный интерфейс" Ousterhout будет пониматься как  **язык формальной спецификации** . На любой вопрос по поводу интерфейса можно ответить очень точно, получив в ответ ответ на вопрос "а как будет выглядеть формальная спецификация?".

Спецификация "по-хорошему" должна быть намного проще, чем код. Но любой человек, имеющий реальный опыт фактической формализации спецификаций, отметит, что есть много случаев, когда спецификация и получается, и должна быть сложнее реализации.

Более того, немало случаев, когда на самом деле желательно иметь более сложную спецификацию, чем код. Основных причин этому две: **призрачное состояние** (ghost state) и **погрешность/неточность** (imprecision). Призрачное состояние -- это понятие из формальной верификации, которое описывает определенные виды "хрупкого" кода. Это отдельная большая и интересная тема (например, когда простое действие вроде обмена значениями на самом деле представляет собой нечто концептуально сложное).

Неточность -- это например

```
Спецификация: 
  Температура двигателя должна быть 
  в диапазоне между 50 и 100 градусами.
Реализация: 
  Температура двигателя -- 70 градусов.
```

Спецификация тут получается более длинной именно потому, что она создаёт абстрактный барьер. Если при проектировании остальной части системы исходить из того, что температура двигателя будет ровно 70 градусов, то изменить её становится намного сложнее. Когда мы корректно ослабляем такие предположения, положенные в основу интерфейса, код получается гораздо более гибким и лёгким для развития.

Кроме того, есть ещё одна фундаментальная причина: гораздо проще описать что-то "изнутри" системы, чем "снаружи". Намного легче показать яблоко, чем отвечать на каждый вопрос про него (где там у него семена? куда яблоко будет катиться, если я его уроню?). И хотя об одном конкретном яблоке можно сказать гораздо больше, нежели обо всех яблоках в мире, в достаточно большом множестве яблок общей истины по яблокам в целом будет гораздо больше, чем в одном яблоке.

Ok, вот более наглядный для программиста пример :)

В любой ОС существует огромное количество всяческих системных флагов, настроечных параметров, которые внутри скрывают огромное количество сложностей, с жуткими скрытыми и неочевидными требованиями типа "должен быть указан ровно один из этих пяти битов". А на вызов различных системных функций могут выдаваться десятки различных кодов ошибок, каждый со своим собственным значением, и часто с отсылками на специфику конкретной реализации.

Формализация пяти команд POSIX например потребовала почти 300 строк формальной спецификации. Но зато, просто взглянув теперь на такую семантику любой команды (на 3-м логическом уровне), мы теперь получим гораздо более точное представление о функциональности этого API за пределами "простой" сигнатуры функций.

Другой наглядный пример -- виртуальная машина Java для Андроида, в реализации которой поддерживается множество типов указателей. Однако сборщик мусора (в версии 5-летней давности) периодически выполнял сжатие 64-разрядных указателей в 32-разрядные, что делало невозможным их "дереференсинг", полноценное восстановление. Правильное решение -- трактовать такие указатели как значения разных типов, что в итоге и было сделано: [androidxref.com/9.0.0_r3/xref/art/runtime/mirror/object_reference.h](http://androidxref.com/9.0.0_r3/xref/art/runtime/mirror/object_reference.h)

Компилятор теперь автоматически выполняет перегрузку присваивания фактически с нулевыми накладными расходами.

Но так как на практике применять формальные спецификации пока нереально, всегда придерживайтесь принципа  **"используйте более точные типы данных"** . Это ответ на множество проблем программной инженерии.
