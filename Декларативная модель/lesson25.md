### 19. Рекурсия

Итеративные вычисления -- это частный случай более общего вида вычислений, называемых  **рекурсивные** .

Итеративные вычисления по сути представляют собой обычный условный цикл while, в котором выполняется очередная итерация (трансформация состояния) до тех пор, пока не сработает условие окончания вычислений.

Рекурсия в программировании представлена в двух формах: в функциях и в типах данных.

**Рекурсивная функция в своём определении содержит собственный вызов** , может вызвать себя в любой точке своего тела и не один раз, а много.  **Тип данных считается рекурсивным, если он определён в терминах самого себя** . Например, когда мы разбирали списки, то выяснили, что этот тип данных рекурсивный (либо пустой список, либо головной элемент, к которому прицеплен оставшийся список). Особенно продуктивным механизм рекурсии получается, когда удаётся гармонично объединить рекурсивные функции с рекурсивными типами данных.

Однако в рекурсивных вычислениях стек вызова функций может неограниченно расти. В общем случае неаккуратное использование рекурсии приводит к знаменитой ошибке Stack Overflow (переполнение стека). К сожалению, в ряде случаев потенциально этого избежать невозможно (например, при анализе деревьев).


### Как ограничивать глубину рекурсии

В прикладном декларативном программировании принято сознательно избегать роста стека, допуская его лишь там, где он точно необходим.

Например, в классической рекурсивной функции вычисления факториала числа N потребуется стек глубиной N.

```
function f(n)
  if n == 0
     return 1
  elseif n > 0
     return n * f(n-1)
  else
     throw(DomainError())
  end
end

f(5) # 5
```

Из-за того, что умножение n * f(n-1) должно выполниться уже после того, как вычислится f(n-1), необходимо сохранить в стеке текущее состояние функции, и перейти к рекурсивному вычислению f(n-1). Текущее состояние подразумевает хранение идентификаторов и связанных с ними значений (по сути, замыкание), и реальные вычисления именно так и происходят, однако эта схема неудобна для поддержки более абстрактных схем вычислений.

Рассмотрим на этом примере типичные приёмы избегания роста стека.


### Как ограничивать глубину рекурсии - 2

Можно добавить в абстрактную декларативную машину простое расширение: механизм замены (подстановка) идентификаторов в инструкциях непосредственно на те сущности, на которые эти идентификаторы ссылаются. Абстрактная машина с подстановками не нуждается в окружении, которое приходится постоянно отображать в идентификаторы (и наоборот).
При этом, правда, стек всё равно будет расти, только уже не в глубину, а в ширину -- в одном элементе стека будут чрезмерно накапливаться промежуточные результаты. Например, в случае факториала большого числа придётся "раскрутить" выражение в ширину на всю "глубину" вызова факториала; вдобавок, такая схема сложна в реализации, и на практике не используется.

Классический способ борьбы с ростом стека -- это  **переход от рекурсивных вычислений к итеративным** . В случае функции факториала и подобных можно расширить количество параметров функции добавлением так называемого  **аккумулятора промежуточных вычислений** :

```
function f(n, a)
  if n == 0
     return a
  elseif n > 0
     return f(n-1, a*n)
  else
     throw(DomainError())
  end
end
  
f(5,1) # 120
```

Такую функцию можно для наглядности "обернуть", как говорилось выше, основной функций для внешнего вызова, которая будет получать единственный параметр, а затем вызывать рекурсивную функцию с её начальными параметрами. Кроме того, основная функция может сразу дополнительно контролировать параметр (не будет ли он отрицательным) и т. д.


### Как ограничивать глубину рекурсии - 2

Можно добавить в абстрактную декларативную машину простое расширение: механизм замены (подстановка) идентификаторов в инструкциях непосредственно на те сущности, на которые эти идентификаторы ссылаются. Абстрактная машина с подстановками не нуждается в окружении, которое приходится постоянно отображать в идентификаторы (и наоборот).
При этом, правда, стек всё равно будет расти, только уже не в глубину, а в ширину -- в одном элементе стека будут чрезмерно накапливаться промежуточные результаты. Например, в случае факториала большого числа придётся "раскрутить" выражение в ширину на всю "глубину" вызова факториала; вдобавок, такая схема сложна в реализации, и на практике не используется.

Классический способ борьбы с ростом стека -- это  **переход от рекурсивных вычислений к итеративным** . В случае функции факториала и подобных можно расширить количество параметров функции добавлением так называемого  **аккумулятора промежуточных вычислений** :

```
function f(n, a)
  if n == 0
     return a
  elseif n > 0
     return f(n-1, a*n)
  else
     throw(DomainError())
  end
end
  
f(5,1) # 120
```

Такую функцию можно для наглядности "обернуть", как говорилось выше, основной функций для внешнего вызова, которая будет получать единственный параметр, а затем вызывать рекурсивную функцию с её начальными параметрами. Кроме того, основная функция может сразу дополнительно контролировать параметр (не будет ли он отрицательным) и т. д.


### Рекурсивные вычисления (задания)

======= 38. Выберите истинное утверждение

[ ]Рекурсивные вычисления -- это частный случай итеративных вычислений

[X]Итеративные вычисления -- это частный случай рекурсивных вычислений

======= 39. Тип данных называется рекурсивным, когда...

[ ] в его определении есть рекурсивная функция

[ ] в его определении есть предикат

[X] в его определении есть обращение к самому себе

======= 40. С ростом стека в рекурсии стратегически борются с помощью ...

[ ] механизма подстановки

[ ] добавлением аккумулятора

[X] перехода к итеративным вычислениям
