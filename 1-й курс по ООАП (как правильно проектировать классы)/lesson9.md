## Команды и запросы

Теперь в свете принципа команд и запросов пересмотрим остальные имеющиеся у нас методы стека (в дополнение к конструктору).

push() -- это явная команда. Она не возвращает никакое значение, и модифицирует стек в соответствии с постусловием.

А вот в случае с pop() сразу выявляется конфликт. Этот метод с одной стороны, функция/запрос, которая возвращает верхний элемент, а с другой стороны, она одновременно меняет состояние стека, удаляя из него этот элемент (то есть должна быть оформлена как команда). И так как у нас уже есть запрос peek(), возвращающий верхний элемент стека, но не меняющий его, метод pop() надо представить в виде команды, которая просто удаляет верхний элемент, если стек не пуст.

Поэтому правильное определение метода pop() будет таким:

```
// предусловие: стек не пустой; 
// постусловие: из стека удалён верхний элемент
public void pop(); 
```

Метод size() -- это запрос, чистая функция, не влияющая на состояние стека, а метод clear() -- это команда, которая работает на всём множестве допустимых значений (то есть не требует предусловия).

Остались два метода (команда pop() и запрос peek()), которые требуют предусловий, то есть в некоторых ситуациях (когда стек пуст) их работа пока не определена. Генерация исключения и возвращение кода ошибки, как объяснялось выше, плохие способы реализации специфики методов.
**Правильно -- сделать отдельные запросы, которые будут возвращать статус выполнения этих команд**. Сами статусы лучше оформить в виде констант в классе.

```
public const int POP_NIL = 0; // push() ещё не вызывалась
public const int POP_OK = 1; // последняя pop() отработала нормально
public const int POP_ERR = 2; // стек пуст

public const int PEEK_NIL = 0; // push() ещё не вызывалась
public const int PEEK_OK = 1; // последняя peek() вернула корректное значение 
public const int PEEK_ERR = 2; // стек пуст

public int get_pop_status(); // возвращает значение POP_*
public int get_peek_status(); // возвращает значение PEEK_*
```

Дополнительные статусы \*\_NIL -- в данном случае пример, что в целом всегда желательна более точная диагностика ошибок. Например, стеки часто реализуются аппаратно (это позволяет достичь очень высокой скорости работы кода; в частности, поэтом мы изучали реализацию очереди на двух стеках), и возможны ситуации, когда аппаратный стек находится в неопределённом состоянии, пока в него что-то не втолкнулось в первый раз.

Тогда некоторую корректную последовательность работы со стеком целых чисел можно записать так:

```
stack1 = new Stask<int>()
stack1.push( 1 )

// ...

x = stack1.peek()
if stack1.get_peek_status() == Stack.PEEK_OK   
   // обрабатываем x

stack1.pop()
y = stack1.peek()
if stack1.get_peek_status() == Stack.PEEK_OK and
   stack1.get_pop_status() == Stack.POP_OK
   // обрабатываем y
```

Вместо запроса статуса конечно можно использовать size() с явной проверкой количества элементов в стеке. Но в общем случае более правильным подходом будет обращение к запросам статуса состояния. Кроме того, может показаться, что программа загромождается дополнительными проверками, но и в случае генерации исключений или возвращения значения null для пустого стека такие же проверки всё равно потребуются, причём они будут гораздо менее наглядными.
