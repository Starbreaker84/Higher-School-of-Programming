## Часть 5. Форматы кодирования данных

Всегда надо учитывать, что потенциально могут сосуществовать в системе в один и тот же момент времени не только старые и новые версии кода, но и старые и новые форматы (структуры, типы, их версии) данных. Чтобы система могла работать в такой ситуации без проблем, необходимо поддерживать совместимость в обоих направлениях:
- **обратная совместимость**- более новый код способен читать данные, записанные более старым;
- **прямая совместимость** -- более старый код способен читать данные, записанные более новым.

Добиться обратной совместимости обычно несложно: будучи создателем более нового кода, вы знаете формат данных, записанных более старым кодом, и можете явным образом обработать их (например, просто сохранив старый код для их чтения). Добиться прямой совместимости существенно сложнее, поскольку для этого более старый код должен либо быть более универсальным, либо игнорировать данные, добавляемые более новой версией.

Далее мы познакомимся с основными форматами данных, используемыми в системах, работающих с БД, и их связях с механизмами СУБД.

Программы обычно имеют дело с данными в (как минимум) двух представлениях.

1. В памяти данные хранятся в объектах, структурах, списках, массивах, хэш-таблицах, деревьях и т. д. Эти структуры данных оптимизированы так, чтобы процессор мог эффективно к ним обращаться и быстро манипулировать ими (как правило, с помощью указателей).
2. При необходимости записать данные в файлы или переслать их по сети необходимо закодировать их в некую самостоятельную последовательность байтов (например, документ в формате JSON). Поскольку внутренние указатели на данные за пределами конкретной программы или ОС смысла не имеют, итоговое представление данных в виде последовательности байтов выглядит совсем не так, как обычные структуры данных в оперативной памяти.

По этой причине требуется хороший способ преобразования между этими двумя представлениями.  **Преобразование из представления в памяти в последовательность байтов называется кодированием (encoding), сериализацией (serialization) или маршалингом (marshalling), а обратная операция -- декодированием (decoding), парсингом (parsing), десериализацией (deserialization) или демаршалингом (demarshalling)** .

Практически во всех языках программирования есть хотя бы минимальная встроенная поддержка кодирования объектов из памяти в последовательности байтов. Например, в языке Java -- пакет java.io.Serializable, в языке Python – pickle, в C# -- System.Runtime.Serialization и т. д.

Однако формат такого кодирования зачастую привязан к конкретному языку программирования или стандартной библиотеке, и чтение полученных данных из программы на другом языке представляет собой обычно весьма непростую задачу. Так, контроль версий в этих библиотеках чаще всего отсутствует, так как их основное предназначение -- быстрое и удобное кодирование данных. В результате же «неудобные» проблемы прямой и обратной совместимости в них часто игнорируются.

Более того, для превращения данных в популярный «формат» объектных типов процесс декодирования должен уметь создавать экземпляры произвольных классов. Это например часто приводит к проблемам с безопасностью: если злоумышленник способен заставить приложение декодировать произвольную последовательность байтов, то сможет создавать внутри программы экземпляры произвольных классов и запускать их в работу.

Эффективность сериализации и десериализации (процессорное время, занимаемое кодированием и декодированием, а также размер получившейся структуры в оперативной памяти) тоже часто считается в стандартных библиотеках вопросом второстепенным. Например, встроенная сериализация языка Java печально известна своей низкой производительностью и занимающими большой объем памяти итоговыми структурами.

Поэтому, общая рекомендация: как минимум, **всегда учитывайте в своих проектах, что использование встроенных средств кодирования конкретного языка программирования или его экосистемы для любых целей, кроме внутренних и очень кратковременных, практически всегда будет плохой идеей.**

**Лучший вариант -– придерживаться стандартов и спецификаций RFC.**


## Форматы кодирования данных (задания)

======= 87. Когда новый код способен читать данные, записанные более старым кодом, это ...

[ ] прямая совместимость

[1 ] обратная совместимость

[ ] общая совместимость

[ ] несовместимость

======= 88. Когда более старй код способен читать данные, записанные новым кодом, это ...

[ 1] прямая совместимость

[ ] обратная совместимость

[ ] общая совместимость

[ ] несовместимость

======= 89. Что сложнее в сопровождении -- прямая или обратная совместимость?

[ 1] прямая

[ ] обратная

[ ] обе простые

[ ] обе сложные

======= 90. Внутренние форматы кодирования в ЯП и их стандартных библиотеках -- это ...

[ ] полезная вещь, обеспечивает универсальность данных

[ 1] вредная вещь, не обеспечивает совместимости, надо придерживаться RFC

[ ] не влияет на совместимость
