## 21. Замыкания (closures)

Замыкание -- это значение (способ представления значения) типа функция.

Замыкание -- это тройка (x, exp, env), где x -- аргумент (идентификатор), exp -- выражение, вычисляющее функцию (значение типа функция), и env -- окружение, которое содержит связывания, актуальные для данного вычисления.

При вычислении

```
minus10 12
```

результатом будет замыкание

```
y, y - x, (x -> 12, "-" -> функция вычитания) 
```

Другой пример:

```
let pi = 3.14159
let circle r = 2.0 * pi * r 
printfn "%f" (circle 2.0) // 12.566360
```

circle -- это тройка (r, 2.0 * pi * r, (pi -> 3.14159, ...))

В функции circle используется идентификатор pi из внешнего лексического контекста, который входит в окружение circle и должен быть зафиксирован на момент её определения.

Связывание идентификатора pi в окружении функции circle происходит на этапе компиляции и называется статическим связыванием.

Замыкания (функции) сравнивать нельзя: не существует алгоритма, способного определить, являются ли два замыкания одной функцией.

**Задание**

Даны две функции

```
curry: (int * int -> int) -> int -> int ->int

и

uncurry: (int -> int ->int) -> int * int -> int
```

curry f -- это функция g, где g x -- это функция h, где h y = f(x,y).

uncurry g -- это функция f, где f(x,y) -- это значение h y для функции h = g x.

Напишите их реализации.

Шаблон для отправки на сервер:

```
let curry f = ...

let uncurry f = ...
```

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/lb2cc952d6.html)**

---

**Ответы на задания 20**

```
let vat n x = x * (1.0 + (float n) / 100.0) 

let unvat n x = x / (1.0 + (float n) / 100.0)

let min f = 
     let rec check = function 
         | x when f x = 0 -> x 
         | x -> check (x + 1) 
     check 1
```
