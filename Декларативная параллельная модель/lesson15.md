### Недетерминизм

Декларативная параллельная модель, несмотря на всю свою кажущуюся мощь, имеет существенное ограничение, которое
значительно усложняет её применение на практике:  **она всегда ведет себя детерминированно** . Но дело в том, что
модульные компоненты, которые действительно независимы, не детерминированы: они ведут себя недетерминированно по
отношению друг к другу, причём этот недетерминизм явно наблюдаем.

В частности, одна из часто добавляемых в декларативную модель недетерминированных операций -- это проверка, связана ли
некоторая dataflow-переменная со своим значением, или нет (это такая своеобразная "слабая" форма работы с состоянием).

Простой пример: обычное клиент-серверное приложение. Запущен сервер, и к нему подключены два независимых клиента.
Независимость подразумевает, что они работают параллельно. Соответственно, сервер может получать информацию от них в
любом порядке, но это и будет наблюдаемое недетерминированное поведение. Если бы клиенты работали согласованно, то
сервер всегда мог знать, какой клиент пошлет следующее сообщение, и программа считалась бы декларативной, но это
нереально. Поэтому нужна например команда ожидания сообщения от любого из клиентов, которая недетерминирована.

### Недетерминизм

Реальный мир не декларативен -- в нём есть и **состояние** (сущности имеют внутреннюю память), и **параллелизм** (
сущности развиваются независимо). Соответственно, возникает два класса проблем.

1) **Проблемы интерфейсов** . Декларативным компонентам не хватает выразительности для взаимодействия с недекларативными
   компонентами. Последние же наличествуют везде: и аппаратные периферийные устройства, и пользовательские интерфейсы по
   своей природе параллельны и stateful. ОС также используют параллелизм и состояние в своих собственных целях. Эти
   недекларативные свойства иногда маскируются или как-то кодируются, но на практике это никогда не работает.
2) **Проблемы спецификаций** . В спецификациях тоже часто упоминаются состояния и параллелизм, поскольку они
   ориентированы на реальный мир. Например, спецификация некоторого сервиса для совместной работы требует, чтобы для
   каждого пользователя блокировалось то, с чем он сейчас работает, чтобы предотвратить конфликты при одновременном
   доступе. В реализации блокировки соответственно должны быть каким-то образом закодированы состояния, а сама
   многопользовательская одновременная работа недетерминирована.

### Выбор подходящей модели для проекта с параллельными вычислениями

Вычислительных моделей множество, и отличаются они друг от друга по степени выразительности и степени сложности
рассуждений (понимании) о программах, написанных в этих моделях. Декларативная модель тут одна из самых простых, однако
она имеет серьёзные ограничения для некоторых областей применения. Существуют куда более выразительные модели, которые
преодолевают эти ограничения, но иногда ценой усложнения понимания. Более выразительные модели отнюдь не "лучше" других,
поскольку они не всегда дают более простые программы, и рассуждать, проектировать в парадигме этих моделей обычно
сложнее.

По опыту Van Roy сотоварищи,  **в одном проекте совершенно реально и допустимо использовать несколько вычислительных
моделей** . Например, в программе, где возникает одновременная работа с состояниями, многие компоненты вполне
допустимо (и полезно) создавать в декларативной модели. И наоборот, в декларативной программе некоторые компоненты (
например, графовые алгоритмы) в целях продуктивной реализации нуждаются в поддержке явного состояния.

Такой опыт обобщён в следующем контринтуитивном Правиле наименьшей выразительности при программировании некоторого
компонента:

**Наиболее подходящей вычислительной моделью для компонента будет наименее выразительная модель, которая приводит к
естественной программе** .

Идея в том, что каждый компонент должен быть запрограммирован в своей "естественной" модели. Почему нужна менее
выразительная модель, ведь она подразумевает более сложный процесс программирования? Потому что использование более
выразительной модели всё равно не даст существенно более простой программы, но зато заметно усложнит рассуждение о ней,
её понимание.

Что понимать под "естественной" моделью для некоторой задачи? Естественность в определённой степени -- свойство
субъективное. Разные люди будут находить различные модели более легкими в использовании, из-за различий в знаниях и
опыте. Вопрос не в формальном определении "естественности", а в принятии того, что такое определение существует для
каждого разработчика, даже если оно может быть разным для разных людей.

### Выбор подходящей модели для проекта с параллельными вычислениями

В частности, декларативная параллельная модель может быть естественно расширена так:

1) **Добавление исключительных ситуаций** . Такая модель больше не будет декларативной, поскольку могут быть созданы
   программы, в которых проявляется недетерминизм.
2) **Добавление портов** . Это так называемая  **параллельная модель с передачей сообщений** . Она представляет собой
   декларативную модель, расширенную каналами связи (портами). Таким способом мы обходим ограничение декларативной
   параллельной модели, не способной реализовать программы с некоторым недетерминизмом -- например, клиент/сервер, когда
   несколько клиентов параллельно взаимодействуют с сервером. Это полезное обобщение декларативной модели, которое легко
   реализуется и позволяет ограничить недетерминизм небольшими частями программы.
3) **Добавление состояния** . Данная модель называется  **параллельная модель с общим состоянием** , которая в
   дополнение к состоянию расширена нитями. Она, в частности, включает параллельное объектно-ориентированное
   программирование. и более выразительна, нежели чистая декларативная параллельная модель, поскольку может использовать
   явное состояние для ожидания наступления одного из нескольких событий (недетерминированный выбор). Однако и
   рассуждение, проектирование с помощью этой модели будет наиболее сложным, поскольку в процессе работы может возникать
   множество сценариев, взаимодействующих непредсказуемым образом.

### Выбор подходящей модели для проекта с параллельными вычислениями

Как правило, любая хорошо написанная программа разумного размера содержит части, написанные в разных моделях (возможно,
это и сами авторы не осознают). На практике существует множество способов совместного использования различных
вычислительных моделей в одном проекте. Рассмотрим особо полезную технику  **"согласование импедансов"** , больше
известную электронщикам, которая естественным образом позволяет использовать различные модели совместно в одной
программе.

Пусть вы изучили две вычислительные модели Large и Small. Модель Large более выразительная (код более нагляден и прост),
но соответственно, и качественно думать/проектировать в её парадигме сложнее. Например, Large -- это императивная
модель, и Small -- декларативная модель. Так вот, благодаря согласованию импеданса мы можем написать программу в модели
Small, которая будет существовать в вычислительной среде модели Large.

Согласование импеданса работает так: мы строим абстракции в более выразительной модели Large, которая параметризуется и
реализуется в модели Small. Суть согласования импеданса -- поиск и реализация правильных абстракций. Эта работа сложная,
но её нужно сделать один раз; после этого остаётся только лёгкая работа по использованию этих абстракций в модели, более
подходящей для проектирования и эксплуатации.

### Выбор подходящей модели для проекта с параллельными вычислениями

Это удивительно, но оказывается, что практически всегда можно найти и реализовать в одной модели нужное множество
подходящих абстракций, и с их помощью выполнять проектирование в более подходящей для конкретной задачи модели.
Например:

-- Использование "последовательного" компонента в параллельной модели. Абстракцией может быть "сериализатор", который
принимает одновременные запросы, передает их на обработку последовательно, и корректно возвращает ответы. Сериализатор
вместе с подключённым к нему дополнительным последовательным компонентом, выполняющим обработку, в целом представляют
собой один параллельный компонент.

-- Использование централизованного компонента в распределенной модели (когда выполняется более чем один процесс ОС).
Например. абстракцией может быть "коллектор", который принимает запросы от любых внешних компонентов, и передает их на
обработку на один сервис.

-- Использование компонента, выполненного в безопасной модели, в небезопасной модели (в которой предполагается
существование вредоносных сущностей, способных нарушить работу программ вполне определёнными способами). Безопасная же
модель предполагает, что таких сущностей не существует. Абстракцией может быть "защитник", который изолирует
определённые "вычисления", проверяя и контролируя все запросы к ним от других "вычислений" и преодолевая вредоносную
активность. Пример -- межсетевой экран.

-- Использование компонента, предназначенного для закрытой модели, в открытой модели (которая позволяет независимым
вычислениям отыскивать друг друга, и вести взаимодействие). Закрытая же модель предполагает, что все вычисления
изначально известны. Абстракция может быть "коннектором", который принимает запросы от одного вычисления для подключения
к другому, используя открытую схему адресации.

-- Использование компонента, предполагающего надежную модель, в модели, допускающей частичные отказы (в распределённой
системе, когда её часть выходит из строя). Например, абстракцией может быть репликатор, который обеспечивает
отказоустойчивость путем активной репликации как данных, так и вычислений (функций) между несколькими серверами,
управляя восстановлением при отказе одного из них.

Все эти случаи ортогональны, и на практике нередко хорошей идеей оказывается реализовать несколько подобных случаев в
одной абстракции.

---

Обычно абстракция не требует каких-то особых условий от программы, написанной в модели Small. Например, репликатор часто
предполагает. что функция, которую он реплицирует, детерминирована.

Согласование импедансов широко используется в языке/экосистеме Erlang: типичная абстракция Erlang получает декларативную
программу, написанную на функциональном языке, и превращает её в stateful, параллельную и отказоустойчивую.

### 15. Программирование реального времени

======= 43. Программирование реального времени (выберите неверное утверждение)

[ ] жёсткое реальное время подразумевает соблюдение сроков выполнения всегда

[ ] мягкое реальное время допускает нарушение сроков выполнения

[ ] Windows может работать в мягком реальном времени

[ 1] Linux на особой аппаратуре может работать в жёстком реальном времени

======= 44. Какая базовая операция мягкого реального времени лишняя?

[ ] создание и запуск новой нити

[ 1] окончательная остановка работающей нити

[ ] получить текущее время

[ ] задержка выполняющейся нити
