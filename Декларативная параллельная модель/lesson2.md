### Параллельная модель, два вида

Последовательную декларативную модель мы превратим в параллельную за два шага.

Во-первых, мы введём понятие  **нить, тред (thread)** . Нить -- это просто исполняющаяся инструкция, и это всё, что
требуется, чтобы начать программировать декларативные параллельные программы :) Эту модель будем называть  **модель
одновременных вычислений, управляемая данными** .

*Фундаментальное отличие процессов от нитей в том, как они управляют ресурсами. Параллелизм на уровне процессов -- это
нечто в духе соревнования: каждый процесс пытается захватить под себя все системные ресурсы. ОС старается играть роль
судьи и обрабатывать запросы на ресурсы достаточно справедливо.
Параллелизм на уровне нитей -- это нечто в духе кооперации: нити в процессе разделяют ресурсы и действуют совместно,
чтобы процесс выдал наилучший результат. Нити обычно принадлежат одному приложению и управляются им.*

Во-вторых, расширим эту модель некоторым порядком исполнения. Для этого добавим понятие **триггера** -- получится
вычисление-по-запросу, известное также, как ленивое выполнение. Итоговую модель назовём модель одновременных вычислений,
управляемая запросами, или  **ленивая модель одновременных вычислений** .

Исключительные ситуации в данную модель не входят, потому что они не декларативны; схему их поддержки рассмотрим
отдельно.

### Базовые концепции параллелизма

Параллелизм подразумевает простое расширение декларативной модели, которое позволяет  **более чем одному выполняющемуся
оператору ссылаться на хранилище однократных присваиваний** . Инструкции, грубо говоря, выполняются "в одно и то же
время", условно одномоментно (мы никогда не знаем, какие из них завершатся раньше или позже других). Для этого мы
добавляем одну новую инструкцию thread.

### Чередование

Давайте более формально рассмотрим, что именно означает "одновременно", "одномоментно" в декларативной модели.

С точки зрения семантики языка (как это видит программист): в реальной работе нити поочередно выполняют шаги вычислений.
Шаги вычислений не пересекаются в том смысле, что каждый шаг вычислений атомарен -- когда он выполняется, его работу
никто не перебивает.

С точки зрения реализации, рассматриваем, как несколько нитей фактически работают на реальной машине. Если программа
выполняется на одном процессоре, то в ходе исполнения также может выполняться чередование шагов. Однако система может
работать и на нескольких процессорах, так что нити могут выполнять по нескольку своих шагов вычислений одновременно. Это
даёт прежде всего существенный выигрыш в производительности.

Далее такую семантику "чередования" мы будем использовать на протяжении всего курса. Каким бы ни было параллельное
выполнение программы "внутри", всегда существует по крайней мере один вариант чередования её параллельных частей,
которое эквивалентно этому выполнению для внешнего наблюдателя. То есть, если мы наблюдаем за хранилищем во время
выполнения программы, всегда возможно найти такое "чередующееся" последовательное выполнение кода, которое заставит
хранилище функционировать таким же образом. Условно говоря, параллельное выполнение мы всегда можем перевести в
последовательное.

### Каузальный порядок шагов вычислений

Для конкретной программы, все шаги вычислений образуют некоторый частный/частичный порядок, называемый  **
причинно-следственным порядком** . Шаг вычисления считается произошедшим ранее другого шага, если во всех возможных
вариантах исполнения программы он всегда происходит раньше другого. Аналогично и для шага вычислений, который происходит
после другого шага (после он происходит всегда).

Иногда шаг не происходит ни до, ни после другого шага в том смысле, что мы не можем гарантировать их
причинно-следственный порядок. В таком случае мы говорим, что эти два шага будут  **одновременными** .

**В последовательной программе все шаги вычислений полностью упорядочены** . В ней не существует параллельных шагов.

**В параллельной программе все шаги вычислений внутри конкретной нити полностью упорядочены** .

Шаги вычислений параллельной программы в целом образуют частичный порядок. Два шага в этом частичном порядке причинно
упорядочены, если первый из них связывает dataflow-переменную X со значением, а второму шагу требуется значение
переменной X.

### 2. Декларативная параллельная модель

======= 4. Ключевой принцип декларативной параллельной модели

[ 1] dataflow-переменная может быть связана только с одним значением

[ ] результат работы рассчитывается параллельно

[ ] результат работы программы независит от её параллельности

======= 5. Почему декларативная форма параллелизма так проста? (выберите неверное утверждение)

[ ] не возникает условий конкуренции (race condition)

[ ] не важно, выполняются ли части программы последовательно или параллельно, результат гарантированно будет один и тот
же

[ 1] такие программы характеризуются наблюдаемым недетерминизмом

[ ] dataflow-переменные не связываются с несовместимыми значениями
