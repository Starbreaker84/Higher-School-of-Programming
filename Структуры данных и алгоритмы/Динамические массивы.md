## Динамические массивы

У списков есть свои неоспоримые преимущества, но есть и один недостаток -- мы не можем обратиться к конкретному элементу быстро, по индексу, одним обращением. Сложность операции выборки i-го элемента, очевидно, O(n) -- нам надо, в наихудшем случае, пробежаться по всему списку с начала до конца. А массивы через индексирование обычно предоставляют меру O(1) -- то есть не зависящую от размера массива. И мы при этом хотим работать с массивами, как с динамическими объектами -- чтобы они автоматически расширялись при добавлении в них элемента.

Практически во всех современных языках поддерживается тип данных "список", как минимум на уровне стандартных библиотек, который в принципе полностью отвечает требованиям динамического массива. Список обычно индексируется, позволяет добавлять элементы в позицию по индексу, автоматически расширяется когда в него добавляются новые элементы, и сжимается при удалении элементов.

**Схемы реаллокации**

Схем увеличения буфера (реаллокации массива) две: аддитивная и мультипликативная.

**Аддитивная схема** обычно применяется, когда размер массива небольшой, и расходы на реаллокацию невелики. В таком случае экономичнее увеличивать его размер относительно небольшими фиксированными порциями. **Мультипликативная схема** подразумевает достаточно сильное изменение размера -- в разы, так как реаллокация крупного массива потребует существенных ресурсов. Обычно он удваивается. Пример мультипликативной схемы, принятой в стандартной библиотеке Java:

```
size = (size * 3) / 2 + 1
```

Часто применяется и отношение "золотого сечения" 1,618.

В целом, политика регулирования такого размера сильно зависит от конкретной решаемой задачи.

**Важно** . В тестах используется схема, когда увеличение буфера происходит в два раза, а уменьшение в полтора раза (текущее значение размера буфера делится на 1.5, и результат приводится к целому типу, никаких округлений!). При этом сохраняем минимальную ёмкость 16 элементов. То есть если после деления на 1.5 получается меньше 16 элементов, то принимаем новый размер буфера 16 элементов.
Увеличение буфера выполняем, когда он весь полностью заполнен, и выполняется попытка добавления. Сокращение буфера выполняем, когда его заполненность после операции удаления станет строго меньше, чем заданный процент заполнения. В тестах используйте этот процент равным 50%.
Придерживайтесь этой схемы в своём коде для успешного тестирования.

**2. Анализ мультипликативной схемы с помощью банковского метода**

В общем случае недостаток мультипликативной схемы в том, что размер массива будет увеличиваться в геометрической прогрессии, а желаемая сложность O(1) в реальности будет o(1) (в среднем). Если вставка попадёт на реаллокацию, задержка времени может быть существенной. Поэтому в противовес так называемому **агрегированному методу** анализа сложности (и, соответственно выбору метода реаллокации), который подразумевает вычисление итоговой суммарной оценки всех операций (общее время работы) применяют  **банковский метод** .
Его идея в том, что дешёвые операции мы делаем чуть дороже, чем они реально стоят, а дорогие наоборот подешевле. При этом удаётся поддерживать всё время положительный баланс, несмотря на то, что дорогие операции по абсолютной цене могут уводить его в минус.
Например, каждый случай вставки элемента, когда реаллокации не происходит, и каждый случай копирования элемента при копировании, можно оценивать не в одну условную операцию записи, а в три. Как только накапливается достаточная сумма, чтобы оплатить очередную реаллокацию, она выполняется. Причём цена её зависит от количества элементов в массиве и выбирается например, как степень двойки, не превышающая новый размер буфера.

**3. Реализация динамического массива на практике**

Мы смоделируем работу динамического массива вручную.

В классе DynArray потребуются три поля: count -- текущее количество элементов в массиве, capacity -- текущая ёмкость буфера (исходно 16 единиц), и array -- по сути, указатель на блок памяти нужной ёмкости.
Как лучше реализовать поле array? Дело в том, что не во всех языках разрешено напрямую работать с памятью.

Стандартный рекомендуемый здесь приём -- array хранит массив фиксированной длины с объектами некоторого базового типа, к которому приводятся все остальные типы. Когда мы расширяем или уменьшаем размер array, мы просто пересоздаём его с новым размером, и затем копируем объекты (по сути, указатели) в массив нового размера. Это копирование выполняется очень быстро и практически не требует ресурсов. Более того, во многих языках имеется стандартная операция копирования массивов.

**4. Общие рекомендации**

Если вам понадобится запрограммировать некоторую структуру данных, которую удобно сделать как связный список или как динамический массив, что лучше выбрать? Если элементов немного, то проще использовать самый обычный массив фиксированного размера с гарантированным запасом места (не важно, будет его размер 100 или 200 элементов, если их точно не будет больше верхней границы). А если их наоборот очень много, то плох будет и список, и динамический массив: первый слишком долго перебирать, а второй слишком долго расширять. Поэтому на практике например используется гибридная схема динамический "массиво-список": список составляется не из отдельных элементов, а из блоков (массивов фиксированного размера), которые сцепляются в список по мере роста числа элементов. При этом сам список относительно небольшой, поэтому его сканирование за O(N) вполне допустимо, а наращивание размера за счёт добавления фиксированных блоков выполняется за O(1). Внутри же этих блоков обращение к элементам также осуществляется за O(1). Но при этом, конечно, придётся пожертвовать временем доступа к конкретным значениям.

В целом, очень полезная практика -- комбинирование разных структур данных в одной, прежде всего из соображений масштабируемости. Когда данных для хранения слишком много, использовать одну классическую, "чистую" базовую структуру данных не всегда оптимально. Надо подумать, можно ли выделить во входных данных какие-то блоки, в которых имеется своя внутренняя структура, внутренняя организация, и применять для них наиболее подходящие типы данных, которые уже глобально связывать чем-то простым вроде списка или массива. Старайтесь применять такой подход и в дальнейшем, прикидывайте, как можно формировать эффективные композиции различных структур данных.

**Задания.**

1. Нам потребуются такие базовые методы:

- формирование блока памяти заданного размера: MakeArray(int new_capacity). Метод меняет размер массива array, копируя при необходимости текущие объекты вышеописанным способом;
- получение объекта по его индексу GetItem(int i). В этот метод встроим проверку корректности индекса в рамках границ, и генерацию соответствующего исключения, если обращение некорректно;
- добавление нового элемента в конец массива, метод Append(item) .

**Важно** . В тестах используется схема, когда увеличение буфера происходит в два раза, а уменьшение в полтора раза (текущее значение размера буфера делится на 1.5, и результат приводится к целому типу). При этом сохраняем минимальную ёмкость 16 элементов.
Придерживайтесь этой схемы в своём коде для успешного тестирования.

2. Добавьте метод Insert(item, i), который вставляет в i-ю позицию объект item, сдвигая вперёд все последующие элементы. Учтите, что новая длина массива может превысить размер буфера.
3. Добавьте метод Remove(i), который удаляет объект из i-й позиции, при необходимости выполняя сжатие буфера.

В обоих случаях, если индекс i лежит вне допустимых границ, генерируйте исключение.

Важно, единственное исключение: для метода Insert() параметр i может принимать значение, равное длине рабочего массива count, в таком случае добавление происходит в его хвост.

4. Оцените меры сложности для этих двух методов.
5. Напишите тесты, проверяющие работу методов Insert() и Remove():
   -- вставка элемента, когда в итоге размер буфера не превышен (проверьте также размер буфера);
   -- вставка элемента, когда в результате превышен размер буфера (проверьте также корректное изменение размера буфера);
   -- попытка вставки элемента в недопустимую позицию;
   -- удаление элемента, когда в результате размер буфера остаётся прежним (проверьте также размер буфера);
   -- удаление элемента, когда в результате понижается размер буфера (проверьте также корректное изменение размера буфера);
   -- попытка удаления элемента в недопустимой позиции.

**[предыдущее](https://skillsmart.ru/algo/15-121-cm/bafa83f3b9.html)**

---

## заготовка класса C# для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
using System;
using System.Collections.Generic;

namespace AlgorithmsDataStructures
{

   public class DynArray<T>
   {
     public T [] array;
     public int count;
     public int capacity;

     public DynArray()
     {
       count = 0;
       MakeArray(16);
     }

     public void MakeArray(int new_capacity)
     {
       // ваш код
     }

     public T GetItem(int index)
     {
       // ваш код
       return default(T);
     }

     public void Append(T itm)
     {
       // ваш код
     }

     public void Insert(T itm, int index)
     {
       // ваш код
     }

     public void Remove(int index)
     {
       // ваш код
     }

    }
}
```

---

## заготовка класса Java для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
public class DynArray<T>
{
     public T [] array;
     public int count;
     public int capacity;
     Class clazz;

     public DynArray(Class clz)
     {
       clazz = clz; // нужен для безопасного приведения типов
       // new DynArray<Integer>(Integer.class);

       count = 0;
       makeArray(16);
     }

     public void makeArray(int new_capacity)
     {
       // array = (T[]) Array.newInstance(this.clazz, new_capacity);
       // ваш код
     }

     public T getItem(int index)
     {
       // ваш код
       return null;
     }

     public void append(T itm)
     {
       // ваш код
     }

     public void insert(T itm, int index)
     {
       // ваш код
     }

     public void remove(int index)
     {
       // ваш код
     }

}
```

---

## заготовка классов C++ для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
#include <stdio.h>

class DynArray
{
  public:
     int count;
     int capacity;
     int array [];  // хранит неотрицательные значения
   
     DynArray()
     {
       count = 0;
       make_array(16);
     }

     void make_array(int new_capacity)
     {
       // ваш код
     }

     int get_item(int index)
     {
       // ваш код
       // все значения считаются неотрицательными
   
       // если элемент не найден:
       return -1;
     }

     void append(int value)
     {
       // ваш код
     }

     void insert(int value, int index)
     {
       // ваш код
     }

     void remove(int index)
     {
       // ваш код
     }

};
```
