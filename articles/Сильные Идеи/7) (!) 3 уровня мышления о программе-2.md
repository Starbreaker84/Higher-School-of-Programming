## Три уровня рассуждений о программной системе - 2

Итак, вы завершили стадию предварительного планирования, и включились в циклы коротких итераций, спринтов, как рекомендует agile. У вас есть доска с множеством листков-задачек, пользовательских требований, которые вам просто надо реализовать. И во всей этой гибкой движухе всё более соблазнительно отказаться от ведения отдельного документа по проектированию ([подробно про важность этого писал тут](https://vk.com/wall-152484379_3422)) -- в пользу того, чтобы просто начать фигачить модный самодокументируемый/самодокументирующийся код.

И это ваша роковая ошибка.

Мы рассуждаем о поведении программы на трёх уровнях: **исполнение, код и спецификация** (в 99% неосознанно, поэтому постоянно путая и смешивая эти уровни). Наибольшая информация -- самое ценное знание о системе -- находится на уровне спецификаций. Вообще, информация о структуре программы, о её дизайне (логической архитектуре), почти не присутствует в ней физически, на уровне кода.

Имею в виду не только то, что нужно действительно внимательно изучить код, чтобы понять дизайн системы; имею в виду, что  **может быть (бесконечно) много дизайнов, которые соответствуют одному и тому же коду** , и поэтому восстановить по нему хотя бы более-менее релевантную информацию о дизайне на самом деле невозможно. Точнее, сам дизайн подразделяется на два уровня: высокоуровневый дизайн спецификаций, и низкоуровневый дизайн реализации (те же паттерны проектирования). Выше этого нижнего этажа дизайна подняться через понимание кода невозможно.

Давайте изучим несколько принципов проектного мышления на третьем уровне. Они решают типичные проблемы плохого дизайна: хрупкие тесты и большая вероятность большой дополнительной работы и ошибок завтра.


## Три уровня рассуждений о программной системе - 2

Сперва пишите тесты, рекомендует TDD, и код будет естественно и корректно им следовать. Тесты -- это те же спецификации, заявляют гуру TDD. Очень полезно думать над своим будущим кодом перед тем, как он будет физически написан, говорят они.

Проблема в том, что тесты не принуждать вас разделять "цели" кода, смысловые задачи кода и реализацию.

TDD -- это довольно слабая (хотя и полезная, отмечу!) попытка мыслить на третьем уровне, оставаясь фактически на втором уровне.

Итак, вы изменили код, тесты сломались, и вы рассуждаете так: ага, я добавил новую фичу, которая в тестах пока не учитывалась. Подправлю-ка я тесты, чтобы они соответствовали новым возможностям. И вот если вы пытаетесь использовать TDD в качестве замены высокоуровневому обдумыванию архитектуры, то, скорее всего, так и будет происходить постоянно, несмотря на то, что TDD настаивает на главенстве тестов.

Проблема с TDD в том, что программисту на практике слишком сложно удерживать в голове запутанную структуру объёмного кода на втором уровне -- поэтому и написать полноценные тесты, учитывающие все нюансы кода наперёд, практически невозможно.

Есть два способа писать плохие тесты. Первый -- пропускать некоторые типовые сценарии, и не делать достаточно строгих проверок. Так случается, когда разработчики гоняются за 100% покрытием кода, не задумываясь о том, а что вообще они тестируют. Типичная слепая зона тут заключается в том, что программист проверяет, что происходит, когда программа работает правильно, но не проверяет, что случится, когда сервер не работает, когда он передаёт ошибочные данные и т.д.

Другой плохой способ писать тесты -- наоборот, делать излишне много тестов, учитывать множество крайне экзотических ситуаций, и быть излишне специфичным.

**Код не должен следовать тестам, ни тесты не должны следовать коду.**

**И тесты, и код должны следовать дизайну, логической архитектуре** .


## Три уровня рассуждений о программной системе - 2

Один из приятных результатов в понимании кода на уровне дизайна/спецификации заключается в том, что теперь у нас есть очень чёткие определения таких ранее нечётких понятий, как например "этот код знает об этом коде".

Есть три модуля, выполненные в функциональном стиле. Модуль 1 определяет запись "студент" с двумя полями (Name1 - имя, Name2 - фамилия) в виде словаря. Модуль 2 определяет запись "сотрудник", превращая студента в студента-сотрудника (создавая новую запись). Наконец, модуль 3 использует записи о сотрудниках, а именно, распечатывая их имя в лог.

```
Module 1 :

function createStudent(name1, name2) {
  return {"Name1": name1, "Name2": name2};
}

Module 2:

function createStudentEmployee(student) {
  var e =  student.copy();
  e["employeeId"] = nextEmployeeId();
  return e;
}

Module 3:

function printEmployeeName1(employee) {
  log(employee["Name1"]);
}
```

Модуль 3 обращается к полю Name1 сотрудника, которое определено в модуле 1. Вопрос: знает ли модуль 3 о модуле 1? То есть, нужно ли описание того, что делает модуль 3, выполнять в терминах описания того, что делает модуль 1? Ответ: в зависимости от ...

Если в документации по модулю 2 говорится, что "createStudentEmployee() возвращает запись студент-сотрудник с полями Name1, Name2 и employeeId", то ответ -- однозначно нет.

Это просто деталь реализации, что createStudentEmployee() получает запись "студент-сотрудник" путем добавления нового поля employeeId к записи "студент".

Но если документация утверждает, что "createStudentEmployee() возвращает запись "студент" с дополнительным полем employeeId", то это действительно тот случай, когда вы не можете полноценно понять, что передаётся аргументом функции printEmployeeName1(), не изучив код модуля 1 -- поэтому модули 1 и 3 очень сильно связаны между собой.


## Три уровня рассуждений о программной системе - 2

Что делает такой код?

```
return x >= 65
```

Если x – код символа, то это проверка, будет ли он буквой или цифрой. Если x – возраст сотрудника, то это проверка, находится ли сотрудник в пенсионном возрасте.

В обоих возможных вариантах ответа исходный код один и тот же. Если это просто отдельная автономная функция из модуля Utils, то сама по себе она не имеет никакого значения для программы, её вполне можно использовать во всех случаях. Но смысл этой функции имеет огромное значение для эволюции проекта.

Может измениться кодировка; могут измениться правила учёта пенсионного возраста; программист может "заоптимизировать" этот код до

```
return x >> 6
```

и т. д.

А вот если бы вы пытались доказать правильность программы, использующей эту функцию, пруф-ассистант, например, не был бы убеждён, что Константин имеет право на пенсионные выплаты только потому, что эта функция вернула true, пока вы явно не подскажете ему, что именно эта функция предназначена именно и только для этого.

Если же думать о программе на втором уровне, только как о коде, то буква "А" будет в нём тем же самым, что и пенсионный возраст.

**Так что сосредоточьтесь на уровне логической архитектуры** .


## Три уровня рассуждений о программной системе - 2

### Как писать более лучший код?

Это были два элементарных примера ситуаций, когда невозможно восстановить смысл только из самого кода. Для тестов соответственно тоже нет другого решения, кроме как где-то отдельно описать дизайн тестируемого кода на третьем уровне, так, чтобы из него можно было узнать, корректен ли порядок параметров HTTP, и какое количество попыток нужно, чтобы запрос API отработал успешно.

Важно:  **почти всегда можно изменить код так, чтобы он соответствовал ровно одному дизайну** .

Например, если мы хотим расцепить модули 1 и 3, в модуле 2 надо создавать записи со всеми тремя явными полями, и затем заполнять два поля значениями из записи "студент". При этом возникнет некоторая сцеплённость между модулями 1 и 2 по списку полей, что лучше всего решается статической типизацией и оформлением этих структур как типов данных и связыванием их, например, через наследование, или через композицию.

В случае

```
return x >= 65
```

как минимум всегда надо делать

```
return x >= RETIREMENT_AGE
```

И пусть константа ASCII_A совпадает по значению с RETIREMENT_AGE -- это первый уровень, но уже на втором уровне кода RETIREMENT_AGE и ASCII_A представляют разные концепции, и не будут взаимозаменяемыми ни в дизайне, ни в формальном доказательстве.

Важно:  **Делайте дизайн по возможности явно видимым в коде** .

Вы скажете, что это очевидно, но это будет долго оставаться весьма расплывчатым и неоднозначным, пока вы по-настоящему не научитесь практическому пониманию того, как код получается просто следствием именно из дизайна, из строгой логики третьего уровня.


## Три уровня рассуждений о программной системе - 2

### Некоторые важные вещи остаются незамеченными

При построении современных моделей машинного обучения остро стоит проблема нарушения причинно-следственных связей. При огромном, даже при бесконечном потоке данных может возникать много процессов, которые генерируют одни и те же результаты. Если вы просто собираете данные о том, в какие дни в городе шёл дождь, и в какие дни на улицах была грязь, вы не сможете отличить множество ситуаций, в которых дождь впоследствии вызывает грязь, от множества ситуаций, в которой грязь впоследствии "вызывает" дождь. Вам нужно знать кое-что ещё: дождь вызывает грязь, но грязь не может призвать дождь.

Проектирование, дизайн, логическая архитектура программного обеспечения часто характеризуются тем, что может быть много дизайнов, которые соответствуют одному и тому же коду -- и это не очень здорово. Причина этого в том, что соотношение "один код -- единственный дизайн" не может быть выполнено, если не думать о системе прежде всего на третьем уровне, когда код становится просто естественным следствием формальной логической модели.

Тем, кто любит поговорить о "самодокументирующемся коде", не хватает чего-то большого. Цель документации -- описать не только и не столько то, как система работает сегодня, на данный момент, но и то (прежде всего), **как система будет работать в будущем, в виде новых версий, после многократных модификаций.** И поэтому очень важно выносить в сознательное понимание то, что не удаётся, что невозможно документировать на первом и втором уровнях.
