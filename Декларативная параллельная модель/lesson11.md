### Варианты параллельной декларативной модели

Рассмотрим теперь, как можно использовать параллельную декларативную модель на практике, не прибегая к концепции потоков.

**Порядково-детерминированный параллелизм (order-determining concurrency)**

Это случай, когда мы знаем, какие вычисления должны быть выполнены, но не знаем порядок их выполнения. Более того, порядок сам может зависеть от значений данных, т. е. не существует одного статического порядка вычислений, который был бы всегда правильным. Простейший пример -- это обход дерева, конкретная структура которого неизвестна. В таком случае мы можем выполнять рекурсивный обход каждого поддерева в каждом узле параллельно, так как каждое поддерево -- это отдельное полноценное дерево, никак со всей остальной частью обходимого дерева не связанное. Результат работы такого алгоритма будет такой же, как и в случае "последовательного" рекурсивного обхода, потому что параллелизм используется тут только для изменения порядка вычислений, а не для изменения самих вычислений. В каком порядке физически будет обходится каждое поддерево в заданном дереве, мы не знаем, но это и не имеет значения.


### Программирование в ограничениях

Этот подход близок к технологиям искусственного интеллекта, когда мы достаточно явно переносим существенную часть нагрузки по проектированию программы с разработчика на систему (движок формального вывода). Это область так называемого  **логического программирования** : мы всё дальше уходим в направлении "что требуется получить", и всё дальше от "как именно получить результат".

На эту тему у меня есть [небольшой курс](https://vk.com/wall-152484379_2878).

Однако при этом требуются довольно сложные алгоритмы поиска решения в модели с заданными ограничениями, которые могут требовать большого времени выполнения. Порядково-детерминированный параллелизм применяется при анализе локальных условий ограничений, что расширяет модель поиска одновременным анализом различных кандидатов в решение, пока не будет найдено полное решение.


### Корутины

**Корутины (сопрограммы)** -- это весьма популярная в современном программировании параллельная модель, которая фактически означает  **нить без вытеснения (nonpreemptive thread)** . Для более точного её понимания введём понятие **локуса контроля** как выполнения некоторой последовательности инструкций, продолжающей предыдущую логику, за один условный шаг. Когда выполняется обычная последовательная программа, локус контроля в ней всегда один. Например, если вызывается функция, то управление передаётся ей, затем выполняется её тело (локус контроля остаётся всё так же единственным), далее управление передаётся вызывающей программе, и она продолжает работать.

Корутина больше похожа на нить: она выполняется одновременно с вызывающей её программой, но эта одновременность реализуется не системой времени выполнения или ОС, а задаётся явно самим программистом. Фактически, сам разработчик определяет, с какого момента корутина (имеющая свой собственный локус контроля) должна приостановить свою работу, передав управление вызывающей программе, и когда вызывающая программа должна снова вернуть управление корутине, чтобы она продолжила работу с прерванного места (с сохранением текущего состояния, конечно).

Нить отличается от корутины лишь тем, что переключение между нитями выполняется автоматически, скрытно, без явного вмешательства программиста.


### Корутины

Корутины типично управляются двумя операциями.
Операция **Spawn** создаёт новую корутину (и возвращает её системный идентификатор), примерно так же, как создаётся новая нить. Эта корутина сразу после создания находится в приостановленном состоянии.
Операция **Resume** передаёт управление корутине с заданным идентификатором, которая становится активной до тех пор, пока явно не передаст управление другой корутине или вызывающей программе.

Такая передача управления должна происходить достаточно часто, чтобы у других корутин тоже был шанс на выполнение. Тут нередки ошибки программистов, когда некоторая корутина никогда не получает управление (такая ситуация называется  **голодание** ). В случае нитей голодание практически невозможно.

Корутины не вносят недетерминизм, и использующие их программы остаются декларативными. Однако сами корутины не могут быть реализованы в декларативной модели параллельных вычислений, поскольку для их реализации требуется явное состояние (лексическое замыкание).

Корутины в различной форме существуют во многих языках программирования (как итераторы/генераторы например), потому что очень удобны, позволяя в частности генерировать бесконечные последовательности значений, или пошагово обрабатывать массивы и списки последовательно, "запоминая", на каком элементе они остановились.


### Параллельная композиция

Нить может создаваться и запускаться в декларативной модели тривиально (просто указанием инструкции thread для кода, который можно выполнять параллельно). Однако на практике часто возникает вопрос: как явно согласовать работу запущенной нити с исходным потоком управления? В Julia для этого, как говорилось, используются инструкции fetch и wait, а что насчёт декларативной модели?

Хорошо изученный способ прежде всего -- это использовать dataflow-переменные. Если например в N разных нитей имеется некоторая общая связанная логика - i-я нить должна дождаться, когда в j-й нити закончится некоторое вычисление, для этого естественно задействовать dataflow-переменную (которая глобальна по отношению ко всем нитям), и i-я нить просто будет дожидаться связывания её со значением в j-й нити.

Другой допустимый способ эквивалентен подходу в Julia и других языках: явное использование инструкции наподобие wait, которым однако надо пользоваться с осторожностью, потому что легко превратить параллельный код в последовательный (следующая нить будет ждать завершения предыдущей), и выигрыша за счёт реального одновременного (мультиядерного например) выполнения не получится.

Третий способ (своего рода универсальная версия первого) -- использовать потоки (трансдьюсеры...).



### Параллельная композиция

Более сильная абстракция управления для параллельной композиции -- это  **комбинатор** . Термин "комбинатор" подчёркивает, что соответствующая операция композиционна, т. е. что комбинаторы могут быть вложенными. Это верно например для абстракций управления, основанных на лексических замыканиях (процедурные значения в декларативной модели).

Комбинатор получает на вход набор процедур без аргументов, запускает каждую из них в собственной нити, и завершает свою работу, когда все нити закончат свою работу. Процедуры без аргументов тут фактически играют универсальную роль программных инструкций, которые могут выполняться параллельно, а сам комбинатор играет роль некоторой управляющей структуры, фиксирующей завершение работы всех одновременно выполняющихся шагов вычислений.
Реализация комбинатора внутри (например, по вышерассмотренным схемам) может быть и недекларативной, главное, чтобы логика его интерфейса оставалась декларативной.



### 11. Синхронное программирование и потоковые объекты

======= 31. Потоковый объект -- это ... (выберите неверное утверждение)

[ ] рекурсивная процедура в собственной нити

[ ] процедура, поддерживающая внутреннее состояние

[ ] чистая функция

======= 32. Синхронное программирование -- это программирование ...

[ ] в рамках направленного графа потоковых объектов

[ ] в рамках обычного графа потоковых объектов

[ ] в рамках дерева потоковых объектов

[ ] в рамках списка потоковых объектов

======= 33. Для моделирования схем с устойчивыми состояниями требуется ...

[ ] прямая связь выхода со входом

[ ] поддержка внутреннего состояния

[ ] временная задержка между входами и выходами
