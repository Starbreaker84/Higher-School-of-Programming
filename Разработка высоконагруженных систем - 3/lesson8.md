## Атомарные операции

Проблема 28. Приложение может читать значение из базы данных, изменять его и записывать обратно измененное значение (цикл чтения-изменения записи). При конкурентном выполнении такого цикла двумя транзакциями возникает риск потери одного из изменений: вторая операция записи не учитывает предыдущее изменение (более поздняя операция записи затирает более раннее значение).

Это так называемая  **проблема потерянного обновления** , весьма распространённая: это и увеличение счётчика или обновление баланса счета (требует чтения текущего значения, вычисления нового значения и записи обратно старого); выполнение локального изменения в составном значении -- например в JSON-документе; одновременное редактирование двумя пользователями некоторого ресурса (вики-страницы), когда каждый из них сохраняет свои изменения путем отправки на сервер всего содержимого страницы.

Решение. Во многих СУБД имеется поддержка  **атомарных операций записи** , что позволяет отказаться от циклов чтения-изменения записи. Атомарные операции реализуются путем эксклюзивной блокировки объекта при чтении, чтобы никакие другие транзакции не могли его прочитать до фиксации изменения.

## Атомарные операции

Проблема 29. При использовании ORM-фреймворков объектно-реляционного отображения можно легко написать код, выполняющий небезопасные циклы чтения-изменения-записи вместо применения предоставляемых базой данных атомарных операций.

Решение. Если функциональности встроенных атомарных операций недостаточно, можно выполнять явную блокировку предназначенных для обновления объектов на уровне самого приложения. Другим транзакциям при попытке конкурентного чтения того же объекта придется ждать завершения цикла чтения-изменения.

## Атомарные операции

Проблема 30. Атомарные операции и блокировки позволяют предотвратить потерю обновлений с помощью последовательного выполнения циклов чтения-изменения-записи. Однако на практике бывает желательно организовать конкурентную работу таких циклов.

Решение. Вполне можно обнаруживать потери обновлений автоматически: в случае обнаружения такой потери надо прервать транзакцию и принудительно повторить цикл чтения-изменения-записи. В таком случае приложению не потребуется использовать какие-то специальные возможности СУБД -- ведь можно забыть про блокировку или атомарную операцию, а обнаружение потерянных обновлений выполняется автоматически.

В СУБД, где транзакции не поддерживаются, обнаружение потерянных обновлений иногда выполняется с помощью операции **"сравнение с обменом"** (compare-and-set). Обновление объекта допускается, только если его значение не менялось с момента его прошлого чтения. При несовпадении текущего значения с прочитанным ранее обновление не выполняется, и цикл чтения-изменения-записи необходимо повторить.

### Изоляция снимков состояния (задания)

======= 22. В каких ситуациях надо избегать асимметрия чтения? (выберите неверный ответ)

[] при репликации данных

[ 1] в пользовательских онлайн-кабинетах

[ ] в OLTP

[ ] в аналитических запросах

======= 23. Изоляция снимков состояния -- это когда...

[ ] чтение может блокировать запись, запись может блокировать чтение

[1 ] чтение никогда не блокирует запись, запись никогда не блокирует чтение

[ ] чтение никогда не блокирует запись, запись может блокировать чтение

[ ] чтение может блокировать запись, запись никогда не блокирует чтение

======= 24. Многоверсионное управление конкурентным доступом - это когда...

[ ] одновременно хранятся две версии (зафиксированная и изменяемая) каждого объекта, обрабатываемого транзакциями

[1] одновременно хранится потенциально неограниченнное число версий каждого объекта, обрабатываемого транзакциями
