## Ясная Архитектура

На данном курсе мы рассмотрим на практике все ныне существующие и более-менее активно применяющиеся стили и архитектуры программирования. Под стилями будем понимать подход, в мировой практике известный как **programming in small** -- собственно программирование как оно есть (императивное, функциональное, декларативное, метапрограммирование и т. д., а так же такие концепции, как ООП, акторы, аспекты иже с ними).

Однако для построения реальных масштабных и сверхсложных систем на миллиарды пользователей знания стилей программирования оказывается совершенно недостаточно. Тут на первый план выходят совсем иные концепции, связанные прежде всего с проектированием структуры огромного количества кода таким образом, чтобы максимально снизить его сложность, уменьшить внутренние связи и в идеале избавиться от явного хранения любых промежуточных состояний. Сюда же отнесём оптимальное распределение нагрузки (на процессоры, оперативную память, диски, сеть...) между клиентами и серверами, которые могут взаимодействовать самым причудливым образом. Этот подход известен как  **programming in large** . В сумме же всех известных и реально применяемых технологических паттернов programming in small и programming in large насчитывается не так и много -- два-три десятка.

Данный курс позволяет быстро изучить на практических примерах все эти подходы -- так, чтобы сразу начать применять их в своей работе. При этом на изучение каждой технологии потребуется символическое время, 15-30 минут. Главный упор в курсе делается на постепенную сравнительность подходов, когда ключевые различия, плюсы и минусы становятся особо наглядными.

Все примеры приводятся на языке Python; синтаксис этого языка настолько прозрачен, что наверняка будет понятен всем.

**Рекомендую сохранять занятия с кодом и теорией к себе на компьютер локально, они периодически будут требоваться в дальнейших занятиях.**

### Постановка задачи

В качестве примера возьмем достаточно простую задачу дистанционного управления роботом-дворником, который скоро придёт на смену очень многим, не желающим совершенствоваться в программировании :)

Робот понимает команды Move (двигаться вперед на заданное число метров), Turn (поворот на месте на заданный угол в градусах), Set (выбрать одно из трёх устройств очистки: полив водой, полив мыльной пеной, чистка метлой), Start (включить устройство очистки) и Stop (выключить устройство очистки).

Условно говоря, мы управляем роботом с помощью некоторого простейшего **языка предметной области, domain-specific language** (DSL), это тоже один из стилей программирования, который очень любит великий Алан Кей со своей вычисляемой математикой (тысячекратная компактность кода). Это будет некоторый условный язык программирования.

Набор управляющих команд роботу -- это и есть своеобразная программа на нашем DSL, которую мы будем интерпретировать.

Входная программа управления роботом представляет собой список команд (строки), которые выполняются последовательно одна за одной. Например:

```
    'move 100',
    'turn -90',
    'set soap',
    'start',
    'move 50',
    'stop'
```

Команда set может принимать один из трёх параметров water (полив водой; исходное по умолчанию), soap (мыльная пена), brush (метла).

Программа, получая такую последовательность команд, после выполнения каждой из них выводит в консоль:
-- либо текущую позицию: POS x,y (команда move),
-- либо текущий угол поворота в градусах: ANGLE a (команда turn),
-- либо текущее состояние устройства очистки (одно из трёх): STATE water/soap/brush (команда set),
-- либо начало работы с текущим состоянием устройства очистки: START WITH water/soap/brush (команда start),
-- либо прекращение работы: STOP (команда stop).

Реализуйте такую программу любым удобным вам способом.
