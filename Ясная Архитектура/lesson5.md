### 4. Модульный стиль: возможное решение


```
import math, robot

# взаимодействие с роботом вынесено в отдельную функцию
def transfer_to_cleaner(message):
    print (message)

# главная программа
cleaner = robot.Cleaner(transfer_to_cleaner)
cleaner.make((
    'move 100',
    'turn -90',
    'set soap',
    'start',
    'move 50',
    'stop'
    ))
```

Мы вынесли определение нашего класса Cleaner из предыдущего примера во внешний модуль (файл robot.py), а в основной программе просто импортируем его. В итоге, как видно, наша программа максимально сократилась.

**Плюсы.**

Без внешних модулей (в самых разных смыслах) сегодня немыслима, наверное, вообще ни одна более-менее крупная программа. Во-первых, система разбивается на набор файлов, с которыми удобно работать -- например, группировать объекты по смыслу. Во-вторых, с помощью модульного подхода реализуется концепция стандартных библиотек, которых, например, для Python сегодня насчитываются, наверное, сотни тысяч -- как минимум, серьёзного упрощения проекта за счет общедоступного кода можно добиться для 99% прикладных задач.

**Минусы.**

Что касается всех императивных языков, для них сохраняются все недостатки, упомянутые в трёх предыдущих примерах. Да, удобство разработки с помощью внешних библиотек существенно повышается, но и оно качественно ограничено -- запутанность императивного проекта рано или поздно достигнет такой степени, что разбиение на модули его только усложнит. Но в общем случае практика разделения кода на модули приветствуется во всех стилях программирования без исключений, и конечно в функциональных языках тоже, например, присутствуют механизмы создания пользовательских библиотек и подключения внешних модулей.
