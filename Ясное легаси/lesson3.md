### Модульные тесты, и не только

Тестирование по своей сути -- фактически попытка выяснить правильность кода. Постепенно на смену этому подходу являются формальные методы верификации, но массово это случится ещё нескоро.

По традиции тестирование, отслеживающее корректность слепка/среза системы на некоторый момент времени, называется  **регрессионным** . Регрессионные тесты очень важны в том плане, что подтверждают правильность уже реализованного поведения (не на 100% конечно, обычно на 50% в лучшем случае), и быстро сообщают о его нарушении, если после внесения модификаций система сломалась.

Регрессионное тестирование в значительной степени опирается на так называемые  **юнит-тесты** .

Термин юнит-тест ( **модульный тест** , юнит-тестирование) уже давно укоренился в ИТ. Юнит-тесты выполняются обособленно от других компонентов и проверяют самые элементарные элементы:  **функции и методы классов** .


### Модульные тесты, и не только

Что важнее, или хотя бы что приоритетнее: писать юнит-тесты, проверяющие самые элементарные единицы поведения системы, или крупные тесты, охватывающие обширные функциональные участки кода?

4. Проблема. Чем глобальнее тест, тем менее он конкретен, тем дольше выполняется, и тем труднее определить, что означает его непрохождение. Для выявления конкретной причины непрохождения теста обычно приходится немало потрудиться, а при добавлении нового кода трудно придумать тест высокого уровня, проверяющий этот новый код.

Решение. Юнит-тесты весьма невелики, поэтому работают быстро; проверяют конкретную логическую единицу, в которой достаточно просто разобраться в случае ошибки; по этой же причине легко пишутся.


### Модульные тесты, и не только

5. Проблема. Если в проекте насчитывается 3000 классов (тысячи классов -- довольно типичный случай), и на каждый класс приходится по 10 тестов, то в итоге получается 30 тысяч тестов. Сколько времени потребуется для выполнения всех этих тестов в данном проекте?  **Правильная граница для времени работы одного юнит-теста -- до 0,1 секунды** . Тогда получаем около часа на один прогон всех этих тестов. Даже это довольно много, комиты в мастер в большом коллективе могут выполняться гораздо чаще.

Решение.
Во-первых, внедрить подходы CI/CD (на курсе карьеры есть вводное занятие),
во-вторых, стремиться понижать время работы юнит-тестов. Для этого надо исключить тесты, не являющиеся модульными, а именно те тесты, которые:

1. обращаются к файловой системе;
2. обращаются к базе данных;
3. взаимодействуют по сети;
4. требуют специальной настройки среды или конфигурационных файлов.


### Тестирование на более высоком уровне

6. Проблема. Тестирование моментов, связанных в частности с четырьмя особенностями, упомянутыми в предыдущей проблеме, а также проверки различных сценариев и вариантов взаимодействия подсистем из модульного тестирования исключены, но сами по себе они явно требуются.

Решение. Такие тесты безусловно полезны, но выполнять их непрерывно на сервере CI/CD -- плохая практика. Их надо запускать, когда очередной релиз уже проверен юнит-тестами и готовится для деплоя в продакшен.


### Модульные тесты, и не только (задания)

======= 7. Юнит-тесты проверяют ...

[1 ] функции и методы

[ ] пользовательские сценарии

[ ] крупные модульные блоки кода

======= 8. Правильная граница для времени работы одного юнит-теста ...

[ ] до 1 секунды

[ ] до 0,01 секунды

[ 1] до 0,1 секунды

======= 9. Выберите неправильный критерий для отсеиваиния тестов, не являющихся модульными

[1 ] регрессионные проверки

[ ] обращение к базе данных

[ ] специальная настройка конфигурационных файлов

[ ] взаимодействие по сети
