## Методологии программной разработки

Готовы ли вы надеть боксерские перчатки и выйти на ринг?

Готовы ли вы к тому, что на вас будут постоянно давить?

Готовы ли вы бесконечно спорить о семантике системы? Нанимать дорогих консультантов, которые расскажут вам, что вы делаете не так, и тренировать вашу команду, чтобы она поднялась на более высокий уровень и прошла очередную "сертификацию"?

Что ж, добро пожаловать в  **мир методологий разработки программного обеспечения** .

У нас нет тортика, но вы можете скушать печеньку на наших ежедневных совещаниях.

Пожалуй, ничто не вызывает больше споров в сообществе разработчиков, нежели выбор методологий разработки и их "реализация" в конкретной команде и конкретном проекте.

**Методологии разработки программного обеспечения определяют, как и какие рабочие процессы мы будем использовать для создания программной системы** .

Некоторые методологии довольно легковесны и дают вам просто набор принципов, которых следует придерживаться.

Другие методологии -- такие как экстремальное программирование -- наоборот чрезвычайно бдительны к деталям, и подробно объясняют вам, как именно вы должны создавать программное обеспечение и управлять всей командой.

В этом занятии мы заглянем в прошлое, и рассмотрим старую модель разработки, с которой и начиналась программная инженерия:  **водопад** , который на самом деле всё ещё используется сегодня в довольно многих организациях.

Затем мы перейдем к самой большой странности в программной инженерии -- странно (и часто очень противоречиво) определяемой методологии, известной как **agile** (гибкая, аджайл) разработка, про которую есть мем "все работают по аджайлу, но никто не делает это правильно".

Наконец, я познакомлю вас с основами того, что я считаю тремя основными "реализациями" agile, которые используются сегодня достаточно разумно и продуктивно.

Должен предупредить вас, что я не собираюсь и пытаться охватить все существующие методологии разработки программного обеспечения, которые когда-либо существовали.

Я написал на эти темы десятки статей в 2000-е годы, и это сама по себе огромная область ИТ.

Вместо этого я снова воспользуюсь своей авторской привилегией и вкратце расскажу вам о том, что, по моему мнению, вам необходимо знать.

### Традиционный водопад

Когда я начинал карьеру программиста, традиционный процесс waterfall считался само собой разумеющимся.

Именно так создавалось почти всё программное обеспечение.

Мы не называли это водопадом.

Мы не высмеивали его.

Мы просто принимали водопад как естественный способ разработки, и делали это -- ну, настолько хорошо, насколько могли.

Это не означает конечно, что не существовало других методологий разработки. Их было много, просто они не были широко известны и использовались аутентично, и многие из них были лишь более формальными способами реализации водопада.

Водопад очень похож на то, как он звучит. Это  **создание программного обеспечения по одному целостному логическому шагу за раз** , причем каждый шаг опускается на следующий более низкий уровень, пока весь проект не окажется внизу.

Ну или наоборот, планомерно поднимаемся к вершине step-by-step, но поток воды через ступени оказался более наглядным.

Методология водопада базируется на понятии  **жизненного цикла разработки программного обеспечения (Software Development Life Cycle, SDLC)** .

SDLC проявляется практически в каждой методологии.

В водопаде SDLC развивается последовательно.

Фактически, можно сказать, что  **водопад -- это просто пошаговое следование SDLC** , не более того.

### SDLC -- это истина?

Хороший вопрос.

SDLC -- это последовательность этапов создания проекта, которая начинается с анализа требований, проектирования, реализации, тестирования, развертывания, сдачи в промышленную эксплуатацию, и, наконец, сопровождения.

**Вы проходите через каждую фазу и двигаетесь только вперед, никогда не возвращаясь назад** .

Фазы могут частично совпадать и накладываться друг на друга, но выполняются они **всегда однократно** на протяжении всего проекта.

Давайте вкратце обсудим каждую фазу, чтобы получить представление о SDLC.

**Анализ требований**

На этом этапе вы собираете все требования заказчика к будущему программному продукту.

Что он должен делать? Какие функциональные возможности он должен иметь?

Как он должен выглядеть?

Как он должно себя вести?

Вы можете собрать эту информацию, поговорив с заказчиками или клиентами, или просто придумать её самостоятельно, но вам в любом случае -- что вроде бы очевидно -- нужно хотя бы немного знать, что вообще вы собираетесь создавать, прежде чем вы начнёте это делать. (Хотя, по мере того, как вы будете входить в мир ИТ, если вы еще этого не сделали, вы быстро поймете, что на самом деле это далеко не так).

**Проектирование (проектный дизайн)**

Теперь, когда вы собрали все требования к системе (они часто называются  **техническое задание, ТЗ** ), которую вы пытаетесь создать, пришло время выяснить, как именно вы собираетесь её строить.

На этом этапе вы берете эти требования и превращаете их в набор высокоуровневых абстракций, архитектуру, набор подсистем, низкоуровневые алгоритмы, диаграммы и схемы на листочках (если хотите), и в целом решаете, как именно система будет построена и как именно её подсистемы будут согласованно работать вместе.

Уровень детализации проектирования -- вечный предмет споров, но некоторый уровень проектирования всегда необходим.

Как именно правильно проектировать системы любого масштаба, я подробно рассказываю на соответствующих курсах.

В традиционном водопадном подходе обычно используется так называемое  **большое предварительное проектирование** , что означает, что на этом этапе большинство деталей сразу планируется на очень низком уровне.

Если вы собираетесь всегда идти только вперед, и никогда не возвращаться назад, и у вас есть жёсткий график работ, то проектирование всего заранее кажется разумным шагом; но в реальности требования к проекту постоянно меняются, и возникает так много непредвиденных обстоятельств, что это редко срабатывает.

Вроде бы водопад выглядит на первый взгляд очень разумно, правда? Есть чёткие логически последовательные шаги, и мы по ним планомерно проходим.

Это ожидание, а реальность и  **самый главный недостаток водопада -- попытка спроектировать практически всё с самого начала, (ошибочно) полагая, что ТЗ не изменится** .

**Реализация**

Ok, ну вот и пришло время писать код.

Здесь вы превращаете проектный дизайн, созданный на предыдущем этапе, в реальный рабочий код.

Я не думаю, что не нужно говорить об этом больше, так что... идём дальше...

**Тестирование**

Итак, у вас есть прекрасный кусок кода, который элегантно спроектирован, идеально реализован и сияет как тысяча солнц.

Затем приходит какой-то седовласый тестировщик и разрушает всё это, показывая вам, как сильно вы отклонились от требований и что на самом деле ничего из вашего кода не работает так, как должно.

Это и есть фаза тестирования.

Тестировщики тайно готовили свои планы тестирования, писали свои тестовые сценарии и готовились к этому моменту с той самой секунды, когда они впервые увидели, как вы радостно смеётесь за своим столом, наслаждаясь написанием кода -- никто не должен быть настолько счастлив.

Теперь тестировщики прогоняют свои тесты, находят ошибки, и после дебатов и многочисленных споров вы исправляете как можно больше из них, пока все в команде не согласятся, что пора двигаться дальше.

**Развёртывание**

Теперь пришло время проверить, работает ли ваше детище на самом деле.

Если у вас есть несколько компонентов системы, которые были разработаны отдельно, вы соединяете их вместе и называете этот этап "интеграцией", но в любом случае вы должны задеплоить проектный код. Выставить его на всеобщее обозрение.

Это может означать развертывание кода на сервере, а затем нервное щелканье выключателем, и чей-то голос: "Работаем!".

Это может означать создание флешки с золотым дизайном, которую вы будете рассылать всем своим клиентам.

Это может означать загрузку вашей программы на облачный хостинг или в популярный маркет приложений.

В любом случае, теперь вы передаёте программное обеспечение (и все ваши надежды и мечты) в руки клиента.

Удачи.

Надеюсь, вы действительно пофиксили те ошибки...

**Сопровождение**

Ага, вы думали, что закончили с проектом, когда запустили его в эксплуатацию и отправили сообщения со ссылкой своим клиентам?

Вы уже взялись за следующую эпическую вещь?

Не так быстро.  **Большинство проектов находятся на этапе сопровождения дольше, чем на любом другом этапе** .

Когда система вышла на рынок, вы всё равно должны её поддерживать.

Теперь вы будете исправлять ошибки, которые находят занудные клиенты, добавлять новые функции и поддерживать всё в рабочем состоянии.

Этот этап длится до тех пор, пока программное обеспечение хоть как-то используется, и его надо поддерживать.

И это -- всё, что действительно есть в SDLC: **получить требования, спроектировать систему, запрограммировать её, протестировать, развернуть, и поддерживать** до тех пор, пока компания не выйдет из этого бизнеса, или пока какому-нибудь молодому джуниору не придет в голову идея начать всё заново и переписать с нуля.

### Agile-разработка

Agile-парадигма действительно внесла большие перемены в разработку программного обеспечения.

До появления аджайла большинство ИТ-проектов использовали некий водопадный процесс разработки, независимо от того, признавали они это или нет.

Я имею в виду, что они последовательно создавали систему, переходя от одной фазы SDLC к другой.

Хотя некоторые проекты использовали итеративные подходы еще до появления движения Agile, и разбивали SDLC на более мелкие циклы, эта идея не была формализована и столь массова и популярна, как сегодня.

Так что же такое Agile?

Даже спустя годы после его появления мы до сих пор не знаем точно.

Agile немного аморфно. Чтобы понять причину этого, нужно разобраться в истории.

### Манифест Agile

Группа известных ИТ-специалистов, представляющих различные методологии разработки, собралась вместе с корпоративными лидерами, чтобы попытаться найти точки соприкосновения в вопросе, как должна вестись продуктивно разработка программного обеспечения.

Первоначальная группа состояла из 17 человек, которые обсуждали разные проблемы, влияющие на разработку, и они сформировали то, что известно как  **Манифест Agile** , с которым вы можете ознакомиться тут:
[agilemanifesto.org/iso/ru/manifesto.html](https://agilemanifesto.org/iso/ru/manifesto.html)

**Люди и взаимодействие важнее процессов и инструментов.
Работающий продукт важнее исчерпывающей документации.
Сотрудничество с заказчиком важнее согласования условий контракта.
Готовность к изменениям важнее следования первоначальному плану.
То есть, не отрицая важности того, что справа, мы всё-таки больше ценим то, что слева.**

И 12 принципов, которые, полагаю, лучше показывают, что на самом деле представляет собой Agile, нежели сам Манифест:
[agilemanifesto.org/iso/ru/principles.html](https://agilemanifesto.org/iso/ru/principles.html)

### Agile -- это не методология

Итак, вы наверное уже поняли, что Agile не является собственно методологией, а скорее  **определяет на очень высоком уровне, как должна вестись разработка программного обеспечения** . Agile -- своего рода родитель других методологий, которые считаются гибкими по своей природе.

Agile сформулировала важный принцип, что  **программное обеспечение должно разрабатываться и поставляться постепенно** , и приняла тот факт, что  **проектные требования могут и должны меняться в процессе разработки системы** .

Agile также переосмыслила отношения между различными членами команд разработчиков, отдавая предпочтение  **общению лицом к лицу и самоорганизующимся командам** , а не массивной документации и строгим протоколам.

Как я уже говорил, некоторые организации уже делали некоторые из этих вещей и следовали методологиям, которые охватывали один или несколько принципов Agile -- но в большинстве своём мир в целом всё ещё разрабатывал программное обеспечение с помощью традиционного водопадного подхода.

### Проблемы с наследием водопада

Прежде чем мы рассмотрим несколько популярных Agile-методологий, давайте немного поговорим о том, почему водопадный подход хорошо смотрится на бумаге, но не очень хорошо, мягко говоря, работает в реальности.

Одна из самых больших проблем водопада заключается в том, что  **в реальной жизни проектные требования постоянно меняются, а многие из них вообще становятся известны только на поздних этапах проекта** .

Если вы решите использовать пошаговый подход к разработке программного обеспечения, и попытаетесь получить все требования от заказчика заранее и сразу создать итоговое ТЗ, это не сулит вам ничего хорошего, если вдруг эти требования изменятся, или появятся новые. А такое случится обязательно.

Когда вы уже полностью разработали архитектуру системы, и вам вдруг понадобилось что-то в ней серьёзно изменить, а вы находитесь в процессе реализации проекта, вам придется отбросить довольно много из того, что вы уже сделали (а может быть, и вообще всё), и вернуться назад -- либо поставить точку и сказать "нет".

Таким образом,  **либо проект срывается, либо вы создаете не то, что нужно, и злите заказчика** .

Любой разработчик мечтает, чтобы в ТЗ ничего не менялось.

Было бы здорово, если бы мы могли пойти и собрать заранее все требования к проекту, а затем разом реализовать их.

Но в жизни так не бывает.

На самом деле, Agile -- это прежде всего признание этого факта, полное принятие его, и  **построение процессов разработки так, чтобы они продуктивно работали с этим ограничением, а не против него** .

Это и есть Agile.

### Scrum

Теперь давайте поговорим о некоторых популярных методологиях разработки Agile.

Я не собираюсь рассматривать их все -- честно говоря,  **большинство команд, которые утверждают, что следуют одной из этих методологий, на самом деле не следуют им даже близко** .

Они следуют им формально по названию, но не по сути и не на практике.

Большинство команд делают то, что я бы классифицировал как некоторую Agile-подобную, самопальную, довольно кривую и слабо эффективную методологию разработки.

Так где же здесь Scrum?

Scrum создали программисты Кен Швабер и Джефф Сазерленд в начале 1990-х, наблюдая за командными тренировками военного спецназа.

В 1995 году они выпустили совместный документ, в котором определили методологию Scrum, объединив два своих подхода.

Scrum -- это формализованная и строгая методология, которая чётко определяет конкретные роли в команде разработчиков, сам процесс разработки, и формат конкретных совещаний (так называемые митинги), которые должны проводиться на каждой итерации разработки, также известной как спринт.

**Роли в Scrum**

В Scrum приняты три роли.

Первая -- **владелец продукта (product owner)** выступает в качестве представителя заказчика и в конечном итоге определяет приоритеты работы, а также взаимодействует с остальными заинтересованными сторонами и клиентами.

**Команда разработчиков** не только пишет код, но и выполняет анализ, проектирование, тестирование и все другие задачи, связанные с созданием программного продукта.

Наконец, **Scrum-мастер** действует как тренер команды, помогая устранять любые препятствия, замедляющие коллективную работу, общаясь с владельцем продукта и поддерживая требования процесса Scrum.

**Как Scrum работает**

Основная идея Scrum заключается в том, что  **разработка разбивается на мелкие итерации, называемые спринты, на которые приходится определенный фиксированный объем работы. Результаты передаются заказчику в конце каждого спринта** .

Все фичи, которые должны быть реализованы, собираются вместе в так называемый **бэклог продукта** (по сути, это требования к системе).

**Бэклог продукта ранжируется по приоритетам** , и во время каждого спринта создаётся  **бэклог спринта** , в который отбирается определенный набор задач из общего бэклога проекта -- для работы над ними в течение очередного спринта, который обычно длится  **одну-две недели** .

В начале каждого спринта проводится  **совещание по планированию** , на котором задачи "помещаются" в текущий спринт, и команда оценивает уровень усилий по завершению бэклога.

Технически,  **команда должна взять на себя обязательство выполнить все задачи бэклога в течение спринта** , но я неоднократно замечал, что на практике это происходит редко (принятие реальных обязательств -- это трудно).

**Каждый день проводится быстрое совещание, называемое "дэйли" (daily scrum) или "митинг"** , на котором каждый участник даёт очень быстрый отчет.

Идея дэйли заключается в том, чтобы держать всю команду в курсе событий и устранять любые препятствия, которые могут замедлять прогресс.

**Дэйли проходит каждый день в одно и то же время в одном и том же месте, и каждый член команды отвечает на три вопроса** :

- Что вы сделали вчера для продвижения команды к цели спринта?
- Что вы сделаете сегодня для продвижения команды к цели спринта?
- Есть ли какие-либо препятствия, которые мешают вам или команде достичь цели спринта?

По моему опыту,  **довольно полезно уточнять личные обязательства на втором вопросе** .

Так, я бы изменил его на  **"Что вы обязуетесь сделать сегодня для продвижения команды к цели спринта?"** .

Я обнаружил, что такое тонкое изменение довольно сильно меняет ситуацию.

Во время спринта команда работает вместе, чтобы завершить все пункты бэклога спринта, и для отслеживания прогресса и скорости завершения пунктов бэклога обычно используется так называемая  **диаграмма сгорания** .

В сводной таблице отслеживаются оставшиеся часы и различные типовые характеристики рабочего процесса и объёма усилий, используемые обычно для отслеживания работы, оставшейся в спринте.

**По окончании спринта проводится обзор** , на котором заинтересованным сторонам демонстрируется новая функциональность, полностью реализованная в течение спринта.

Наконец, проводится  **ретроспективное совещание** , на котором команда анализирует прошедший спринт и разрабатывает идеи для улучшения работы на следующем спринте.

### Проблемы Scrum

Когда Scrum выполняется правильно и точно, он становится чрезвычайно эффективной и ценной методологией разработки программного обеспечения.

К сожалению, я обнаружил, что в реальности требованиям Scrum часто следуют не очень тщательно, и допускается много послаблений, чтобы компенсировать провалы или попытаться "обыграть" методологию.

И к сожалению, есть одна самая главная причина того, что Scrum-команды не достигают успеха, который они могли бы получить.

**Ответственность. Обязательства.**

Опытные Scrum-мастера, тренировавшие многие организации самого разного размера, отмечают, что самое первое, что обычно убивает успешное внедрение Scrum -- это отсутствие ответственности -- как со стороны команды в целом, так и на личном уровне каждого разработчика.

Очень легко записать элементы бэклога в спринт и договориться о том, что они будут выполнены, если всё пойдет хорошо и по плану.

Но в жизни так не бывает.

**Что-нибудь обязательно пойдёт не так.**

Гораздо сложнее взять на себя обязательства по выполнению запланированных работ.

Без такой концепции обязательств стандарты труда сильно снижаются, и спринт теряет смысл, потому что работа, заложенная в спринт, превращается в несбыточную мечту.

Это очень похоже на составление списка дел, которые вы собираетесь сделать за день, каждый день вы стараетесь сделать всё, что в ваших силах, но в подавляющем большинстве случаев не успеваете завершить запланированное.

В результате сам список to-do со временем теряет смысл, и вы начинаете задаваться вопросом, зачем он вообще нужен.

**Гораздо эффективнее брать на себя обязательства, которые вы выполняете в 99% случаев, потому что тогда вы можете доверять себе** .

Я мог бы еще много говорить на эту тему из своего опыта, но, думаю, вы поняли суть.

### Проблемы с вариациями Scrum

Очень часто (почти всегда) команда заявляет, что придерживается Scrum, а затем, при более детальном разборе, выясняется, что они приводят длинный список исключений из процесса Scrum.

Затем они придумывают всевозможные оправдания, почему они делают всё по-своему, вместо того чтобы просто следовать этому процессу так, как он был написан и проверен на сотнях компаний самого разного размера!

А знаете, почему они так делают? Потому что  **в список своих исключений они включают именно самые болезненные моменты Scrum, чтобы обойти боль в рабочем процессе Scrum -- ту самую боль, которая и делает его столь эффективным** .

Это похоже на то, как если бы вы пытались приготовить что-то на плите. Вы включаете плиту, она становится горячей, и вы обжигаете руку, потому что не использовали прихватку для ручки сковороды. Тогда вы говорите: "Знаете что, мне очень нравится готовить на такой плите, но вот только эта раскалённая жара никуда не годится. Давайте будем готовить на плите, но не станем разогревать её".

Если бы вместо этого вы сказали: "Хм... ручка этой сковороды горячая, в следующий раз стоит взять прихватку ", вы бы добились гораздо большего прогресса.

Но, увы, большинство команд разработчиков, пытающихся внедрить Scrum, просто выключают огонь, и потом удивляются, почему их еда никак не приготовится.

### Канбан

В то время как Scrum -- достаточно формализованная и строгая методология (по крайней мере, в отношении рабочего процесса и структуры команды) -- Kanban по стилю отличается существенно.

В чём-то он, конечно, и похож, как и все аджайлы, но это гораздо более свободная методология, основанная скорее на принципах, нежели на инструкциях.

[Обзор Канбана на хабре](https://habr.com/ru/post/230725/)

Канбан берет свое начало в производственной системе Toyota, в парадигме  **бережливого производства** .

Изначально он был создан как  **способ разумно ограничить объемы работы в производстве** , что привело к повышению эффективности и уменьшению складских запасов.

Когда Канбан применяется в ИТ-разработке, он в первую очередь ориентирован на так называемую Канбан-доску.

**Канбан-доска** -- это обычная доска (например, c магнитиками) с несколькими столбцами, которые представляют собой различные этапы работы над проектом.

Идея заключается в том, чтобы **сделать видимой всем всю работу над проектом и ограничить общий объём работы, выполняемой "одновременно", в данным момент** (объём незавершенной работы, WIP), чтобы оперативно выявлять и ликвидировать узкие места.

Как и Scrum, Канбан основан на идее самоорганизующихся команд, которые, подразумевается, многопрофильные.

Канбан легко применяется к существующим системам и процессам, выступая как способ формализации и визуализации потока работы в этих системах на Канбан-доске.

Канбан в значительной степени ориентирован на  **идею непрерывного совершенствования через петлю обратной связи** .

Не существует определенного способа, которым команды разработчиков должны использовать Канбан, поэтому он варьируется от команды к команде.

Как правило, можно ожидать, что у команды имеется некий бэклог, список работ, которые необходимо выполнить, и эти работы расставлены по приоритетам.

Затем кто-то из команды берет новую работу (задачу) с максимальным приоритетом, которую необходимо выполнить, и добавляет ее на Канбан-доску.

Задача перемещается по доске по мере своего продвижения от этапа к этапу.

Возможно, сперва будут этапы анализа и проектирования, затем -- переход к разработке, затем к тестированию и, наконец, к деплою -- но вполне могут быть и различные промежуточные этапы, или другие способы организации работы.

Я всегда был большим поклонником Канбана.

На самом деле, я сам использую некоторую разновидность Канбана для большей части своей работы, включая написание этого курса.

Но я всегда чувствовал, что процесс должен быть более структурированным.

Сейчас все мои задачи ведутся в органайзерах, где ранжируются по приоритету, по цветам и т. п.

Идея в том, чтобы создать немного больше структуры и больше формальных принципов как по рабочему процессу в целом, так и непосредственно по процессу разработки.

Для этого я например интегрировал Канбан и  **GTD (Getting Things Done)** .

### Экстремальное программирование (XP)

Последняя Agile-методология, которую мы обсудим в этом разделе, с одной стороны, одна из самых моих любимых, а с другой -- одна из самых отрицаемых, потому что она хорошо формализована и способствует чрезвычайно высокому уровню профессионализма и строгости в разработке, но довольно тяжела к применению.

**Экстремальное программирование (XP)** было создано Кентом Беком в 1996 году; в 1999 году он выпустил свою первую книгу с подробным описанием этого процесса -- "Extreme Programming Explained".

XP взяла многие из лучших практик на то время -- модульное тестирование, TDD, ООП, фокус на поставке высокого качества клиенту -- и подняла их на такой уровень, который некоторые люди назвали экстремальным, отсюда и название.

Из-за своего экстремально строгого характера она так и не получила широкого распространения, хотя некоторые команды практикуют её и сегодня. Гораздо более распространен -- нет, не Канбан, как ни странно -- а Scrum, ну или, по крайней мере, его вариации (см. выше).

XP, как и другие методологии Agile, поддерживает концепцию постоянных изменений и использует короткие циклы разработки -- итерации, чтобы поддерживать эволюционные изменения в проекте с течением времени.

Процесс разработки XP сосредоточен вокруг чрезвычайно сфокусированного набора принципов.

Последователи XP планируют, над чем они собираются работать - во многом подобно Scrum - и затем назначают различные задачи, которые должны быть выполнены.

Когда задача фактически выполнена, начинается тестирование.

Приёмочные тесты определяют критерии, которые должна пройти рабочая задача, чтобы считаться завершённой.

Перед написанием реального кода готовятся модульные тесты, которые определяют, как именно должен работать код в различных обстоятельствах (см. занятие по TDD).

XP также в значительной степени опирается на идею парного программирования -- когда два разработчика сидят вместе за одним компьютером, и совместно работают над всем создаваемым в проекте кодом.

Цель всегда состоит в том, чтобы разрабатывать и реализовывать задания как можно проще, учитывая прежде текущие потребности проекта, а не планы на будущее.

Идея заключается в том, что код будет развиваться для решения более сложных ситуаций естественно -- по мере их возникновения; не надо пытаться преждевременно оптимизировать его или стараться обеспечить дополнительную гибкость, которая часто достигается ценой существенно большей сложности.

Концепция коллективного владения кодом и единых стандартов кодирования очень важна для практики XP.

XP также строго предписывает, чтобы ни один разработчик не трудился над проектом сверхурочно.

XP вызывает много критики, и ей очень трудно следовать правильно и целостно, если команда не предана принципам и практикам этой методологии.

Постороннему человеку XP может показаться каким-то культом или сектой программирования.

Но я должен сказать, что мне лично нравится XP, и я считаю её чрезвычайно эффективной при условии правильного и точного применения.

Но всегда очень трудно убедить менеджеров и команду полноценно принять этот процесс, потому что XP дискомфортна и при неумелом применении или с нарушениями (например, игнорирование правила отказа от любой переработки) быстро приводит к выгоранию.

### Другие методологии разработки, а также не-методологии

Давайте будем честными: подавляющее большинство команд, в которых вы работали или будете работать, либо будут заявлять, что придерживаются какой-то методологии -- но на самом деле по существу следовать ей не будут, либо будут делать вид, что вообще не следуют никакой формальной методологии, что на самом деле означает, что они изобрели кривой велосипед с квадратными колёсами, и пытаются на нём куда-то ехать.

Раньше меня это очень расстраивало.

Я проповедовал о ценности буквального следования Scrum до буквы или о преимуществах реального, а не показушного, внедрения XP.

Когда я работал журналистом, я спрашивал в десятках ИТ-компаний: "Какую методологию вы используете для разработки?". И когда в серьёзной организации я получал ответ "у нас ничего такого нет", это выводило меня из себя.

Но со временем я понял, что  **конкретная методология не так важна, как наличие в компании повторяемого и объективно измеряемого процесса, который может развиваться и адаптироваться** .

По этому поводу упомяну  **модель зрелости программных процессов Карнеги-Меллона CMM** , которая не требует использования какой-то конкретной методологии из готового списка, однако подразумевает, что компания постоянно трудится над развитием своих внутренних процессов: [vk.com/wall-152484379_1409](https://vk.com/wall-152484379_1409)

Прекрасно, если ваша команда использует Scrum и совершенствуется в его применении.

Но также здорово, если ваша команда берет что-то из Scrum, что-то из Канбана и XP, и делает из них свой собственный процесс, который хорошо работает -- при условии, что такой процесс действительно есть, он формализован, описан в документации, и по нему проводится регулярная рефлексия.

Это ключевой момент.  **Повторяющийся, улучшающийся и чётко определённый процесс** .

Рассмотрим несколько заключительных моментов.

Во-первых,  **формально определённый процесс разработки более важен, нежели конкретная методология** .

А во-вторых, если методология в этом списке не была указана, это совсем не значит, что она не подходит для использования командами разработчиков.

Это короткий материал, поэтому вместо того, чтобы пытаться охватить все существующие методологии разработки -- а их множество -- я постарался дать вам базовое понимание тех методологий, которые, по моему мнению, сегодня используются в большинстве компаний -- ну или элементы которых наиболее часто заимствуются для построения собственных процессов.
