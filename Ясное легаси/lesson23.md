### В легаси-системе полно слишком крупных классов

70. Проблема. Когда класс крупный, его "пользователи" редко пользуются всеми методами -- как правило, разные группы методов класса используются тоже, соответственно, разными группами клиентов (разными типами клиентских сущностей).

Решение. В идеале, под каждую группу связанных методов лучше создать отдельный класс. Но если в легаси-проекте это затруднительно, оформите явно внутри большого класса свой отдельный интерфейс (хотя бы на уровне комментариев и размещения методов в коде) для каждой из этих групп, что поможет инкапсулировать данные и уменьшит зависимость.


### В легаси-системе полно слишком крупных классов

71. Проблема. Иногда под новую задачу приходится слишком сильно переделывать некоторую существующую конкретную функцию или метод.

Решение. Скорее всего, вы выявили отдельную ответственность, которую следует извлечь и оформить как независимую сущность.


### В легаси-системе полно слишком крупных классов

72. Проблема. Что делать при выявлении новых "ответственностей"?

Решение. В идеале, конечно, желательно все их оформлять в виде отдельных компонентов, но далеко не всегда на это имеется время. Кроме того, это обычно рискованно: на период реорганизации система становится неустойчивой, даже если разработчики действуют осторожно и пишут хорошие тесты.

Самый лучший подход к разделению классов на части в проекте такой:

- выявите все виды ответственности;
- убедитесь, что они понятны и принимаются всеми остальным разработчиками;
- разделите соответствующие классы на части так, чтобы риск от изменений распределялся равномерно по всем новым создаваемым частям.


### В легаси-системе полно слишком крупных классов

73. Проблема. SRP хорошо воплощается на уровне реализации (извлекаем новые классы из крупного существующего класса). Однако на уровне интерфейса крупного класса это труднее: требуется вносить изменения также и в клиенты изменяемого класса, и тестировать их.

Решение. Начинать в таком случае лучше с реорганизации самого крупного класса не в плане его разделения на новые части, а в плане приведения его реализации к требованиям SRP. В результате, скорее всего, и интерфейс этого класса естественно приблизится к формату единственной ответственности.


### Когда класс крупный (задания)

======= 61. Когда класс крупный ...

[ ] группируем его методы в интерфейсы

[ 1] группируем его методы в отдельные классы

[ ] группируем его методы внутри родного класса

======= 62. Что делать при выявлении в реализации класса новых "ответственностей"?

[ 1] равномерные разделяем класс на классы/компоненты

[ ] приводим реализацию класса к SRP

======= 63. Что делать при выявлении в интерфейсе класса новых "ответственностей"?

[ ] равномерные разделяем класс на классы/компоненты

[ 1] приводим реализацию класса к SRP
