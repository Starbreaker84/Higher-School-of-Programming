### 5. Функциональный стиль

Рассмотрим версию нашей программы, выполненную в функциональном стиле.

```
import math
from collections import namedtuple

RobotState = namedtuple("RobotState", "x y angle state")

# режимы работы устройства очистки
WATER = 1 # полив водой
SOAP  = 2 # полив мыльной пеной
BRUSH = 3 # чистка щётками


# взаимодействие с роботом вынесено в отдельную функцию
def transfer_to_cleaner(message):
    print (message)

# перемещение
def move(transfer,dist,state):
    angle_rads = state.angle * (math.pi/180.0)   
    new_state = RobotState(
        state.x + dist * math.cos(angle_rads),
        state.y + dist * math.sin(angle_rads),
        state.angle,
        state.state)  
    transfer(('POS(',new_state.x,',',new_state.y,')'))
    return new_state

# поворот
def turn(transfer,turn_angle,state):
    new_state = RobotState(
        state.x,
        state.y,
        state.angle + turn_angle,
        state.state)
    transfer(('ANGLE',state.angle))
    return new_state

# установка режима работы
def set_state(transfer,new_internal_state,state):
    if new_internal_state=='water':
        self_state = WATER  
    elif new_internal_state=='soap':
        self_state = SOAP
    elif new_internal_state=='brush':
        self_state = BRUSH
    else:
        return state  
    new_state = RobotState(
        state.x,
        state.y,
        state.angle,
        self_state)
    transfer(('STATE',self_state))
    return new_state

# начало чистки
def start(transfer,state):
    transfer(('START WITH',state.state))
    return state

# конец чистки
def stop(transfer,state):
    transfer(('STOP',))
    return state


# интерпретация набора команд
def make(transfer,code,state):
    for command in code:
        cmd = command.split(' ')
        if cmd[0]=='move':
            state = move(transfer,int(cmd[1]),state) 
        elif cmd[0]=='turn':
            state = turn(transfer,int(cmd[1]),state)
        elif cmd[0]=='set':
            state = set_state(transfer,cmd[1],state) 
        elif cmd[0]=='start':
            state = start(transfer,state)
        elif cmd[0]=='stop':
            state = stop(transfer,state)
    return state
```

```
# главная программа

# начальное состояние
state = RobotState(0.0, 0.0, 0, WATER)

# конвейер
make(
    transfer_to_cleaner,
    (
    'move 100',
    'turn -90',
    'set soap',
    'start',
    'move 50',
    'stop'
    ), 
    state)
```


Ключевое, принципиальное отличие функционального подхода от ранее рассмотренных императивных и объектных подходов -- это  **работа с иммутабельными (неизменяемыми) состояниями** . У нас имеется набор функций, которые получают на вход некоторое состояние, и возвращают всегда новое состояние (пусть даже его содержимое неотличимо от входного), никак не меняя исходное. Таким образом мы можем свободно комбинировать функции, не задумываясь о побочных эффектах и внутренних состояниях, организовывать конвейерную обработку, и тестировать функции самыми разными способами.

Для удобства задействуем так называемые именованные кортежи -- простенькая версия структур в Python, чтобы не создавать специальный класс для хранения состояния. RobotState -- это наша "структура" с четырьмя полями x,y, angle и state (можно при желании использовать и обычный словарь, но его использование немного усложняет код). Каждая из функций move, turn, set_state, start и stop получают в качестве параметров функцию, формально отвечающую за взаимодействие с роботом, при необходимости -- дополнительный параметр расчёта, и последним параметром -- входное состояние. Задавать состояние в конце списка аргументов -- это такой типичный стиль ФП, имеющий довольно глубокие основания.

Внутри функций мы создаём новое состояние, рассчитывая его на основании входного состояния.

Комбинировать функции можно по-разному -- например, просто организуя вложенную цепочку вызовов:

```
  set_state(transfer, SOAP,
  turn(transfer, -90,
  move(transfer, 100, state)
))
```

Недостаток такого подхода, очевидно, прежде всего в необходимости императивной записи вызовов от конца к началу.
Функциональный дух подразумевает, что функции комбинируются друг с другом с помощью  **конвейера** , который позволяет простым способом передавать выход одной функции на вход другой. В функциональных языках имеются специальные механизмы для поддержки подобного синтаксического сахара, то есть код мог бы выглядеть условно так:

```
move | turn | set_state | ...
```

Хотя нередко применяется и обратная форма, когда передача состояния происходит справа налево:

```
... <| set_state <| turn <| move
```

В нашем примере мы не можем просто так передавать состояние по конвейеру, потому что наши функции имеют несколько аргументов, причём их перечень может различаться. Чтобы избежать этой незадачи, введена концепция монады, которая будет рассмотрена отдельно.

Реализацию конвейера берёт на себя функция make. Она просто сохраняет очередное состояние, и передаёт его на вход следующей функции.

**Плюсы.**

Реализация проста и наглядна для понимания.

Код больше не завязан на глобальные состояния переменных или полей объекта, и его легко тестировать. В силу того, что состояние всегда подаётся только на вход цепочки вычислений, мы можем быстро смоделировать практически любую ситуацию.

Функции не допускают побочных эффектов и, в частности, могут использоваться и в других задачах (за подобный полиморфизм отвечают специальные механизмы функционального программирования). Например, мы можем создать функцию-повторитель, которая, автоматически комбинируя функции-примитивы, рисует щёткой узоры по некоему алгоритму. Кроме того, в записи нашего кода мы приближаемся к математической нотации.

**Минусы.**

Состояние приходится по-прежнему сохранять в локальных переменных внутри make() для имитации работы конвейера.

Сама реализация конвейера подразумевает скорее императивный стиль со всеми его недостатками.
