## Общая схема построения объектно-ориентированной программы

Данная тема напрямую относится к **проектированию -- созданию гибкой, надёжной, легко расширяемой системы классов.** Мы познакомимся с базовыми правилами проектирования, потому что процесс успешного формирования АТД в программе в любом случае тесно связан с ключевыми принципами проектирования.

Придерживаемся следующих правил проектирования программы:

**1) Система типов основана только на классах.**

Каждый тип данных в системе должен быть основан на конкретном классе. В общем случае вокруг понятий "тип" и "класс" ведётся множество обсуждений, мы пока считаем, что в общепринятом программистском смысле эти понятия эквивалентны.

Фактически, в самых популярных языках программирования со статической типизацией все типы данных и задаются классами. В других языках базовые типы данных (числа, строки, ...) из соображений эффективности реализованы не как экземпляры классов, а как непосредственные "наивные" значения. Однако чаще всего числа и строки скрыты за соответствующими классами стандартных библиотек, а эффективная реализация возложена на компилятор.

В системе всегда имеются какие-то смысловые сущности моделируемой предметной области (автомобиль, кот, гном, банкомат, ...): их правильному выявлению и выделению из требований (декомпозиции) посвящён отдельный курс. Эти сущности иногда можно представить, закодировать даже простым целым числом (перечислением значений) или форматированной строкой -- например, дни недели, или месяцы в году, но всё равно лучше их реализовывать в виде классов и обрабатывать с помощью явно определённого набора операций, как полагается для АТД.

Итак, вся система типов в проекте основывается исключительно на классах. Очень желательно в виде классов определять и базовые типы (числа, строки, ...), иначе в системе будет множество плохо формализуемых частных случаев и ограничений.

**2) Вычислительная модель ООП -- это набор равноправных классов и сигма-исчисление.**

Программа как система -- это набор равноправных классов.

В этой системе нету главных и подчинённых структур управления вычислениями, и нету автономных функций, которые не принадлежат никаким классам.

Для выполнения вычислений разрешается вызывать только методы этих классов. Когда мы говорим "методы классов", подразумевается конечно, что в реальной работе вызываются методы реализующих эти классы объектов.

**Методы -- это единственная форма общения между классами**. В некоторых языках программирования такую форму называют также обменом сообщениями между классами. Например, метод Substring() класса String -- это по сути отправка сообщения Substring(...) (извлечь подстроку по таким-то параметрам) конкретному экземпляру класса String.

*В формальной математической модели ООП (так называемое **сигма-исчисление**) все вычисления выполняются только с помощью минимального набора операций: вызов метода объекта, присваивание, условный выбор и цикл, которые есть в любом императивном языке. На этом наборе с небольшими дополнениями (наследование, полиморфизм) в целом основано и ОО-проектирование. Поэтому изучать все эти темы можно совершенно независимо от конкретного языка программирования.*

**3) Активно применяем обобщённые типы.**

Правильное использование АТД подразумевает активное применение такого механизма, как обобщения, обобщённые или универсальные типы (generics).
**Обобщения -- это по сути параметризованные типы**, когда мы задаём дополнительный тип, с которым должен уметь работать основной тип.

*Когда мы создаём обобщённые классы, мы по сути определяем не тип данных, а шаблон типа, который потенциально задаёт бесконечное множество конкретных типов.*

Например, если у нас есть контейнер Stack, то желательно, чтобы он единообразным способом работал и с числами, и со строками, и с объектами любых пользовательских классов, причём никаких дополнительных реализаций или расширений класса Stack делать бы не потребовалось. Это достигается указанием дополнительного типа T как параметра: Stack<T>. В таком случае реализация Stack будет одинаково работать практически с любыми доступными типами в системе -- при условии, что они отвечают некоторым стандартным требованиям (например, наследованию от самого базового стандартного класса).

В процессе проектирования надо учитывать такую абстракцию обобщения как **универсальный АТД с параметризацией**, который может быть и рекурсивным (когда тип-параметр -- этот же АТД).
Например, мы хотим определить такой тип данных, как стек стеков. В таком случае корректнее говорить про шаблон АТД.

На тип-параметр могут накладываться ограничения на допустимые операции (например, обязательно требуется отношение упорядоченности). Так, если определён обобщённый класс Stack с типом-параметром T -- Stack<T>, то в каких случаях мы можем создавать стеки стеков? Это зависит от ограничений, которые мы накладываем на тип T. В любом таком случае класс Stack должен быть совместим с родительским типом для T (так как он поступает самому себе как параметр).

*Для языков с динамической типизацией (например, Python) параметризация типом не требуется, в них обычно уже стандартно поддерживается работа со списками объектов самых разных типов.*

**4) По возможности применяем статическую типизацию.**

Объектно-ориентированное проектирование в существенной степени опирается на статическую типизацию, потому что позволяет в процессе компиляции контролировать абсолютное большинство некорректных форм взаимодействия между объектами. Например, в случае обобщённых типов часто бывает нужным, чтобы тип-параметр поддерживал какое-то специфическое отношение -- в частности, отношение порядка, чтобы универсально работали алгоритмы сортировки. В языках с динамической типизацией все эти полезные возможности контроля исходных текстов к сожалению недоступны, но если имеются хотя бы средства аннотации типов, их надо обязательно применять.

**5) Отказываемся от явных структур данных в классах (отвязываемся от конкретной реализации).**

Никаких глобальных значений, глобальных сущностей, в системе нету. Есть только равноправные объекты, которые вызывают методы друг друга, поэтому для удобства все объекты обычно упаковываются в различные контейнеры (которые, конечно, сами определены в проекте как классы реализации). Это, например, списки, массивы, стеки, которые, как правило, эффективно реализованы в стандартных библиотеках.

Эти контейнеры активно используются внутри классов, но всегда скрыты от внешнего мира посредством инкапсуляции. Доступ к этому внутреннему содержимому осуществляется исключительно посредством методов.

**В этом проявляется особенность АТД: мы полностью отвязываемся от конкретных структур данных внутри объектов, и работаем с классами исключительно через их публичные интерфейсы (наборы операций), ничего не зная об их внутренней реализации.**

ООАП тут отличается от других методов проектирования, которые с самого начала привязываются к различным структурам данных и становятся полностью зависящими от их реализации (например, от табличного представления в базе данных).

**В объектно-ориентированном подходе под "структурой данных" понимается только набор операций -- своеобразный контракт, интерфейс, протокол взаимодействия.**
