``


## 6. Реализация объектной системы

Как уже отмечалось,  **ООП желательно использовать в основном при наличии явной необходимости в наследовании, и достаточно ограниченно; в остальных случаях лучше придерживаться декларативной/функциональной моделей** .

Как правильно и легко реализовать полноценную объектно-ориентированную систему на основе декларативной модели вычислений, расширенной явным состоянием? Это делается в основном **сочетанием программирования высшего порядка с явным состоянием** -- через это сочетание вы полностью поймёте концепцию объектов и классов.

Первый шаг в понимании того, как построить систему объектов, заключается в том, чтобы понять,  **как связаны между собой её различные части** .
ООП задаёт иерархию абстракций, которые связаны друг с другом своего рода отношениями "спецификация-реализация". Существует множество вариантов этой иерархии, рассмотрим простую схему, набор абстракций, от более конкретных к более абстрактным:

- **Работающий объект** -- это активное обращение к объекту, связывающее поток исполнения программы с объектом. Работающий объект содержит набор элементов окружения (например, часть стека, которая создаётся во время "выполнения" объекта), а также сам объект.
- **Объект** -- это процедура, которая инкапсулирует явное состояние (ячейку) и набор процедур, которые ссылаются на это состояние.
- **Класс** - это обёртка записи, в которую заключён набор процедур и набор атрибутов. Эти процедуры называются  **методы** . Методы получают состояние атрибутов в качестве параметра, и изменяют это состояние. Методы могут вызывать друг друга.
  Часто бывает полезно следующее различие:
  **Абстрактный класс** -- это класс, в котором некоторые методы не имеют определения.
  **(Конкретный) класс** -- это класс, в котором определены все методы, которые вызываются в программе.

Если язык поддерживает сообщения первого класса, то возможны вызовы вида

```
Obj Msg 
```

где Msg вычисляется непосредственно во время выполнения.
Если такой "вызов" Msg в программе явно присутствует, то различие между абстрактным и конкретным классом исчезает (хотя оно может существовать концептуально). Выполнение вызова "Obj Msg" вызывает исключение, если Msg не существует в Obj. Но большинство современных языков со статической типизацией такую возможность вычисления сообщения (метода) на лету не допускают -- возникнет ошибка компиляции.- **Метакласс** -- это класс с определённым набором методов, которые соответствуют основным операциям, характерным именно для класса, а не для объекта, например: создание объекта, политика наследования (как методы наследовать), вызов метода, возврат из метода, выбор метода для вызова, присвоение атрибутов, доступ к атрибутам, вызов self/this и т. п.
Реализация этих методов позволяет настраивать семантику объектов в вашей системе.


### Как все эти сущности связаны друг с другом

**Работающий объект создаётся, когда в потоке выполнения программы встречается обращение к некоторому объекту** . Работающий объект существует до тех пор, пока поток его не "отпустит" (не закончит взаимодействие с основным объектом). Несколько "вызовов" одного и того же физического объекта вполне могут "существовать" в программе одновременно в виде нескольких рабочих объектов, если она поддерживает параллельную модель вычислений.

**Объект создаётся как экземпляр класса** . Если объектная система делает различие между абстрактными и конкретными классами, то обычно допускается создавать только экземпляры конкретных классов. Объект как абстрактная сущность существует в программе вечно и инкапсулирует ячейку, которая была создана специально для него.
На практике, объект обычно существует до тех пор, пока активно работающая программа не потеряет все ссылки на него. В этот момент сборщик мусора может освободить память, отведённую под объект, а финализация (условный деструктор) может выполнить последнее действие, если это необходимо. Несколько экземпляров одного и того же класса могут существовать в программе одновременно.

**Класс создаётся через наследование от списка других классов** . Новый класс существует вечно. Наследование получает множество существующих методов и список существующих классов, и возвращает новый класс с новым набором методов. Несколько классов, которые наследуются от одного и того же класса, могут существовать одновременно. Если класс может наследоваться от нескольких классов, то мы имеем множественное наследование, а если класс может наследоваться только от одного класса, то мы имеем единичное наследование.

**Класс может быть создан как экземпляр метакласса** . Новый класс существует вечно. Основные операции такого класса определяются конкретными методами метакласса. Несколько экземпляров одного и того же метакласса могут существовать одновременно.



### Реализация объектной системы

======= 39. Если отсутствует явная необходимость в наследовании, желательно использовать

[ ] объектно-базированную модель

[ 1] декларативную модель

[ ] императивную модель

======= 40. Какой элемент в иерархии абстракций ООП второстепенный?

[ ] работающий объект

[ ] объект

[ ] класс

[ ] абстрактный класс

[ 1] метакласс

======= 41. Какой элемент в связях между абстракциями ООП второстепенный?

[ ] работающий объект создаётся, когда встречается обращение к объекту

[ ] объект создаётся как экземпляр класса

[ ] класс создаётся через наследование

[ ] класс создётся как экземпляр метакласса
