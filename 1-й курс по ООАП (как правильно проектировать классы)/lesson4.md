## Добавляем спецификацию АТД в проект

Как формально определять АТД (его спецификацию) в проекте, когда имеется перечень требований к нему? Каким образом это определение увязывать с реализацией в виде класса?

В некоторых языках программирования это возможно с помощью определения абстрактных классов и абстрактных методов, не требующих реализации на данном этапе. Если такая возможность имеется, определите АТД как абстрактный класс непосредственно в коде.

*Теоретически можно использовать вместо абстрактных классов интерфейсы, которые не поддерживают абстрактные атрибуты, однако реализация интерфейсов в некоторых языках излишне усложнена. Приходится добавлять в проект дополнительные синтаксические конструкции, не относящиеся напрямую к классам, что ухудшает общую идеологическую 
чистоту системы.*

Если такой возможности в языке нету, создайте обычный класс, добавьте везде подробные комментарии, а методы реализуйте с вызовами исключений (например, NotImplemented или, если имеется в языке более подходящий тип исключений -- Abstract...).

Другая возможность -- формальное определение АТД в комментариях к классу (класс всегда реализуется как отдельный модуль кода в проекте).

1) **Определите сам тип** -- просто задайте его название и, при необходимости, тип-параметр.

Обобщим АТД Stack, который исходно был стеком целых чисел, на стек любых потенциально допустимых типов в системе: Stack<T>.

2) **Сформируйте сигнатуры всех методов АТД (без их реализации)**. В отличие от математического определения типа (множества) как декартова произведения, АТД просто перечисляет допустимые операции над объектами своего типа.

*В примерах далее будем использовать условный псевдокод из курса по алгоритмам.*

```
abstract class Stack<T>
    public void push(T value);
    public T pop();
    public T peek();
    public int size();
    public void clear();
```

3) **Для каждого метода при необходимости задайте набор условий, ограничений на его работу (так называемые предусловия)**.

Метод не всегда способен работать на всём множестве значений своего типа (такие методы называют **частичные методы или функции**), и кроме того, часто бывает полезным ограничивать область его определения (допустимые диапазоны значений аргументов).

Конкретный АТД в проекте должен по всем предусловиям, как минимум, определять поведение реализаций соответствующих методов, если данное предусловие нарушается. В нашем случае в АТД не будет определена работа двух методов pop() и peek() в случае, если стек пуст:

```
abstract class Stack<T>
    public void push(T value);
    public T pop(); // предусловие: стек не пустой
    public T peek(); // предусловие: стек не пустой
    public int size();
    public void clear();
```

Что делать в таких случаях, рассмотрим далее.

4) С формальной точки зрения, **вычислительная модель АТД аппликативна: все функции у нас чистые**, и мы никогда не меняем текущий объект, а функции всегда возвращают новый объект. На практике конечно ситуация другая, поэтому в дополнение к методам-функциям и предусловиям потребуются и **постусловия, которые определяют, что в объекте изменяется после вызова того или иного метода**.

```
abstract class Stack<T>

// постусловие: в стек добавлено новое значение
    public void push(T value); 

// предусловие: стек не пустой; 
// постусловие: из стека удалён верхний элемент
    public T pop(); 

// предусловие: стек не пустой
    public T peek(); 

    public int size();

// постусловие: из стека удалятся все значения
    public void clear();
```

5) Так как класс -- это не просто набор полей, а реализация АТД, все атрибуты (поля) класса должны быть согласованы друг с другом. Возможные взаимосвязи согласованных по смыслу атрибутов должны учитываться в спецификации АТД с помощью так называемых **инвариантов**, которые мы изучим на курсе, посвящённом формальному проектированию. Например, если в классе Автомобиль подразумеваются сущности Двигатель и Бак, то при поступлении горючего в Двигатель объём топлива в Баке должен соответственно понижаться. В целом, инварианты дополняют предусловия, определяющие допустимость вызова методов, и постусловия, определяющие влияние методов на состояние объекта.
