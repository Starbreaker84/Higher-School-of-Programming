## Единая нотация.

Название класса и аргументы методов

### Единая нотация

При работе с объектами, при вызове их методов мы всегда используем единую нотацию.

**Каждая операция подразумевает свой вызов относительно её родительского объекта, который всегда существует в контексте этой операции (метода).**

Этот родительский объект, текущий экземпляр для каждой операции в момент её выполнения -- всегда единственный (в языках программирования он обычно обозначается this или self).

Фактически вся объектно-ориентированная нотация определяется совсем небольшим набором из четырёх операций. Самая основная -- это вызов метода объекта:

```
x.f(a) 
       
```

где x -- конкретный объект, f() -- метод этого объекта, а -- аргумент этого метода (список аргументов).

Оставшиеся три операции хорошо известны из императивного программирования: это **присваивание**, **выбор по условию** и **цикл** (с поддержкой команд прерываний цикла). И возможны дополнительные инструкции, связанные с отладкой и тестированием (например, assert и log).

Что касается оператора return, то наилучший способ его использовать -- это указывать return в каждом методе ровно один раз, причём самой последней командой.

### Название класса

Название класса напрямую отражает его смысл. Говорить, что класс делает то-то -- явная ошибка. Класс ничего не делает, он группирует в одно целое набор операций над некоторой структурой данных, над объектами одного типа.

**Название класса -- это английское существительное, именующее конкретную абстракцию данных** (например, BankCard, Stack, Singleton).

В ряде случаев название может быть прилагательным, заканчивающимся на -able, которое характеризует некое общее свойство, например, отношение порядка (Comparable, Sortable). Такие классы всегда отложены (абстрактны) и часто реализуются как интерфейсы, если конкретный язык программирования это позволяет.

### Аргументы (параметры) методов

Общий принцип: **чем меньше аргументов у метода, тем лучше**. В идеале АТД желательно спроектировать так, чтобы у каждого метода, подразумевающего параметры, был ровно один аргумент.

**Аргументы делят на два класса: операнды и опции.**

**Операнды -- это непосредственные значения (объекты), требуемые для работы метода.**

**Опции определяют различные режимы работы метода**. Опции практически всегда можно задавать значениями по умолчанию.

**Аргументы команд -- всегда только операнды**.

-- Задание опций для команд выполняется отдельными вспомогательными командами, для которых эти опции уже будут операндами, причем эти команды имеют ровно один аргумент.
-- Названия вспомогательных команд выдерживаются в едином стиле, например, set\_ИмяСвойства().
-- Если аргумент -- логическое значение, лучше создать две команды без аргументов, одна из которых устанавливает соответствующее свойство в true, а другая в false. Например, set\_light\_on() и set\_light\_off().
-- Для каждой команды, задающей некоторую опцию, должен иметься запрос, возвращающий текущее значение этой опции.
-- В общем случае в коде явно устанавливаются только те опции, которые отличаются от настроек по умолчанию.

При таком подходе не требуется запоминать все детали настроек различных команд, а при расширении класса новыми возможностями его основной интерфейс остаётся неизменным, добавляются как правило только инструкции установки новых опций. Вдобавок одни и те же опции могут использоваться разными командами, и при этом не потребуется многократно их указывать в аргументах этих команд, а достаточно установить один раз, или до следующего вызова соответствующей команды установки соответствующей опции.

Исключения из этого правила делаются обычно в двух случаях:

1) для методов, создающих новые объекты, в любом случае должен присутствовать метод, в котором все опции имеют значения по умолчанию (подразумевается конструктор по умолчанию);
2) для методов, где по смыслу желательно указывать не только опцию, но и основной аргумент (например, строковое имя какого-то устройства), хотя в таком случае оба таких параметра будут операндами.

### Геттеры/сеттеры

Мы собираемся явно разделять запросы и команды, но полностью отказываемся от любых общедоступных атрибутов, полей класса. Ведь мы можем и получать значение атрибута, и одновременно изменять атрибут через прямое обращение к его имени (присваивание), что полностью противоречит нашему подходу. Упомянутый выше универсальный синтаксис вызова методов потенциально допускает схожее с функциональным указание идентификатора атрибута для получения его значения -- как условную функцию без аргументов и даже без скобок списка параметров (), однако никак не поддерживает вариант с присваиванием атрибуту значения.

Существует известная практика геттеров/сеттеров, когда для считывания значений атрибутов используются методы getИмяАтрибута(), а для изменения их значений -- методы setИмяАтрибута(). Этот подход далеко не самый лучший: во-первых, приходится создавать множество маленьких методов, во-вторых, их наличие всё равно даёт неограниченные возможности по изменению значений атрибутов.

Но самое главное, что атрибуты/поля никак не представляются в АТД, и мы добавляем в АТД обычные запросы и команды как некие аналоги геттеров/сеттеров только в случаях, если они действительно необходимы, и им есть определения в спецификации.

### Синглетоны

В заключение ещё один важный момент. Некоторые классы подразумевают свою единственную реализацию: разрешается создавать только один экземпляр такого класса. Это вполне допустимый подход. Реализуется подобная схема с помощью так называемого шаблона проектирования Одиночка/Синглетон, или с помощью Фабрики объектов. Например, когда мы моделируем работу конкретного города, в системе потребуется ровно один экземпляр класса Город.
