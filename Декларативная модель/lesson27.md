### Рекурсивные функции и их области определения

Определим функцию Nth, которая возвращает N-й элемент списка:

```
function Nth(Ls, N)
    if N == 1
        return Ls[1]
    elseif N > 1
        return Nth(Ls[2:end], N - 1)
    end
end

println(Nth([1,3,5], 3)) # 5
```

Но что случится, если мы вызовем Nth([1,3,5], 5)? В данном случае возникнет исключение BoundsError (выход за границы списка/массива). Исключение возникнет также, если N будет равно нулю, и т. д.

Отсюда следует общая техника определения функций:  **генерировать явные исключения, когда значения параметров находятся вне области определения функции** . Однако гарантировать такой контроль весьма трудоёмко (возможны в частности ситуации, когда аргументы окажутся других типов, и т. п.). Компилятор Julia, в отличии, например, от компилятора Java, не отслеживает обязательное завершение всех веток функции, поэтому в динамически типизированных языках это будет проблемой. Тут желательно использовать различный синтаксический сахар, повышающий наглядность и выразительность кода, зависящего от диапазона некоторых параметров.



### Наивные определения часто неэффективны

Как "естественно" реализовать рекурсивную функцию обращения (перевёртывания) списка?

```
function Rev(Ls)
    if Ls == []
        return []
    end

    head = Ls[1]
    tail = Ls[2:end]
    return push!(Rev(tail), head)
end

println(Rev([1,5,3,7,9])) # [9,7,3,5,1]
```

Какой примерно будет её производительность? Для списка длиной n придётся сделать n рекурсивных вызовов, и n добавлений элемента в список. Функция push!() в среднем обрабатывает список длиной n/2 элементов, поэтому общая эффективность Rev() будет пропорциональна (n * n)/2, или по сути O(n * n). Чем длиннее список, тем сильно дольше будет работать такая функция. Кроме того, данная функция имеет ещё один неприятный дефект: для её работы потребуется стек вызовов глубиной n, и если например надо обратить список из миллиона элементов, вполне возможен классический stack overflow.

Любой программист с базовыми навыками, знакомый с императивным языком (например, Java или Python), напишет функцию обращения списка с эффективностью O(n): в одном цикле просто брать i-й от конца исходного списка элемент, и добавлять его в хвост результирующего списка. Поэтому существуют техники, позволяющие превращать такие рекурсивные функции в функции с итеративной формой вычислений, чья эффективность линейна.

### 21. Преобразование рекурсивных вычислений в итеративные

Вернёмся к функции определения длины списка.

```
function Len(lst)

    if lst == []
        return 0
    end

    head = lst[1]
    tail = lst[2:end]

    return 1 + Len(tail)

end
```

Она работает за линейное время, однако всё ещё требует стек размером n (длина списка-параметра). Почему так происходит? Потому что прибавление +1 в заключительном return происходит уже после рекурсивного вызова Len(tail). Вызывающему окружению необходимо "сохраниться" (в частности, запомнить точку возврата в функцию в стеке), о чём уже говорилось -- по сути только для того, чтобы прибавить 1 к результату и сразу его вернуть.

Ранее мы уже обсуждали итеративную схему как  **последовательность трансформации состояний** . В её формате процедуру вычисления длины списка можно представить как последовательность перехода от состояния к состоянию, где каждое состояние -- это пара {длина уже обработанного списка, оставшийся список}. Начальное состояние S0 -- это (0, исходный список), а конечное состояние Sn (для списка длиной n) -- это (n, пустой список). Промежуточное состояние Si -- (i, хвост списка от i+1 до n).

Переведя этот подход в рекурсивный вид, мы получим функцию, которая получает два параметра (длина списка и оставшийся список), увеличивает длину на +1 и удаляет из списка первый элемент.

```
function IterLen(i, lst)
    if lst == []
        return i
    end
    return IterLen(i+1, lst[2:end])
end

println(IterLen(0, [1,2,3,5,8])) # 5
```

Теперь увеличение счётчика i на 1 выполняется не после, а до рекурсивного вызова, и так как он последний в коде функции, сохранять её состояние в стеке не требуется. Фактически мы получили  **рекурсивную версию итеративной схемы расчёта** .

Применим теперь аналогичную технику к функции обращения списка. В качестве состояния снова будем использовать пару {уже обращённая часть списка, оставшаяся необработанной часть списка}.

```
function IterRev(Rs, Ys)
    if Ys == []
        return Rs
    end

    head = Ys[1]
    tail = Ys[2:end]
    return IterRev(pushfirst!(Rs,head), tail)
end

println(IterRev([], [1,5,3,7,9])) # [9,7,3,5,1]
```

Чтобы обеспечить пользователя удобством вызова подобных рекурсивных функций, требующих дополнительный параметр, используется "обёртка" в виде родительской функции, вызывающей рекурсивную функцию с начальным аргументом. Нередко, в частности, в такой схеме рекурсивная функция определяется непосредственно внутри родительской функции.

Например:

```
function Revers(Rs)

  function IterRev(Rs, Ys)
    if Ys == []
        return Rs
    end
    head = Ys[1]
    tail = Ys[2:end]
    return IterRev(pushfirst!(Rs,head), tail)
  end

    return IterRev([], Rs)
end

println(Revers([1,5,3,7,9])) # [9,7,3,5,1]
```

Функция Revers работает за линейное время и не требует стека.

### Преобразование рекурсивных вычислений в итеративные (задания)

======= 44. В декларативной модели, если значения параметров находятся вне области определения функции, надо...

[ ]корректировать их значения

[ ]выводить диагностические сообщения

[x]генерировать явные исключения

======= 45. Рекурсивные вычисления полезно преобразовывать в итеративные, потому что...

[] надо понижать сложность O(..)

[X] надо избегать переполнения стека

[ ] полезно создавать обёртку для рекурсивных функций

======= 46. Итеративная схема -- это...

[X] последовательность трансформации состояний

[ ] избегание сохранения состояния в стеке

[ ] вычисления за линейное время
