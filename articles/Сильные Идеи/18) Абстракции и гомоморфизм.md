## Гомоморфизмы и абстракции

### (важное дополнение к материалу об абстракциях)

Определений абстракции в программировании существует множество, и возможно вы встречались с одним из них, если изучали учебник **"Структура и интерпретация компьютерных программ"** (SICP), который считается одной из двух самых великих классик в информатике -- наряду с **"Concepts, Techniques, and Models of Computer Programming"** (CTM), которая на русский не переводилась (кроме моих курсов :). Так вот, уже первая глава SICP называется "Построение абстракций с помощью процедур", но насколько она адекватно отражает концепцию абстракции?

**Gerry Sussman** (один из авторов SICP) продолжает успешно профессорствовать в MIT, и наши с вами PhD-друзья из Массачусетса этой весной 2022-го года специально поинтересовались у мэтра, чтобы он пояснил по поводу его версии абстракций. По мнению Sussman, абстракция -- это "чемоданный термин", который означает слишком много разных вещей, хотя он видит ровно два её подходящих определения, прямо относящихся к разработке программного обеспечения.

Первое определение: давать имена сущностям, созданным в соответствии со вторым определением. :)

А вот второе определение естественно вытекает из [первой теоремы о гомоморфизмах](https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms) и её обобщений в универсальной алгебре.


### Гомоморфизмы и абстракции

Объяснение на пальцах.

![](https://skillsmart.ru/self/work/hott.png)

G -- это множество всех возможных данных некоторого типа, и f -- это операция над этим множеством. Например, G -- это множество всех объектов-котов в программе, а f -- это операция "Погладить", изменяющая значение "настроения" объекта. Или, G -- это множество всех резисторов в системе, а f вычисляет значение тока через резистор в зависимости от напряжения.Потенциально существует множество различных значений в G, при которых f делает одно и то же. У многих котиков может быть одно и то же текущее "настроение", которое увеличится на одно и то же фиксированное значение после применения f; в системе может быть несколько резисторов с одинаковым сопротивлением, для которых f выдаст одинаковые результаты при одинаковых входных напряжениях. Таким образом в G можно выделить группы объектов, которые f обрабатывает "одинаково". Каждую такую группу выделим в список, и получим так называемое ядро f -- ϕ (фи) как список таких списков.


### Гомоморфизмы и абстракции

Каждый список содержит объекты-котики, которые "похожи" по операции f (но могут конечно сильно различаться по другим операциям и своими состояниями в общем). Однако каждый такой вложенный список мы считаем представлением, репрезентацией условного f-котика (в некотором смысле это так называемый  **гомотопический тип** ).

И теперь фактически мы можем использовать фи для "сминания" схожих (по операции f) элементов G. В некотором смысле мы "обобщаем" всех котиков с одинаковым настроением N, или все резисторы с сопротивлением R (без учёта их остальных качеств!) до одного "котика" с настроением N или одного резистора с сопротивлением R. Это обобщение есть G/K на картинке.

Так вот, фундаментальная теорема о гомоморфизме заключается в том, что G/K ведет себя так же (изоморфен) как и H: множеством различных представлений котиков или резисторов можно манипулировать так же, как и одним конкретным котиком или резистором. Программистам этот подход обычно известен как  **утиная типизация** : если нечто выглядит как утка, плавает как утка и крякает как утка, то считаем, что это и есть утка (применяется например к полиморфной реализации интерфейсов). И можно обойтись всего одной операцией: "выглядит", "плавает", или "крякает".


### Гомоморфизмы и абстракции

Профессор Sussman тут однако делал акцент не столько на самой теореме, сколько на сущности G/K.

**Абстракция -- это идея/принцип/схема объединения различных представлений, которые ведут себя одинаково** (при некоторой заданной операции).

И это сильная идея, потому что она позволяет объединить в одно отображение всю сложную связь между множеством различных реализаций и их общей абстрактной предметной областью. В рамках гомотопической теории типов HoTT эта идея сводится к объединению конкретных значений, которые могут быть обработаны единообразно с помощью определённых операций. Она присутствует в абстрактной интерпретации: фи фактически и есть отображение абстракции, а G и G/K -- конкретная и абстрактная предметные области.

Но при этом важно отметить, хотя такая потенциальная связь "программистских" абстракций с абстрактной алгеброй и HoTT весьма симпатична, она нам не даёт никаких явных подсказок относительно улучшения нашей прозаической повседневной работы. Но вот таким оказалось мнение легендарного профессора о понятии абстракции в разработке программного обеспечения. Внешне оно отличается от любых известных вариаций интерпретации понятия абстракции, но на самом деле вполне совместимо с ними.


### Гомоморфизмы и абстракции

Однако существует ещё кое-что, что хотелось бы уметь делать с помощью того, что мы называем "абстракцией", но что не можем делать с помощью абстрактной интерпретации: иметь дело с  **неточностью** .

Потому что любые формальные определения хорошей абстракции фактически предлагают нам функцию, которая заявляет: "тут может быть что угодно" в 100% случаев. Однако на практике нам часто требуется учитывать некоторую погрешность. Например, даже при простейших физических вычислениях нам придётся придерживаться некоторых численных приближений, и такая техника в 0,1% случаев например может ошибаться (из-за накопившейся погрешности, ...). Тут ведётся немало исследований, можно почитать Дойча "Структура реальности" и т. п. Это реально важный момент, потому что, для примера, разработчики сильнейшего в мире AI для игры в покер [заявляют](https://www.cs.cmu.edu/~noamb/papers/17-IJCAI-Libratus.pdf), что "абстрагируют" пространство игры, округляя ставки, и профи специально используют этот момент, делая странные ставки, чтобы погрешность сбивала AI с толку.

Но хорошего подхода к абстракции, который допускал бы разумные ошибки, в информатике пока нету.


### Гомоморфизмы и абстракции

Резюме такое, что когда вы только начинаете думать о системе типов (классов) в вашем проекте, самым универсальным и безопасным подходом будет абстрагирование семантики (онтологии предметной области) с постепенной детализацией через их операции. Сперва вы выделяете самые "грубые", общие, совсем наглядные и очевидные сущности в АТД, но только исходя не из их названий, а из операций над ними (причём с акцентом на минимизацию первоначального множества таких операций).

Например, если вы пишете игру по котиков, то вроде бы очевидным и естественным будет сразу создать класс Cat, и потом в него что-то напихивать. Однако, вполне возможно, в игре окажется несколько "видов" котов, каждый из которых ведёт себя принципиально иначе. Одни коты только кушают, и их можно гладить, а другие коты неуловимы и только воруют еду. Можно создать иерархию с двумя дочерними классами-наследниками Cat, однако скорее всего у них вообще не будет ничего общего, и полиморфизм будет лишь мешать. Поэтому на первом шаге лучше создать полностью автономные АТД с минималистичными наборами операций.


### Гомоморфизмы и абстракции

Когда ТЗ большое, и всевозможных активностей сотни или тысячи, такая работа, конечно, существенно усложняется. На третьем курсе по ООАП предлагаю методику Бертрана Мейера, упрощающую анализ и проектирование системы АТД, но самое главное, чего надо придерживаться в этом процессе -- это  **выявлять сущности, которые могут быть обработаны единообразно с помощью определённых операций** . Тут может оказаться гораздо более продуктивным не полиморфизм, а наоборот, interface dispatch, когда мы формируем прежде всего наборы операций (в виде автономных функций) над интерфейсами, которые (интерфейсы) потенциально могут реализовываться самыми разными и вроде бы несовместимыми сущностями (котики, бабочки, роботы,...).
