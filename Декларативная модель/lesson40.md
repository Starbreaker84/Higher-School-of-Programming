### 42. Абстрактные типы данных (АТД)

Вы, возможно, уже хорошо познакомились с АТД на практике, на моих курсах по ООАП. Напомню, что АТД -- это описание структуры данных исключительно в терминах операций над ней. Внутренняя реализация (включая любые атрибуты типа) полностью скрыта в АТД, ну или точнее, она просто отсутствует. Ближе всего к АТД в программировании понятие интерфейса или абстрактного класса.

Рассмотрим теперь АТД с точки зрения декларативной парадигмы – что же они собой представляют?

Тип данных, или просто тип – это множество значений, с которым связано множество допустимых операций над этими значениями. В декларативной модели имеется предопределённый набор базовых типов, которые мы изучали ранее. В дополнение к ним разработчик может свободно определять новые типы.

**Тип называется абстрактным, если он полностью определён своим множеством операций и при этом полностью независим от реализации** . Это значит, что всегда можно менять его текущую реализацию, не меняя сам АТД (как интерфейс в программировании).

### Декларативный стек

АТД Stack<T> (стек, содержащий элементы типа T) может быть описан четырьмя операциями (функциями):
-- NewStack() – создать новый стек;
-- Push(Stack s, T elem) – втолкнуть элемент elem в стек s;
-- Pop(Stack s) – вытолкнуть элемент из стека s;
-- T Peek(Stack s) – получить верхний элемент стека s, не меняя сам стек;
-- IsEmpty(Stack s) – булева проверка, пустой ли стек s.

Попытка вытолкнуть элемент из пустого стека вызовет ошибку (исключение).

Важный момент: первые три функции возвращают в качестве своего значения новый стек, так как все функции чистые и не меняют значений своих аргументов. Таким образом, мы можем выстраивать целые конвейеры таких функций, которые передают друг другу промежуточные результаты (стеки), и порядок обработки данных при этом становится весьма нагляден и последователен.

Реализовывать этот набор функций мы можем самими разными схемами, при этом оригинальный АТД Stack остаётся неизменным.

### Защита АТД

Однако лёгкая сменяемость имплементаций АТД несёт в себе определённую опасность. В частности, далеко не всегда хорошо делать реализацию открытой и видимой для всех. Пока предложенная модель стека может легко дополняться любым разработчиком, который может создавать новые операции над стеком, так как его реализация открыта и доступна.

Но на практике это приводит к двум серьёзным проблемам:

1) Программу становится гораздо сложнее развивать и сопровождать. Например, мы хотим повысить эффективность АТД Словарь, заменив его реализацию на основе списков реализацией на основе деревьев. В таком случае придётся прочесать весь код программы для выяснения, какие её части зависят от реализации Словаря на основе списка.
   Кроме того, если в каких-то частях программы в реализации некоторого АТД имеются ошибки, то в процессе их исправления вполне могут возникать правки и в самом АТД, что в свою очередь загрязнит другие части программы.
2) Программа становится подверженной потенциально вредоносному вмешательству. Это более тонкая проблема, связанная с безопасностью. Она возникает в основном с открытыми программами, которыми пользуется много людей. Под открытой программой будем понимать программу, взаимодействующую с такими другими программами, которые «доступны» только в рантайме, например через API (нету доступа к их исходным текстам). Но что получится, если другая программа вредоносна, и захочет нарушить выполнение открытой программы?

Базовый принцип решения упомянутых проблем –  **защитить конкретные реализации АТД от неавторизованного вмешательства** . Внутренняя реализация, "вычислитель" значений, помещается внутрь некоторой границы защиты.

Есть два способа использования такой границы:

1) Стационарное значение. Значение никогда не выходит за границы. Чётко определенный и задокументированный набор операций фактически и становится такой границей. Схема вычислений остаётся внутри границ.
2) Мобильное значение. Значение, вычисленное реализацией, может покинуть границу, и затем снова вернуться обратно. Когда оно снаружи, с ним можно работать внешнему коду. Определённым операциям с соответствующего разрешения допускается вывести значение за границу, вычислить на его основе новое значение, и результат вернуть обратно внутрь границы.

В каждом из этих случаев достаточно лишь посмотреть на реализацию операций АТД. Классический пример первого случая -- цифровой банкинг. У каждого клиента имеется счёт с некоторой суммой денег. Клиент может совершить операцию по переводу денег со своего счёта на другой счет. Но так как клиенты никогда на самом деле не приходят физически в банк, то и физические деньги банк не покидают.

Второй пример – сейф или банковская ячейка. Он хранит деньги и может быть открыт клиентами, у которых есть ключ. Каждый клиент может забрать деньги из сейфа, или положить их в него. Выйдя из банка, клиент может отдать деньги другому клиенту. Но когда деньги в сейфе, они в безопасности.

Этот способ -- самый простой для понимания в рамках декларативной модели.  **Авторизация, требуемая для преодоления границы защиты, и есть своего рода "ключ"** . Мы добавляем его как новое понятие к декларативной модели, и называем «имя».

Но для этого декларативную модель требуется расширить. Во-первых, потребуется защитить значения, и во-вторых, потребуется защитить несвязанные декларативные переменные.

Один из возможных подходов –  **создать операции-«обёртки» с «ключом» доступа** . Доступ к внутреннему представлению некоторой структуры данных становится возможен только тем, у кого имеется такой специальный ключ. С его помощью можно создавать «обёртки» и взаимодействовать с другими «обёртками» с таким же ключом.


Рассмотрим пример создания "обёртки" с ключом. Пусть имеется некоторый тип Name («имя»), хранящий атомарное значение. Для него не определены операции вывода на экран и преобразования в число или строку. Всё, что можно делать с типом Name – это **создавать новые экземпляры** (операция NewName), и **сравнивать их с другими значениями типа Name** с помощью == .

Операция создания нового «имени» NewName гарантирует, что результирующее значение уникально в программе. Однако тут необходимо отметить, что эта операция не декларативна: вызывав её дважды, мы получим разные результаты (что подразумевает, что у этой операции имеется внутренняя память, которая хранит некоторое состояние, гарантирующее уникальность очередного имени). Однако если мы применяем NewName исключительно для создания безопасного АТД, это не проблема – получившийся АТД останется декларативным.

Теперь с помощью NewName мы можем создавать уникальные ключи в программе, и при этом не имеется никакой возможности выяснить их значение и как-то нарушить границы безопасности. Сравнение тут не поможет, так как NewName гарантированно выдаёт только уникальные значения, и нету никакой другой возможности создать экземпляр типа Name.

Как эта схема применяется на практике? Например, мы реализовали АТД Stack внутри как обычный список.

```
S = NewStack()
```

Мы знаем, что S – это стек с известным набором операций, но не имеем прямого доступа к его физическому содержимому в виде списка (в рамках декларативной модели, а не в конкретном языке программирования).

Создадим в программе ключ доступа к Stack:

```
StackKey = NewName()
```

Теперь можно определить функцию GetStackInternal(), которая получает на вход стек и ключ, и либо возвращает список-реализацию стека, если ключ-параметр совпадает с ключом StackKey, либо не делает ничего.


### Обёртка как АТД

Подобная схема при создании безопасных АТД может применяться часто, поэтому она сама, в свою очередь, напрашивается быть выделенной в абстрактную «обёртку». Сделать это лучше тоже с помощью АТД, который будет иметь две операции: Wrap и Unwrap. Ключ генерируется скрыто в «конструкторе» АТД.

Операция Wrap, получая на вход некоторое значение, возвращает функцию, которая требует наличия ключа при своём вызове, и только тогда возвращает «хранимое» в ней значение.

Операция Unwrap получает на вход подобную функцию, передаёт ей скрытый ключ, и возвращает, соответственно, снова незащищённое значение.

Например, имеем незащищённый список S:

```
S = [1, 2, 3]
```

Получим его защищённую версию:

```
SecS = Wrap(S)
```

Теперь, просто обратившись напрямую к SecS (это уже не значение, а функция), мы ничего не получим.

Обратно вернуть открытое значение можно так:

```
S1 = Unwrap(SecS)
```

Wrap и Unwrap -- это операции, которые вызываются внутри других операций АТД, за его границами они недоступны.


Защищенная версия стека SecureStack, где в качестве реализации применяется список, может выглядеть так:

-- NewStack() возвращает Wrap( [ ] ) – защищённый пустой список.

-- Push(Stack s, T elem) делает Unwrap(s), добавляет в хвост (или голову, в зависимости от того, что считаем вершиной стека) получившемуся списку elem, и затем выполняет Wrap() для нового списка, что и возвращает.

-- Pop(Stack s) делает Unwrap(s), удаляет элемент из хвоста получившегося списка, и затем выполняет Wrap() для нового списка, и возвращает защищённый результат.

-- Peek(Stack s) делает Unwrap(s) и возвращает элемент из хвоста списка.

-- IsEmpty(Stack s) делает Unwrap(s) и проверяет, не пустой ли список.

Обе операции Wrap и Unwrap скрыты внутри реализации АТД, поэтому нету абсолютно никакой возможности получить доступ к его содержимому.


### АТД и их защита (задания)

======= 83. АТД -- это ...

[ ]набор атрибутов и операций над ними

[]абстрактный класс/интерфейс, не зависящий от реализации

[x]описание структуры данных исключительно в терминах операций

======= 84. Реализация АТД в декларативной модели ...

[x]всегда формирует новую структуру данных

[]содержит атрибуты и операции над ними

[ ]выполняется в виде класса

======= 85. Защита АТД с ключом доступа ...

[ ]подразумевает явную генерацию уникального ключа

[]требует операций-обёрток с указанием ключа доступа

[x]не требует знания самого ключа
