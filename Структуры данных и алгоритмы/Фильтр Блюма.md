## Фильтр Блюма

Существует несколько подходов, позволяющих повысить эффективность работы хэш-системы. Один из них -- это  **фильтр Блюма** , который не выдаёт точный результат, присутствует элемент в множестве или нет, а лишь вероятностный. При этом допускаются ложноположительные срабатывания (про несуществующий элемент сообщается, что он в наличии), но не ложноотрицательные (когда существующий элемент не находится). Вероятность ложного срабатывания находится в обратной зависимости от выделяемого под фильтр объёма памяти, что позволяет гибко его настраивать на конкретные условия эксплуатации.

**1 Реализация фильтра Блюма**

Реализуется фильтр Блюма на основе битового массива длиной m, который например из соображений эффективности, когда памяти достаточно, можно реализовать как массив логических значений. В таком случае мы получаем мгновенный O(1) доступ к каждому элементу, а в случае битовой реализации сложность завязывается на конкретный способ хранения битового массива. На практике часто ситуация противоположная: память для фильтра Блюма очень ограничена, но накладные расходы на работу с отдельными битами в машинных словах всё равно оправдывают экономию времени, когда основная система (кэш-системы, прокси-серверы, базы данных) будет выполнять подобную операцию в десятки раз дольше.

В фильтре Блюма реализуется семейство хэш-функций, отображающих входные значения в соответствующие индексы в пределах 1..m (или 0..m-1).

Исходно все m значений массива равны нулю. Когда в фильтр Блюма добавляется новый элемент, надо выставить единицы во всех позициях, которые выдадут все хэш-функции (подразумевается, что они это делают достаточно равномерно).
Каждая хэш-функция выдаёт только одну, единственную позицию, индекс, в массиве. Точнее, она в идеале выдаёт битовую маску, в которой в позиции этого индекса выставлена единичка.
Соответственно, проверка принадлежности элемента множеству требует, чтобы во всех позициях индексов, выдаваемых всеми хэш-функциями, были единицы. Если есть хотя бы один ноль, считаем, что элемент множеству не принадлежит.

В такой ситуации возможны ложные срабатывания "найден несуществующий", когда выставлены все единицы в позициях для конкретного элемента -- например, так скомбинировалась работа хэш-функций для других элементов. Но очевидно, что существующий элемент не может быть не найден, так как для него проставлены все единицы.

Зная фиксированное количество n значений на входе, можно подбирать такой размер m фильтра (битового массива), чтобы добиться подходящей вероятности ошибочного положительного срабатывания:

```
P = 0,6931 в степени (m / n)
```

А рекомендуемое количество хэш-функций такое:

```
k = 0,6931 * m / n
```

Обратите внимание, что чем больше элементов для анализа, тем меньше требуется хэш-функций, так как растёт вероятность того, что рассчитанные хэши будут значимо отличаться друг от друга.

Хэш-функции можно использовать достаточно простые, например версия для строки:
организуем цикл до длины строки, результат в этом цикле считаем как его версия с предыдущей итерации, умноженная на случайное число, к которой прибавляется код очередного символа, и берём результат тут же по модулю длины таблицы.

Хэш-функция возвращает число, которое удобно представить в виде битовой маски, и одной операцией выполнить наложение на битовый массив, если в языке поддерживается подходящий тип данных. Поэтому на практике используются более корректные математически в плане равномерности распределения хэш-функции, например одна из наиболее популярных -- MurmurHash (MUltiply and Rotate).

Плюсы фильтра Блюма: битовый массив можно делать произвольного размера, в том числе и совсем небольшим, ведь нам требуется просто быстро проверять наличие элемента, или наоборот, крайне крупным, ведь он хранится очень компактно. И сами хэш-функции можно хорошо реализовывать простыми алгоритмами. Очень важно так же, что операции над несколькими фильтрами можно выполнять побитовыми операциями сложения-умножения.

**2 Модификации фильтров Блюма**

Существуют гибридные версии фильтров, показывающие очень высокую степень надёжности, когда например в качестве ключей выступают строки. Строки разбиваются на последовательности из n элементов, для каждой последовательности вычисляется свой набор индексов, и результат комбинируется из результатов таких n-последовательностей.

Фильтр Блюма нередко применяется и в сферах, где используются словари, которые работают по похожим схемам, только с гарантированной "доставкой" результата. Это например оптимизированная модификация фильтра Блюма -- Bloomier filter, обобщающий оригинальную версию. Он хорошо работает при реализации словарей, для которых достаточно знать, принадлежит ли некоторый ключ словарю, пусть даже и небольшой вероятностью ошибки, а вот проверка отсутствия ключа в словаре не требуется. Bloomier filter подразумевает хранение и значения, ассоциированного с битовой картой, выданной для него хэш-функциями.

Эта концепция выглядит на первый взгляд немного парадоксальной, так как мы хотим реализовать словарь на типе данных, который и был придуман для того, чтобы избавиться от проблем, связанных со словарями. Основная идея такая: входные значения лежат в битовом диапазоне либо 0 или либо 1, и для каждого ключа строится набор фильтров Блюма (два, один для 0, другой для 1), которые по этому ключу выдают соответствующий ему корректный результат. Так как с помощью двух битов мы можем закодировать любые значения, то данный подход расширяется на битовые цепочки, и итерациями строятся своеобразные иерархии фильтров Блюма, которые хотя и потенциально могут экспоненциально расти, однако сходятся на практике достаточно быстро.

Здесь применяются так называемые статические функциональные значения, -- значения, вычисляемые функциями на лету. Сами значения ведь нигде не хранятся, а формируются функционально, операциями над множеством фильтров Блюма.

**3 Задание**
Реализуйте классический фильтр Блюма для строк на основе битового массива (не массива из байтов или булевых значений).

Для тестового примера можно использовать и обычное 32-разрядное целое число: принимаем размер фильтра m=32. Примем количество значений для фильтра n=10, и получим примерное количество хэш-функций k=2.

Не используйте в вашем решении никакие стандартные библиотеки для работы с битовыми массивами.
Запрограммируйте самостоятельно код для установки/снятия i-го бита в 32-разрядном регистре -- это буквально пара строчек кода с битовыми операциями, дополнительные библиотеки не нужны.

Реализуйте две хэш-функции для строк по вышеописанной схеме.
В качестве результата первой итерации используйте ноль.
В качестве случайных чисел для первой функции используйте 17, для второй 223.
В качестве 10 тестовых строк используйте строки

```
"0123456789" "1234567890" ... "8901234567" "9012345678"
```

**[предыдущее](https://skillsmart.ru/algo/15-121-cm/c9b6abc9e1.html)**

---

## заготовка класса Python для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github_py.html)

```
class BloomFilter:

    def __init__(self, f_len):
        self.filter_len = f_len
        # создаём битовый массив длиной f_len ...


    def hash1(self, str1):
        # 17
        for c in str1:
            code = ord(c)
        # реализация ...

    def hash2(self, str1):
        # 223 
        # ...

    def add(self, str1):
        # добавляем строку str1 в фильтр

    def is_value(self, str1):
        # проверка, имеется ли строка str1 в фильтре
```

---

## заготовка класса C# для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
using System.Collections.Generic;
using System;
using System.IO;

namespace AlgorithmsDataStructures
{
    public class BloomFilter
    {
      public int filter_len;

      public BloomFilter(int f_len)
      {
        filter_len = f_len;
        // создаём битовый массив длиной f_len ...
      }

      // хэш-функции
      public int Hash1(string str1)
      {
        // 17
        for(int i=0; i<str1.Length; i++)
        {
            int code = (int)str1[i];
        }
        // реализация ...
        return 0;
      }
      public int Hash2(string str1)
      {
        // 223
        // реализация ...
        return 0;
      }

      public void Add(string str1)
      {
        // добавляем строку str1 в фильтр
      }

      public bool IsValue(string str1)
      {
        // проверка, имеется ли строка str1 в фильтре
        return false;
      }
   }
}
```

---

## заготовка класса Java для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
public class BloomFilter
{
      public int filter_len;

      public BloomFilter(int f_len)
      {
        filter_len = f_len;
        // создаём битовый массив длиной f_len ...
      }

      // хэш-функции
      public int hash1(String str1)
      {
        // 17
        for(int i=0; i<str1.length(); i++)
        {
            int code = (int)str1.charAt(i);
        }
        // реализация ...
        return 0;
      }
      public int hash2(String str1)
      {
        // 223
        // реализация ...
        return 0;
      }

      public void add(String str1)
      {
        // добавляем строку str1 в фильтр
      }

      public boolean isValue(String str1)
      {
        // проверка, имеется ли строка str1 в фильтре
        return false;
      }
}
```

---

## заготовка классов C++ для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
class BloomFilter
{
  public:
      int filter_len;

      BloomFilter(int f_len)
      {
        filter_len = f_len;
        // создаём битовый массив длиной f_len ...
      }

      // хэш-функции
      int hash1(char* str1)
      {
        // 17
        for(int i=0; i<strlen(str1); i++)
        {
            int code = str1[i];
        }
        // реализация ...
        return 0;
      }
      int hash2(char* str1)
      {
        // 223
        // реализация ...
        return 0;
      }

      void add(char* str1)
      {
        // добавляем строку str1 в фильтр
      }

      bool is_value(char* str1)
      {
        // проверка, имеется ли строка str1 в фильтре
        return false;
      }
};
```
