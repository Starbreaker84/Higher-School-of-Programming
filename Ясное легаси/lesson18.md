### Зависимости от сторонних библиотек

54. Проблема. Практически в каждом более-менее крупном проекте используются внешние библиотеки, которые решают определённые задачи некоторым готовым сервисом. Когда мы активно их применяем, то, скорее всего, существенно сократим сроки выполнения проекта. Однако существенный минус такого подхода в том, что мы легко становимся слишком зависимыми от библиотеки, особенно если пользуемся ею в коде без разбора.

Я сам попадал в ситуацию, когда, например, в большом проекте (сотни тысяч строк на C#) применялся закрытый компонент UI (форматированный вывод текста) ценой 15 долларов, принудительно навязанный менеджерами, решившими "поумничать" -- типа, помочь разработчикам сэкономить их время. Никакой адекватной проверки этого компонента не проводилось -- просто было сказано "используйте его, и всё".

Пользователям показывались большие формы с графическими полями на основе такого компонента, и когда дело дошло до опытного тестирования, оказалось, что форма с сотнями, а то и тысячами таких полей грузится очень долго. В результате детальных тестов выяснилось, что конструктор такого компонента (в версии .NET 2.0 по-моему) выполнялся на компьютере среднего качества 0,15 секунды, поэтому загрузки формы с множеством полей приходилось ждать целые минуты. На этот компонент в проекте было завязано очень много кода (т.к. менеджеры просто приказали его активно применять), и обратной дороги уже не было :)
Решилось это рекомендацией пользователям обновить версию .NET и использовать более мощные компьютеры, что, конечно, отнюдь не добавило продукту авторитета и лайков.

Случается немало и других, буквально убийственных для проекта, проблем. Например, довольно типична ситуация, когда поставщик библиотеки в одностороннем порядке поднимает лицензионную плату, или вводит драконовские роялти, и в результате выпуск приложения на рынок даже не окупает затраты на разработку.

Решение. Никогда не завязывайте ваш проект на внешние библиотеки и компоненты, если они не доступны в исходных текстах, пусть и за плату.

Избегайте беспорядочного использования прямых вызовов библиотек в коде. Напишите тонкую оболочку поверх всех классов или функций, которые предоставляет библиотека. При возникновении малейших сложностей или проблем с её эксплуатацией пишите поставщику используемой библиотеки, чтобы понять, как оперативно он предоставляет обратную связь, и насколько быстро готов решать проблемы.


### В легаси полно прямых вызовов внешнего API

Допустим, вы абсолютно уверены в поставщике библиотеки, внешнего сервиса, или же она стандартная в вашей экосистеме (например, .NET или J2EE). Действительно, вы экономите много времени и других ресурсов, применяя множество готовых решений, используя опенсорсные решения, или даже целые фрагменты кода из стандартных библиотек, большинство которых сегодня общедоступно. Однако в результате ваше приложение получается почти целиком состоящим из сплошных вызовов API внешних библиотек и сервисов. Какие в таком типичном подходе имеются подводные камни?

В большом проекте вы постоянно попадаете на распутье "создавать самому, приобретать готовое, заимствовать чужое".

Выбирая путь заимствования, мы экономим время, но рискуем тем, что массово внедряем в приложение код, который нелегко (а то и невозможно) изменить, не зная фактически, насколько этот код надёжен, полноценен, и даже просто корректен. В результате приложение получается сплошь состоящим из вызовов внешних библиотек. И как же изменять такой код? А может быть, вообще отказаться от тестирования -- ведь мы лишь вызываем готовые методы, а сам код прост, так что же в этом плохого?


### В легаси полно прямых вызовов внешнего API

55. Проблема. По мере разрастания подобные проекты превращаются в довольно жуткую мешанину сомнительного оригинального кода и сплошных вызовов внешнего API. И, увы, иметь дело с подобными легаси-системами, испещрёнными библиотечными вызовами, существенно труднее, нежели с полностью доморощенными.

Во-первых, очень трудно подчас даже примерно понять, как улучшить структуру кода, испещрённого вызовами API -- отсутствует даже намёк на правильный подход.

Во-вторых, работать с системами, активно использующими внешний API, трудно по определению, поскольку это чужой прикладной интерфейс. Если бы он был полностью наш, то мы могли бы применять многие из ранее перечисленных методов (переименование интерфейсов/классов/методов, добавление классов-наследников и т.д.).

Решение. Возможны два пути: заключение интерфейса API в оболочку и декомпозиция (извлечение методов, логическая инкапсуляция вызовов) по видам ответственности.

1. Когда мы заключаем внешний интерфейс API в оболочку, то создаём свои интерфейсы, зеркально отображающие интерфейс API как можно точнее по своим сигнатурам. Этот вариант подходит, когда сам внешний интерфейс API относительно невелик, и есть чёткая возможность полностью отделить зависимости проекта от сторонней библиотеки. Заключая интерфейс API в оболочку, мы получаем возможность протестировать практически весь наш код (за исключением тонкого слоя делегирования в оболочке).
2. Декомпозиция по видам ответственности подразумевает, что мы не отказываемся от совместного прямого использования внешнего API в нашем коде, однако не допускаем их свободного "размазывания" по кодовой базе, а логически инкапсулируем в новые методы существующих классов. Этот вариант подходит, когда интерфейс API достаточно сложен, и имеются хорошие инструментальные средства, обеспечивающие безопасное формирование методов (ну или уверенность в безопасности их создания вручную).


### В легаси полно прямых вызовов внешнего API

56. Проблема. Найти хороший баланс между этими двумя вариантами непросто. Заключение интерфейса API в оболочку полезно и удобно, однако требует больших усилий. В случае декомпозиции по видам ответственности мы объединяем логику собственного кода с кодом API в новом методе более высокого уровня абстракции. В таком случае наш код становится зависим в основном уже от подобных интерфейсов более высокого уровня, нежели от вызовов низкоуровневого API, но тогда мы вряд ли сможем организовать хоть какое-то модульное тестирование соответствующих частей кода.

Решение. На практике нередко применяются оба подхода: тонкая "физическая" оболочка вокруг API -- для тестирования, а оболочка более высокого логического уровня -- для представления внешнего интерфейса в форме, более удобной для использования программистами.



### В легаси полно прямых вызовов внешнего API (задания)

======= 46. Если в важных подсистемах вашего проекта активно используются внешние библиотеки, главное -- ...

[1 ] они должны быть доступны в исходных текстах, пусть и за плату

[ ] хорошая связь с разработчиком библиотеки

[ ] упорядочить прямые вызовы библиотек в коде

[ ] использовать более мощные компьютеры

======= 47. Заключение внешнего интерфейса API в оболочку подходит, когда ...

[ 1] внешний интерфейс API относительно невелик, и зависимости от него прозрачны

[ ] интерфейс API достаточно сложен

======= 48. Декомпозиция по видам ответственности подходит, когда ...

[ ] внешний интерфейс API относительно невелик, и зависимости от него прозрачны

[ 1] интерфейс API достаточно сложен
