## 6. Развитие моделей данных

Вторая по актуальности проблема реляционной модели -– это  **наличие связей один-ко-многим и необходимость её нормализации** . Например, в организации имеется штатное расписание с утверждённым перечнем должностей, и сотрудники, каждый из которых назначен на определённую должность. Делать в таблице сотрудников отдельное поле «должность», очевидно, ошибочно: названия должностей могут меняться, а кроме того, к каждый официальной должности, занесённой в таблицу штатной структуры, удобно привязать различную дополнительную информацию (например, зарплату).

Поэтому в таблице сотрудников должность представляется внешним ключём («ссылкой») на соответствующую запись в таблице должностей (штатной структуры). Это классический подход SQL-модели (до SQL:1999), когда требуется выполнить нормализацию такого представления.

В дальнейшем SQL-стандарт расширился поддержкой  **структурированных типов данных и данных в формате XML** . В результате многоэлементные, составные данные стало возможным сохранять в отдельной записи, делать к ним запросы и выполнять индексацию.

И третий вариант -- представление должностей и иной служебной информации  **непосредственно в виде JSON- или XML-документа** . Он сохраняется в текстовом столбце таблицы БД, а интерпретируется прикладным приложением. Тут мы упускаем все возможности СУБД по выполнению запросов к содержимому такого столбца.

Таким образом мы плавно переходим к концепции так называемых  **документоориентированных (или NoSQL-) баз данных** . В частности, у JSON-представления хорошая так называмая  **локальность** , нежели у многотабличной схемы. Для извлечения всей информации по сотруднику в реляционной модели необходимо выполнить несколько запросов (по идентификатору пользователя) или выполнить запутанное многостороннее соединение таблицы пользователей с подчиненными ей таблицами. В JSON-представлении же вся нужная информация находится в одном месте, и одного запроса вполне достаточно.

Связи «один-ко-многим» профиля сотрудника с его должностями и другими детальными характеристиками (местом обучения, контактной информацией, …) подразумевают древовидную структуру данных, и JSON-представление делает эту структуру явной и наглядной.

Однако при этом возникает **массовое дублирование информации** -- например, дублирование должностей как отдельных структур данных, которые приходится многократно копировать и как-то модифицировать все разом.

**Идея исключения дублирования лежит в основе концепции нормализации баз данных** . К сожалению, нормализация данных часто требует организации связей «многие-к-одному» (множество людей живет в одной области или работает в одной сфере деятельности), которые плохо вписываются в документную модель. В реляционных БД считается нормальным ссылаться на строки в других таблицах по уникальному идентификатору, поскольку выполнение соединений не представляет сложностей. В документоориентированных БД для древовидных структур соединения не нужны, и поддержка их если и имеется, то часто она очень слаба и вторична. А когда СУБД сама по себе не поддерживает полноценные соединения, то их приходится эмулировать в коде приложения через набор запросов к базе данных. У такого подхода есть свои плюсы и минусы.

Мы добрались до вида отношений  **«многие-ко-многим»** , которые, как и соединения, регулярно используются в реляционных БД. На эту тему ведётся многолетняя дискуссия -- как лучше представить подобные отношения в документоориентированных базах данных и NoSQL, и, по большому счёту, мы уходим к самым первым дням компьютеризованных систем баз данных.

Одной из первых так называемых иерархических СУБД была  **IBM IMS** , активно и успешно эксплуатировавшаяся на мэйнфреймах OS/360 и ЕС ЭВМ начиная с 1960-х годов. Как и документоориентированные базы данных, иерархическая IMS хорошо работает в случае связей «один-ко-многим», но со связями «многие-ко-многим» дела у нее обстоят хуже, и вдобавок она не поддерживает соединения. Разработчикам приходилось постоянно дублировать ( **денормализовать** ) данные, контролировать их актуальность, или буквально вручную разрешать ссылки одной записи на другую.

Для устранения ограничений иерархической модели было предложено множество решений. Два наиболее известных — **реляционная модель** (ставшая впоследствии моделью SQL и завладевшая всем миром) и  **сетевая модель CODASYL** .

Модель CODASYL стала обобщением иерархической модели, в древовидной структуре которой у каждой записи была ровно одна родительская запись.  **В сетевой модели у каждой записи могло быть несколько родительских** . Например, в базе могла быть одна запись для области "Ховрино" со ссылкой на неё для каждого живущего там пользователя. Благодаря этому появлялась возможность моделировать связи «многие-к-одному» и «многие-ко-многим».

Ссылки между записями в сетевой модели представляли собой не внешние ключи, а нечто, напоминающее указатели в языках программирования (хотя и хранящиеся на диске). Единственный способ обращения к записи заключался в следовании от корневой записи по этим цепочкам ссылок. Такой путь назывался  **путём доступа (access path)** .

В простейшем случае путь доступа напоминал обход связного списка: начинаем с головного элемента списка и просматриваем по одной записи за раз до тех пор, пока не найдем нужную (сложность O(N)). Но в мире связей «многие-ко-многим» к одной записи может вести несколько различных путей через промежуточные наборы, и программистам, работавшим с сетевой моделью, приходилось постоянно держать в голове эти различные пути доступа, которые при модификации условной «схемы» базы данных вполне могли «сломаться».

Выполнение запросов в модели CODASYL представляет собой перемещение указателя по БД -- итерациями по спискам записей и следованием по путям доступа. Если у записи имеется несколько родительских записей (несколько указывающих на неё ссылок с других записей), то код приложения должен отслеживать все её различные связи. Члены комитета CODASYL признали, что это выглядит как  **навигация по n-мерному пространству данных с соответствующей (очень высокой) алгоритмической сложностью** .

Реляционная модель, напротив, выставляет все данные напоказ:  **отношение (таблица) – это просто набор кортежей (строк)** , и всё. Никаких лабиринтообразных вложенных структур, никаких запутанных путей доступа, необходимых для просмотра данных. Можно прочитать любую строку в таблице, или даже все строки, выбирая те, что соответствуют произвольному условию. Можно прочитать конкретную строку путем объявления некоторых столбцов ключом и выполнения поиска по этому ключу. Можно вставить новую строку в любую таблицу, не беспокоясь о связях по внешним ключам с другими таблицами.

Вдобавок, в реляционной базе данных оптимизатор запросов автоматически принимает решение о том, в каком порядке выполнять части запроса, и какие индексы использовать. По сути, эти решения представляют собой «путь доступа», но важное различие заключается в том, что они принимаются автоматически оптимизатором запросов, а не вручную разработчиком приложения, благодаря чему прикладным программистам редко приходится об этом задумываться.


## Введение в highload и базы данных (задания)

======= 20. В каком порядке исторически развивались СУБД?

[ ] реляционные – иерархические

[ ] иерархические – реляционные

[1 ] иерархические – реляционные – иерархические

[ ] реляционные – иерархические - реляционные

======= 21. Главная проблема документоориентированных БД

[ ] нормализация данных

[ ] денормализация данных

[ 1] навигация по n-мерному пространству данных

[ ] отсутствие SQL

======= 22. Главный плюс реляционных БД

[ ] нормализация данных

[ ] денормализация данных

[ 1] все данные напоказ

[ ] наличие SQL
