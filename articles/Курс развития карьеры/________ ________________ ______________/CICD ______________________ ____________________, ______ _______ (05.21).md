## Continuous Integration/Continuous Delivery (CI/CD): комбинация непрерывной интеграции CI и непрерывного развертывания CD

Я большой поклонник непрерывной интеграции.

Когда меня приглашают проконсультировать небольшие команды и стартапы, и у них ещё не внедрён автоматизированный процесс сборки и непрерывной интеграции, можете не сомневаться, что первое, что я сделаю для них -- это приведу всё это в порядок.

Мне нравится идея автоматизации всего.

**Я люблю делать вещи более эффективными и автоматизированными, когда это только возможно** .

Для меня это как раз то, что представляет собой непрерывная интеграция.

Мы берём медленный, болезненный, утомительный и чреватый ошибками процесс создания программного обеспечения, проведения тестов, сборки, упаковки, развертывания, и превращения его в  **полностью автоматический процесс** .

Но CI гораздо больше, нежели это.

Непрерывная интеграция, или CI, как её обычно называют, также заключается в  **увеличении частоты интеграции проектного кода** , над которым работают отдельные разработчики, чтобы вы не так часто оказывались в пресловутом интеграционном аду.

Чем раньше вы сможете проводить такую интеграцию, пока не накопилось много несмерженного кода, тем быстрее вы будете справляться с проблемами интеграции.

И, наконец, непрерывная интеграция обеспечивает  **обратную связь со всей командой** , причем качественную и быструю обратную связь.

Когда вы можете за две минуты узнать, компилируется ли ваш код в рамках всего проекта, а через пять минут понять, не сломали ли вы что-нибудь своими правками, и при этом видите все результаты в одном месте в централизованном формате, вы получаете очень быстрый и полезный цикл обратной связи.

Чем быстрее цикл обратной связи, тем быстрее может развиваться проект в целом, и тем сильнее может быть улучшено общее качество -- чрезвычайно важный аспект agile-разработки.

В этот момент вы можете подумать: "Хорошо, Сергей, это звучит так, как будто вы пытаетесь продать мне эту штуку под названием CI, но что это вообще такое?".

Ну, я имею в виду, что это действительно звучит классно, и всё такое.

Мне нравится автоматизация. Мне нравится обратная связь. Я не люблю интеграционный хаос.

"Но что же именно представляет собой этот CI, о котором вы говорите?"

Пожалуй, лучший способ понять непрерывную интеграцию - это вернуться немного в прошлое и показать вам, как это всё делалось раньше, и как непрерывная интеграция зарождалась и развивалась с течением времени. Затем, наконец, я проведу вас через рабочий процесс, в котором установлена и работает хорошая система CI.

Давайте начнем путешествие, ok?

### Как раньше создавали код

Я за десятки лет пережил несколько качественно разных подходов к созданию программного обеспечения, и неплохо помню те времена, когда ещё не было никаких модных инструментов для автоматизации разработки.

В начале моей карьеры - середина 1980-х - о какой-либо автоматизации разработки вообще не было речи. Программирование считалось уделом единичных высококлассных специалистов, и простое умение написать программу в несколько сотен строк ценилось очень высоко.

Программирование велось на больших мэйнфреймах ЕС ЭВМ, которые сопровождали десятки инженеров, но и вся сопутствующая работа -- бесперебойная организация деятельности оборудования, в некотором смысле была автоматизирована типовыми командными процедурами.

В середине 1990-х, с массовым распространением персоналок, появилось множество команд разработчиков, где  **каждый программист отвечал за создание собственной сборки программного обеспечения** .

Что я имею в виду под этим?

Ну, в любом достаточно большом приложении будет довольно много компонентов, модулей, библиотек, которые будут включаться в сборку итоговой системы, над которой ведется работа.

Конечно, наличествует большое число файлов исходного кода, которые должны быть скомпилированы.

Часто на машине разработчика требуются и другие ресурсы, например, внешние библиотеки, которые необходимы для создания окончательной версии.

Также могут потребоваться дополнительные шаги до или после компиляции кода, чтобы получить готовый продукт.

В те времена, когда вы работали программистом, вы получали копию исходного кода. Какой-нибудь гуру, работавший над программой последние три года, показывал вам магические заклинания, которые нужно было сделать, чтобы собрать программу, а дальше вы были предоставлены сами себе.

Отдельные разработчики разрабатывали свои собственные способы сборки системы на своих машинах.

Когда приходило время выпускать сборку, готовую для тестирования или даже для развертывания у клиентов, один из разработчиков брал бубен, ходил задом наперед по кругу, зажигал свечи в форме пентаграммы, зажимал 23 клавиши, и на свет появлялась готовая версия программного обеспечения.

Однако у такого способа создания программного обеспечения имелось несколько серьезных проблем.

Самой главной из них была такая, что поскольку каждый разработчик создавал программное обеспечение на своих собственных машинах и немного разными способами, существовала огромная вероятность того, что  **два разработчика с идентичными версиями кода могли создать две совершенно разные версии программного обеспечения** .

Как такое может случиться, спросите вы?

Множество вещей в ИТ может пойти не так, когда у вас нет формальной последовательности, и каждый следует своему собственному процессу выполнения чего-либо.

На машинах разработчиков могут быть установлены разные версии внешних библиотек -- библиотек компилятора, системных библиотек и т. п. Даже слегка различающиеся версии ОС могут вносить свои погрешности новыми версиями некоторых системных файлов.

Разработчики могли считать, что у них один и тот же исходный код, но на самом деле они забывали получить последние файлы из системы версионного контроля, или случайно вносили локальное изменение в файлы, что не позволяло полноценно объединить код, или, что ещё хуже, получалась работающая версия, но совсем кривая.

Структура файлов или каталогов может быть разной, а это, в свою очередь, может привести к различиям в том, как на самом деле работает программное обеспечение.

Множество вещей могло пойти не так.

Другая серьезная проблема заключалась в том, что, поскольку разработчики обычно имели доступ по сети лишь к файловому серверу (интернета ведь ещё не было), постоянно возникали конфликты интересов с некомпилирующимся кодом.

Бывало очень забавно, и при этом хотелось плакать, когда несколько разработчиков проверяют плохой код в течение нескольких дней или даже недель, а потом, когда кто-то наконец пытается собрать всё вместе и обнаруживает, что оно фатально сломано, он понятия не имеет, какое конкретно изменение вызвало проблемы.

Кроме того, например я работал в проектах, где на создание одной сборки программного обеспечения уходили буквально часы. Большой проект на Си, очень медленный компилятор и ещё более медленный сборщик....

Нет ничего хуже, чем запустить сборку на своей машине на 4-5 часов, а потом обнаружить, что она завершилась фейлом.

### Затем появились серверы сборки

Одним из первых способов решения подобных проблем стало  **внедрение серверов сборки** .

Идея заключается в том, что вместо того, чтобы каждый разработчик собирал программное обеспечение на своей машине,  **используется один центральный сервер сборки** , который правильно настроен, содержит все нужные версии библиотек и т. д.

Разработчик мог запустить сборку на сервере сборки, или сервер сборки автоматически собирал программное обеспечение каждую ночь.

Сначала это начиналось с  **еженедельных сборок** .

Таким образом, у вас, по крайней мере, была официальная еженедельная сборка программного обеспечения, которая объединяла все изменения всех разработчиков за неделю и была создана единообразно.

Однако очередная проблема с еженедельной сборкой заключалась в том, что часто - особенно в больших командах - при попытке создать такую еженедельную сборку  **возникали проблемы с интеграцией** .

Часто за обеспечение работы еженедельной сборки отвечал разработчик или системный администратор, и они вручную исправляли все проблемы, которые ломали сборку, и разбирались вместе с программистами с конфликтующими изменениями, чтобы попытаться решить их.

Это было конечно лучше, нежели отсутствие сервера сборок, но не намного.

В конце концов, стала популярной  **идея ночных сборок** .

Идея заключалась в том, что если мы будем интегрировать код ежедневно, а сервер сборки будет создавать новую сборку каждую ночь, то будет меньше времени для накопления и усугубления больших проблем, и мы сможем отлавливать проблемы намного раньше и оперативнее.

Сначала эта идея казалась безумной.

Вы не поверите, сколько сопротивления я однажды получил, когда впервые предложил ночную сборку в одной из компаний, где я работал.

Но со временем это стало нормой, и это действительно решило довольно много проблем.

Ночные сборки на центральном сервере помогали всем действовать синхронно и быть, так сказать, на одной волне, а если ночная сборка ломалась, то первоочередной задачей каждого было вернуть ей работоспособность.

Идея ночной сборки подтолкнула к необходимости  **фактической автоматизации самого процесса сборки** .

Это было очень здорово.

Для того чтобы последовательно собирать программное обеспечение каждую ночь, нужен какой-то автоматизированный способ собрать весь код вместе, скомпилировать его и выполнить все остальные шаги, необходимые для создания рабочей сборки.

**Это была эпоха множества скриптов** , которые создавались для автоматизации процесса сборки программного обеспечения, по крайней мере, на выделенной машине сборки. Для разработчиков всё ещё считалось вполне нормально иметь свои собственные локальные процессы сборки.

По мере того, как agile-подходы становились всё более популярными, а идея модульного тестирования получала всё большую поддержку, ночные сборки, которые просто компилировали код и формировали финальный билд, были недостаточно хороши.

**Нам были нужны более короткие циклы обратной связи.**

Вся команда оказывалась в дауне, если кто-то отправлял вечером накануне на сборку плохой код, и мы узнавали об этом только на следующее утро.

Нам нужен был **способ надёжно собирать систему несколько раз в день** и проводить другие проверки качества продукта в дополнение к простому "оно нормально компилируется".

### Итак, непрерывная интеграция

Ночные сборки были сложным шагом, но они не шли ни в какое сравнение со сложностями в убеждении руководства в необходимости непрерывной интеграции -- идеи полной сборки каждый раз, когда кто-то вносит изменения в кодовую базу.

Зачем вам это нужно? спрашивали они. У нас уже есть ночные сборки.
Вы хотите постоянно собирать код? Я не понимаю.
Минутку, вы хотите, чтобы я сказал всем разработчикам, что они должны проверять свой код на корректность сборки по нескольку раз в день? Вы издеваетесь?

Сопротивление было значительным, но постепенно оно было преодолено. Непрерывная интеграция стала не просто приятной мечтой, а скорее обязательным условием для того, чтобы иметь достаточно короткие циклы обратной связи для завершения работы на каждой итерации.

Основная проблема, однако, заключалась в том, как это сделать хорошо.

Как мы можем на самом деле собирать билд каждый раз, когда новый код появляется в системе версионного контроля?

Ответом стали  **серверы непрерывной интеграции** .

Было разработано специальное программное обеспечение, которое можно запускать на сервере сборки в режиме обнаружения изменений в системе контроля версий, извлечения последних модификаций и запуска новой сборки.

Очень скоро разработчики ощутили существенное сокращение времени на непродуктивных сборках, и обратная связь между кодом и результатом стала еще быстрее.

Непрерывная интеграция развивалась, включила в себя запуск модульных тестов и метрик качества кода, линтеров и статических анализаторов кода.

Самым большим препятствием было - и по большей части остается до сих пор -  **заставить разработчиков отправлять в мастер свои комиты часто** , чтобы можно было получить обратную связь довольно быстро.

Теперь, с внедрением CI, можно не только в течение нескольких минут узнать, не мешают ли очередные правки кода компиляции всего проекта, но и выяснить, не были ли нарушены какие-либо модульные тесты, и даже сделать такие вещи, как запуск автоматических нагрузочных тестов.

Жизнь прекрасна.

### Пример рабочего процесса CI

Итак, на данный момент вы, вероятно, получили представление о том, что такое непрерывная интеграция, познакомившись с проблемами, которые она решала, и с тем, как она развивалась.

Но вы всё ещё не совсем "поняли" -- и это нормально.

Давайте рассмотрим примеры рабочих процессов с использованием непрерывной интеграции, и тогда, возможно, всё станет немного понятнее.

**Check in code**

Классическое понятие командной разработки, подразумевающее загрузку кода в репозиторий основной ветки (мастер), чтобы ответственный (например, тимлид) мог просмотреть код и окончательно обновить версию проекта.

Цикл начинается с того, что вы отправляете свой локальный код в мастер.

Конечно же, вы сперва запустили сборку на своей локальной машине и выполнили все модульные тесты, прежде чем решиться "запушить" код в основной репозиторий и рискнуть сломать сборку... верно?

**Запущена новая сборка**

Программа CI, установленная на сервере сборки, только что обнаружила изменение в ветке версионного контроля, за которой она следит.

Это же ваш код! Вот это да!

Сервер CI запускает новое задание -- сборку проекта.

**Check out code**

Первая вещь, которую сделает это задание -- это check out (выгрузка) всего нового кода проекта с вашими последними изменениями в свой рабочий каталог.

**Компиляция**

На этом этапе обычно запускается какой-либо скрипт сборки, чтобы фактически скомпилировать и собрать код.

Скрипт, сценарий сборки выполняет команды для компиляции исходного кода и его сборки. Существуют различные системы поддержки подобных скриптов, входящие, например, в экосистему конкретного языка программирования.

Скрипт также подключит любые внешние библиотеки и всё остальное, необходимое для компиляции кода и пострения билда.

Если код не удастся скомпилировать, сборка сразу остановится, и будет выдано сообщение об ошибке.

Это называется  **сломать сборку (breaking the build)** , и это плохо.

Я поверил вам, когда вы заявили, что успешно скомпилировали код на своей машине.

Позор!

**Запуск линтеров**

Если код был собран правильно, запускаются статические анализаторы и линтеры для измерения определенных показателей качества кода.

Если вы не знаете, что это такое, ничего страшного.

Это специальные умные инструменты, которые автоматически изучают стиль и семантику кода и пытаются найти в нём возможные ошибки или нарушения лучших практик кодирования.

Результаты их работы сохраняются и доступны в качестве отчётов по завершении сборки.

Некоторые сборки могут быть настроены на отказ, если не был достигнут определенный порог для метрик качества кода, полученных с помощью линтеров.

Вообще, линтеры и статические анализаторы -- это полезный проактивный способ поддержания кода в рабочем состоянии и предотвращения легко устранимых ошибок и потенциальных ловушек.

**Прогоняются модульные тесты**

Если к этому моменту всё было в порядке, задание CI запускает модульные тесты.

Юнит-тесты запускаются на только что скомпилированный код, и результаты записываются для последующего анализа.

Обычно, если хоть какие-то модульные тесты не проходят нормально, это приводит к сбою всей сборки.

Я настоятельно рекомендую именно такой подход, потому что если вы начнете спускаться по скользкой дорожке игнорирования фейлов юнит-тестов, вам будет крайне трудно подняться обратно. Очень скоро все будут знать, что некоторые модульные тесты не срабатывают, и со временем сами модульные тесты станут бессмысленными.

**Готовятся отчёты**

Наконец, готовится отчёт о результатах фактической сборки.

Отчет будет содержать данные о том, прошла или не прошла сборка, сколько времени занял процесс, как выполнялись отдельные этапы, значения метрик качества кода, выполненные модульные тесты и любые другие важные данные.

Документация также может быть автоматически сгенерирована на этом этапе.

Результаты могут быть настроены на рассылку команде по электронной почте и в мессенджеры -- особенно в случае неудачи. Кроме того, большинство программ CI имеют удобный веб-интерфейс, где каждый может увидеть результаты работы последней и предыдущих сборок.

**Софт упаковывается**

Теперь собранное программное обеспечение упаковывается в форму, в которой оно будет развёрнуто на сервере или инсталлировано на целевой платформе.

Этот шаг сильно зависит от того, что именно представляет из себя конечный продукт.

Обычно берётся скомпилированный код и любые внешние ресурсы, файлы, библиотеки, иные зависимости, и упаковывается в некоторую структуру, необходимую для получения полноценного автономно развертываемого или инсталлируемого модуля.

В простом случае, например, может быть создана файловая иерархия, содержащая все нужные файлы, а затем всё это может быть упаковано в zip-архив.

На этом этапе задание сборки может также применить какой-либо вид тэгирования в системе управления исходным кодом, чтобы отметить новую версию программного обеспечения.

**Код при необходимости деплоится (Continuous Deployment)**

Этот последний шаг (как и предыдущий) необязателен.

Но всё больше команд в дополнение к CI выполняют непрерывное развертывание CD, при котором они деплоят код непосредственно на тестовый сервер, или, если они действительно смелые, прямо в продакшен.

**Завершено**

И это всё.

Конечно, существуют некоторые вариации этих шагов, и могут добавляться дополнительные шаги, но основная идея заключается в том, чтобы **собрать код, проверить его на наличие проблем и подготовить к развертыванию** -- все это происходит автоматически при регистрации нового кода в рабочей ветке.

Такая схема позволяет нам очень быстро узнать, вызвало ли новое изменение в системе ошибку, и сразу же исправить её.

Несмотря на то, что я рассказал обо всём этом в относительно небольшом занятии, я не хочу, чтобы это выглядело слишком просто.

В серьёзных организациях существуют отдельные должности для поддержки CI/CD -- например, инженеры по сборке, которые могут тратить немало времени на создание и развитие хорошо отлаженного процесса непрерывной интеграции, и существует множество разных взглядов, как это должно быть сделано, и каковы тут лучшие практики.

### CI-серверы и CI-софт

Одним из важнейших компонентов непрерывной интеграции становится, очевидно, сам софт для поддержки CI.

Без него нам пришлось бы писать пользовательские скрипты и, по сути, программировать собственные серверы сборки. Это, кстати, совсем не редкость во многих небольших командах.

К счастью, многие умные разработчики быстро поняли ценность использования готового ПО CI, которое помогает автоматизировать большинство общих задач непрерывной интеграции.

**Большинство систем CI работают очень похоже, делая простым - или, по крайней мере, более лёгким - реализацию рабочего процесса, подобного тому, что я описал выше** .

На самом деле существует довольно много CI-серверов, остановлюсь на нескольких наиболее часто используемых.

### Популярный CI-софт

[**Jenkins**](https://github.com/jenkinsci/jenkins) -- это практически "народное" программное обеспечение для CI.

Это Java-система, которая изначально была создана для поддержки CI в среде Java, но она стала настолько популярной и простой в использовании, и её возможности так расширились, что теперь её можно использовать практически для любой технологии.

Jenkins очень легко установить и запустить, поскольку она содержит собственный встроенный веб-сервер.

Она также имеет огромное количество всевозможных плагинов.

Если вы попытаетесь сделать что-то оригинальное в Jenkins, есть большая вероятность, что кто-то уже написал плагин, который сделает это за вас. Это одна из основных причин, почему я люблю и рекомендую Jenkins, которая вдобавок активно развивается.

**Hudson**

Это была длинная и полная драматизма история о расколе между Hudson и Jenkins.

До появления Jenkins существовал Hudson.

Было несколько разборок между разработчиками, Jenkins отделился от Hudson, а Hudson продолжил развиваться самостоятельно.

Развитие Hudson контролировала Oracle, и он стал не так хорош, как Jenkins, потому что Kohsuke Kawaguchi -- автор Hudson, и ключевые члены его команды, перешли в Jenkins.

Ну и в 2016-м Hudson прекратил своё существование.

[**Travis CI**](https://travis-ci.org/)

Travis - ещё одна популярная программа CI, но работает она немного по-другому.

Travis CI размещается в облачном хостинге и предоставляется как услуга.

Другими словами, вы не устанавливаете Travis CI на свои серверы, вы подписываетесь на неё.

В первую очередь Travis предназначена для поддержки проектов, размещенных на GitHub.

Travis набирает популярность, поскольку всё больше проектов размещаются на GitHub, и он сам по себе хорошо разработан и прост в использовании.

Кроме того, приятно, что не нужно поддерживать собственный сервер сборки.

**Team Foundation Server / Azure DevOps Server**

На мой взгляд, конвейер CI в этом продукте Microsoft ранее был довольно упрощён, чтобы всерьёз конкурировать с некоторыми другими, более популярными предложениями, хотя я уже несколько лет не изучал его новые возможности. Полагаю, если вам нужно что-то простое - и это должно быть решение Microsoft - этот вариант может вам подойти.

[**TeamCity**](https://www.jetbrains.com/teamcity/)

Это CI-разработка российской компании JetBrains. Имеется бесплатная версия, но сам по себе это лицензионный продукт.

Поэтому, если вы ищете что-то с профессиональной поддержкой в России, это хороший вариант.

Я знаю немало команд, разрабатывающих под .NET, которые используют TeamCity для своих нужд CI.

Я привел лишь небольшую выборку наиболее популярных систем поддержки CI, но их существует довольно много. Вы можете погуглить "top ci cd tools текущий-год". Например, в классическую линейку ворвался весьма симпатичный [**Buddy**](https://buddy.works/).
