## 18. Условное выражение

Условное выражение записывается так:

```
if выражение-1 then выражение-2 else выражение-3 
```

Вторую часть else можно опускать:

```
if выражение-1 then выражение-2 
```

Можно сокращать комбинации else if до elif:

```
if выражение-1 then выражение-2 
elif выражение-3 then выражение-4
...
elif выражение-n then выражение-n+1
else выражение-n+2
```

Выражение-1 должно быть логического типа, остальные выражения произвольных типов.

```
let s = "123"
if s = "12" then
    printfn "1" 
elif s = "21" then
   printfn "2" 
else
   printfn "3" 

let odd n = n % 2 = 1 
let test_str s = if odd(String.length s) then "odd" else "even"
test_str "1234"
```

**[[ далее ]](https://skillsmart.ru/fp/fsh/h45f1b0def.html)**

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/a8s910a3f8.html)**

---

**Ответы на задания 17**

```
let rec pow = function
    | (s, 0) -> ""
    | (s, i) when s = "" -> ""
    | (s, i) when i < 0  -> ""
    | (s, i) -> s + pow(s, (i - 1))

let rec isIthChar = function
    | (s, n, c) when n > (String.length s) - 1 -> false
    | (s, n, c) when n < 0 -> false
    | (s, n, c) when s.[n] = c -> true
    | (s, n, c) -> false

let occFromIth (s, n, c) = 
    let rec check = function
        | (n, c, acc) when n > (String.length s) - 1 -> acc
        | (n, c, acc) when n < 0 -> 0
        | (n, c, acc) when c = s.[n] -> check (n + 1, c, acc + 1)
        | (n, c, acc) -> check (n + 1, c, acc)
    check (n, c, 0)
```


## 19. Перегрузка функций и операторов

**19.1. Перегрузка**

При обращении к функции или оператору, которые имеют несколько реализаций (перегрузок) для разных типов данных (например, оператор + для чисел и строк) система типов F# придерживается таких правил:
-- если тип может быть выведен из контекста применения, то символ оператора интерпретируется как функция для этого выведенного типа;
-- в противном случае используется перегруженный оператор для подходящего типа по умолчанию.

Если оператор может быть применён к типу int, то int считается типом по умолчанию.

```
let cube x = x * x * x
```

По умолчанию тип функции cube равен int -> int.

F# позволяет явно задавать типы как аргументов функций, так и её результата.

Явное указание типа аргумента как float:

```
let cube (x: float) = x * x * x
```

Явное указание типа результата функции cube как float:

```
let cube x : float = x * x * x
```

Явное указание типа выражения, вычисляемого функцией, как float:

```
let cube x = x * x * x : float
```

**19.2. Функции как объекты первого класса (first-class citizens)**

Так как функции в F# -- базовые типы данных, то их можно передавать в качестве аргументов другим функциям или возвращать как результат работы функции.

Функции, использующие другие функции в качестве объектов первого класса, называются функции высших порядков (high-order functions, HOF).

**19.3. Нонфиксная запись**

Инфиксный оператор + и ему подобные могут быть представлены в нонфиксной записи, когда оператор берётся в круглые скобки: (+).

Тип нонфиксного оператора (+) есть int -> int -> int.

Ассоциация оператора типа -> правая, поэтому тип int -> int -> int представляется как int -> (int -> int), где (int -> int) есть функция.

По сути, результат работы нонфиксного оператора, получающего на вход единственный аргумент, есть функция.

```
let plus3 = (+)3
printfn "%d" (plus3 5)  // 8
```

Применение (application) функции имеет левую ассоциацию:

```
(+) 3 5 = ((+)3) 5 // true
```

**[[ далее ]](https://skillsmart.ru/fp/fsh/lb2cc952d6.html)**

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/i4c57d738f.html)**


## 20. Композиция и каррирование

**20.1. Композиция функций**

В математике композиция двух функций f и g (f o g) означает следующее:

```
(f o g)(x) = f( g( x ) )
    
```

Если f(y) = y - 5, и g(z) = z^3, то

```
(f o g)(z) = f(g(z)) = f(z^3) = z ^ 3 - 5
```

Инфиксный оператор << реализует композицию функций; оба его параметра -- функции.

```
let f = fun y -> y - 5
let g = fun z -> z * z * z
let h = f << g
printfn "%d" (h 2) // 2*2*2 - 5 = 3

let h2 = ((fun y -> y - 5) << (fun z -> z * z * z)) 2 // 3
```

Композицию функций можно выполнять и в другом порядке с помощью оператора >>.

```
let h = f >> g // h 2 = g( f(2) ) = g( -3 ) = -27 
```

**20.2. Частичное применение функций, каррирование**

Частичное применение -- это передача функции неполного числа аргументов, когда в результате получается тоже функция.

Функции в F# имеют один аргумент, поэтому передача нескольких аргументов -- это формально применение функций одного аргумента к списку аргументов по очереди.

Например, каррированная функция f x ожидает один параметр y, её тип int -> int -> int (или int -> (int -> int)):

```
let f x = fun y -> y - x
let minus10 = f 10
printfn "%d" (f 2 3) // +1
printfn "%d" (f 10 12) // +2
printfn "%d" (minus10 12) // +2
```

F# допускает более компактную форму записи, без fun:

```
let f x y = y - x
let minus10 = f 10
printfn "%d" (minus10 12) // +2
```

**20.3. Задания**

20.3.1. Напишите функцию vat: int -> float -> float, так что vat n x увеличивает x на n процентов (0 <= n <= 100).

20.3.2. Напишите функцию unvat: int -> float -> float такую, что

```
unvat n (vat n x) = x
```

20.3.3. Напишите функцию min: (int -> int) -> int, так что min(f) вычисляет минимальное целое положительное число n, когда f(n) = 0. Подразумевается, что такое натуральное число существует всегда.

Шаблон для отправки на сервер:

```
// 20.3.1
let vat n x = ...

// 20.3.2
let unvat n x = ...

// 20.3.3
let rec min f = ...
```

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/h45f1b0def.html)**
