## Основы тестирования и QA

Большинство (очень большое большинство) разработчиков даже понятия не имеют о том, как на самом деле правильно проводить тестирование, и насколько умение тестировать код и систему в целом может быть ценным для разработчиков, которые действительно хотят сделать профессиональную карьеру.

Многим успехам в моей карьере разработчика я обязан своему опыту в тестировании, которое постепенно и привело меня к серьёзным формальным темам и математике. Этот опыт заставлял меня смотреть на код, который я писал, немного по-другому, и понимать, что моя работа программистом заключалась не только в реализации функций и исправлении ошибок, но и в том, чтобы заставить софт, который я писал, работать правильно, и так, как я и планировал.

Тестирование выглядит как простая и очевидная идея, но если вы не знаете хотя бы основополагающих принципов тестирования, то вы, вероятно, пока просто не представляете, что на самом деле означает "код работает правильно, и так, как было задумано".

### Ключевой принцип, скрывающийся за тестированием

Обычно начинающие программисты не понимают, зачем нужно тестирование, с неохотой и для галочки изучают стандартные библиотеки тестировщика, и думают, что это второстепенная тема.

Действительно, на поверхностный взгляд это может показаться немного излишним.

Нам действительно нужно тестировать этот код? Я запустил его на своей машине, и он отлично работает, так что давайте его просто отправим на рабочий сервер.

**Тестирование, по сути, очень важно для снижения проектных рисков.**

Цель тестирования -- отнюдь не поиск ошибок, как обычно принято считать, у него даже нет задачи сделать проект лучше. Тестирование нужно прежде всего для снижения рисков путем проактивного поиска и устранения проблем, которые могли бы наиболее сильно повлиять на удовлетворённость пользователей.

Что же сильнее всего влияет на удовлетворённость пользователей?

Это, конечно,  **высокая частота ошибок, или ненужные или странные функциональные возможности, а также серьёзность возникающих проблем** .

Если вы сделали ошибку в бухгалтерском софте, из-за которой оно зависает на пару секунд всякий раз, когда в форму вводится сумма выше 1000 рублей, это не оказало бы большого влияния на правильность работы; однако когда такое зависание происходит достаточно часто, оно может стать очень раздражающим для пользователя.

С другой стороны, если вы сделали такую ошибку в бухгалтерском софте, которая приводит к повреждению всех данных в файлах в среднем один раз из тысячи при сохранении данных, это было бы огромным ударом по качеству, хоть и частота его очень низка.

Причина, по которой я определяю тестирование программного обеспечения через такие понятия, заключается в том, что - как скажет вам любой тестировщик -  **вы никогда не сможете найти все ошибки в коде** , и вы никогда не сможете протестировать все возможные варианты входных данных.

Итак, идея заключается не в том, чтобы найти все возможные аспекты в системе, которые ошибочны реально или потенциально, и даже не в том, чтобы проверить программное обеспечение по спецификации - как иногда тестирование определяется - потому что и то, и другое невозможно.

**Основная идея тестирования заключается в снижении риска** -- риска, что пользователь подвергнется сильному негативному воздействию при использовании создаваемого софта.

Как правило, для этого определяется по приоритетам, какие подсистемы, скорее всего, будут иметь наибольшее влияние (т.е. риск) на пользователя, а затем принять решение о наборе тестов, которые проверят требуемую функциональность и типичные use cases (сценарии использования) в этих подсистемах.

Когда фактическая функциональность отклоняется от желаемой, баг обычно регистрируется в системе управления рабочими задачами или контроля за ошибками (bugtracker, jira, ...), и приоритет этих багов в смысле срочности их исправления определяется в зависимости от его тяжести.

Одни ошибки исправляются очень быстро, другие вследствие достаточно слабого влияния просто отмечаются и оставляются до лучших времён.

### Основные типы тестирования

Подобно тому, как в мире разработки существует множество концепций и методологий разработки ПО, существует и множество способов тестирования, и их перечень постоянно меняется.

Даже по названиям.

Наименование "тестировщик" подчас может быть воспринято как лёгкое оскорбление; люди, занимающиеся тестированием, предпочитают, чтобы их называли  **специалистами по контролю качества QA (или по обеспечению качества)** .

Однако других людей наоборот может оскорбить такое название -- им нравится, чтобы их называли именно  **тестировщиками** .

Так или иначе, давайте поговорим о различных видах тестирования, чтобы вы получили общее представление об этой теме, когда кто-то бросается подобными терминами, которые вы часто услышите на работе программистом.

Это конечно далеко не исчерпывающий список.

### Тестирование чёрного ящика

Одна из наиболее распространенных форм тестирования (скорее, это описание метода тестирования) считается тестирование чёрного ящика.

Тестирование чёрного ящика - это просто тестирование, когда мы считаем, что  **сама тестируемая система для нас чёрный ящик** .

При тестировании чёрного ящика вас интересуют только его входы и выходы. Вас не волнует, как выходы формируются фактически.

Вы ничего не знаете ни о коде, ни о том, как он работает -- только то, что для заданного набора входов в программе должен быть получен заданный набор выходов.

Большинство тестов проводится именно таким образом, потому что в основном этот подход беспристрастен. Это либо работает, либо нет.

### Тестирование белого ящика

Тестирование белого ящика - полная противоположность тестированию чёрного ящика.

В тестировании белого ящика  **у вас есть некоторое представление о том, что происходит внутри программы** .

Часто юнит-тестирование называют тестированием белого ящика, но я не согласен. Модульное тестирование вообще не тестирование, по большому счёту - об этом мы поговорим в отдельном занятии.

Вместо этого тестирование по методу белого ящика - это когда вы знаете, каковы некоторые внутренние компоненты системы с точки зрения разработчика и, возможно, имеете доступ к реальному исходному коду, который вы используете для более точной организации вашего тестирования.

Например, вы посмотрели на код, который выполняет сложные финансовые вычисления, и увидели, что имеется один модуль кода, который выполняет один набор вычислений для крупных сумм выше некоторого порога, и другой модуль вычислений для любых других сумм -- в таком случае вы можете создать тесты, которые будут учитывать оба этих сценария.

При тестировании чёрного ящика вы бы не имели возможности узнать об этих двух условиях, так что вы вряд ли смогли бы тщательно протестировать их оба, и ошибка, специфичная для сумм в конкретном диапазоне, вполне могла прокрасться в рабочую версию.

### Приёмочное тестирование

Приёмочное тестирование известно под самыми разными названиями.

Одни называют это бета-тестированием, другие -- формальным тестированием, третьи -- системным тестированием, и т. д.

Основная идея приёмочного тестирования заключается в том, что  **вы выполняете ряд тестов, которые проверяют фактические требования и ожидания заказчика** , и тесты, которые пытаются сломать систему в целом.
Я имею в виду, что вам недостаточно просто проверять разные части приложения по отдельности.

Такого рода тестирование может включать проверку функциональности системы или проверку удобства её использования, или и то, и другое.

Идея в том, что  **приёмочное тестирование проверяет то, что ожидается** , а не то, что происходит на самом деле.

### Автоматизированное тестирование

Это ещё один распространённый вид тестирования, который может принимать самые разные формы, но я придерживаюсь такого определения, что автоматизированное тестирование как и любое тестирование, подразумевает  **обычное выполнение тестов и верификацию результатов, только эти процессы автоматизированы** .

Таким образом, вы можете автоматизировать тестирование веб-приложения, запустив скрипты, которые открывают веб-страницу, вводят некоторые данные, нажимают некоторые кнопки, а затем проверяют некоторые результаты на странице.

Также можно автоматизировать тестирование API, написав скрипты, которые обращаются к API с различными данными, а затем проверяют возвращаемые результаты.

Тестирование сегодня всё больше и больше движется в направлении автоматизированного тестирования, и тут активно подключается AI, потому что прогон большого количества тестовых сценариев вручную снова и снова бывает утомительным и дорогостоящим, а ошибки вследствие усталости или невнимательности нередко пропускаются.

### Регрессионное тестирование

Определённая сложность объёмного тестирования подводит нас к так называемому регрессионному тестированию, которое, по сути, делается для проверки того, что  **система всё ещё работает так, как раньше** , и новые правки её не поломали.

**Цель регрессионного тестирования -- убедиться, что программное обеспечение не ухудшается по функциональности** .

Это чрезвычайно важно в современных гибких методологиях разработки (им посвящено отдельное занятие), когда программное обеспечение разрабатывается постепенно, и есть постоянный потенциальный риск, что добавление новых функций может сломать существующий код.

**Большинство автоматизированных тестов -- регрессионные** .

На самом деле, можно даже заявить, что все автоматизированные тесты -- регрессионные, так как цель автоматизации тестов заключается в том, чтобы они могли легко запускаться многократно.

### Функциональное тестирование

Функциональное тестирование -- это ещё одно широкое понятие, которое подразумевает, что  **то, что тестируется, является фактической функциональностью системы** .

Это может показаться очевидным.

Вы можете подумать: "да, а что вы ещё можете тестировали, как не функциональность системы?".

Но на практике оказывается, что вы можете также тестировать всевозможные вещи, не связанные напрямую с функциональностью: производительность, удобство использования, отказоустойчивость, безопасность, масштабируемость -- этот список можно продолжать и продолжать, поверьте.

Таким образом, функциональное тестирование -- это такой вид тестирования, когда вы действительно проверяете, чтобы система делала то, что она должна делать с функциональной точки зрения.

Если я введу вот такое значение и нажму вот эту кнопку, получу ли я ожидаемый результат?

Мне все равно, сколько времени это займёт. Меня не волнует, что экран будет долго мигать ярко-красным цветом, а компьютер уйдёт на перекур -- получу ли я в конце концов свой результат?

### Исследовательское тестирование

Исследовательское тестирование звучит гордо, хотя при этом некоторые называют его тестированием ленивых задниц.

Но, безусловно, есть некоторая легитимность идеи исследовательского тестирования.

Идея исследовательского тестирования, когда оно проводится правильно, заключается в том, что у вас есть только некоторые рекомендации и базовый план того, какие области вы собираетесь тестировать, и как вы собираетесь их тестировать.

У вас нету реальных тестовых сценариев --  **вы просто исследуете систему, ищете в ней вещи, которые могут быть неправильными, или поведение, которое оказывается неожиданным** .

Обычно сеансы исследовательского тестирования записываются, так что в случае обнаружения ошибки проблема может быть воспроизведена путем возврата по шагам.

Хотя я не большой сторонник тестирования такого рода, надо признать его достоинства, так как исследовательское тестирование иногда может выявить ошибки, которые пропускали все рациональные тестовые сценарии.

### Другие виды тестирования

Мы конечно лишь очень поверхностно коснулись различных типов тестирования.

Существует немало других форм, например:

- нагрузочное тестирование: как программа ведёт себя под высокой нагрузкой;
- тестирование производительности: изучение, какова будет производительность приложения в различных сценариях использования;
- тестирование на восстановление после отказа: проверка, как приложение работает после сбоев или отказа оборудования;
- тестирование безопасности: проверка безопасности системы;
- юзабилити-тестирование: оценка эргономичности, удобства и эффективности интерфейса пользователя.

Этот список можно пополнять ещё долго.

Я лишь постарался познакомить вас с основами тестирования, о которых вы услышите в повседневных разговорах разработчиков.

### Но позвольте!..

Тестирование черного ящика очень похоже на функциональное тестирование. Какая между ними разница? Да и регрессионное тестирование мало чем отличается от автоматизированного тестирования.

Ладно, тсcc... Я собираюсь рассказать вам маленький секрет, который, вроде как, бесит QA-специалистов, тестировщиков.

Так вот...  **Многие из этих терминов в тестировании в основном одно и то же** .

Иногда мне кажется, что сами тестировщики специально придумываают кучу терминов, чтобы добавить солидной сложности в свою профессию, которая по своей сути проста.

Не поймите меня неправильно, **тестирование -- это реально важно, я всегда его делаю и призываю к этому других, и оно конечно требует навыков, чтобы быть хорошим в этом деле, но это не так уж и сложно...** на самом деле.

В принципе, функциональное тестирование может быть как белым, так и чёрным ящиком; обычно это чёрный ящик.

Тестирование черного ящика и белого ящика просто относится к тому, как именно проводится функциональное тестирование или другое тестирование. На самом деле это просто тип функционального тестирования.

Вы смотрите на код, чтобы получить подсказки, что именно нужно тестировать -- или вы относитесь ко всему проекту, как к таинственному чёрному ящику?

Тестирование чёрного ящика -- это просто концепция или идея тестирования на более высоком уровне, без возможности посмотреть на внутреннюю часть, на реализацию.

Если вы проводите эффективное функциональное тестирование, вы, вероятно, делаете это в форме чёрного ящика; хотя вполне возможно, что просмотр кода может дать вам представление о некоторых крайних или особых случаях, которые вы, возможно, захотите проверить отдельно и которые вы, возможно, пропустили бы в противном случае.

В случае автоматизированного тестирования в сравнении с регрессионным тестированием, опять же, мы имеем дело с более высоким уровнем.

Регрессионное тестирование -- это концепция. Идея заключается в том, что когда что-то ломается -- или прежде, чем такое случится -- необходимо создать некоторый набор тестов, которые гарантируют, что уже наработанная функциональность системы не ухудшится.

Автоматизированные тесты очень хорошо служат этой цели, так как, ну... они автоматизированы.

Таким образом, практически все автоматизированные тесты будут регрессионными.

Если вы хотите пройти собеседование на должность тестировщика, вы, вероятно, должны знать вот это вот всё и уметь объяснить, почему исследовательское тестирование на самом деле будет правильным способом тестирования, и что пользовательское тестирование и приёмочное тестирование -- не одно и то же.

Но если вы разработчик, честно говоря, для вас важно просто иметь представление об этих концепциях и о популярных терминах, и конечно понимать реальную идею тестирования, которая заключается в снижении риска.

Так что не беспокойтесь о семантике и сосредоточьтесь на ключевых идеях в этом занятии. Вот что важно.

### Процесс тестирования

В разных компаниях вы будете встречаться с очень разными представлениями о том, как следует проводить тестирование.

Вы также познакомитесь с множеством формальных спецификаций, подготовленных ответственными за тестирование, которые называются в компании "процессом тестирования".

Итак, опять же, я уже говорил, что идея заключается не в том, чтобы регламентировать все нюансы или смоделировать идеальный процесс тестирования, а в том, чтобы вы получили представление о процессе тестирования в целом и о его последствиях.

Я сторонник прагматичного подхода и к жизни, и к тестированию.

**Тестирование обычно начинается с разработки некоего плана тестирования.**

Каким образом всё будет проверяться?

Какова наша стратегия тестирования?

Какие виды тестирования мы будем проводить?

Какие функции, модули... мы будем тестировать?

Каков наш план?

Когда такой план подготовлен, далее тесты обычно разрабатываются на высоком уровне -- исходя из требований или функциональных возможностей системы.

На этом этапе тестировщик может подготовить общий список тестов, которые будут выполняться, уточнить, какие случаи и сценарии будут проверяться, а также подумать, что будет необходимо для выполнения этих тестов.

Далее, вся эта информация загоняется в систему управления задачами.

После этого тесты обычно создаются и выполняются.

Иногда это происходит за один шаг.

Результаты выполнения тестов фиксируются, и выявленые ошибки, как правило, заносятся в какую-либо систему отслеживания ошибок или в общую систему управления задачами.

Ошибки имеют приоритет над другими заданиями и обычно немедленно отправляются разработчикам для исправления.

Исправленные ошибки повторно тестируются, и этот цикл продолжается до тех пор, пока система не будет соответствовать некоторому стандарту качества кода в организации.

И это, в основном, всё.

Планируйте тестирование; проектируйте тесты; пишите тесты; выполняйте тесты; находите ошибки; исправляйте ошибки; выпускайте систему в эксплуатацию.

### Как работает тестирование в гибких командах

Вышеописанный стандартный процесс тестирования, как правило, сталкивается с некоторыми проблемами в agile-команде, где новые функции реализуются и выкатываются в продакшен каждые пару недель или даже быстрее.

Многие команды пытаются либо строго следовать стандартному процессу тестирования, либо полностью выбросить его в окно вместо того, чтобы работать с ним в гибком жизненном цикле.

Оба этих подхода неправильны.

Вместо этого, **основное внимание надо серьёзно переключить на разработку конкретных тестовых случаев и тестовых сценариев заранее, еще до того, как любой код будет написан** (изучите занятие по TDD), и сократить процесс тестирования по той же схеме, как и разработка выполняется в agile.

Это просто означает, что мы должны разбивать вещи на мелкие кусочки и иметь немного более короткий цикл обратной связи.

Вместо того, чтобы тратить большое количество времени на предварительное создание плана тестирования для проекта и замысловатый дизайн тестовых сценариев, команды должны запустить процесс тестирования на уровне конкретных фич системы.

**Каждая фича должна рассматриваться как мини-проект, и должна проверяться миниатюрной версией процесса тестирования** , который начинается еще до того, как будет написан какой-либо код.

Другим важным аспектом agile-тестирования становится  **автоматизация** .

Поскольку новые версии выпускаются на коротких итерациях, регрессионное тестирование становится всё более важным, поэтому и автоматизированное тестирование становится ещё более критичным.

В идеальном мире agile-тестирования **автоматизированные тесты создаются до создания кода, который реализует конкретные фичи** - это и есть истинное TDD - но так к сожалению редко случается на практике.

### Тестирование и вы как разработчик

А что насчет тебя, программист? Какова твоя роль во всех этих тестах?

Есть ли она у тебя вообще?

Да. Определенно.

Один из больших и частых фейлов в ИТ-командах заключается в том, что тимлид недостаточно вовлекает разработчиков в процесс тестирования, а те сами не берут на себя достаточно ответственности за тестирование и качество собственного кода.

**Как разработчик, вы должны заботиться о качестве своего кода куда больше, чем кто-либо другой** .

Вы не можете быть уверены, что отдел QA найдет ошибки в вашем коде.

Вместо этого вы должны нести полную ответственность за поиск и исправление ошибок до того, как ваш код пойдет на стороннее тестирование.

Причина довольно проста.  **Чем позже в процессе разработки обнаруживается ошибка, тем дороже обходится её исправление** .

Подумайте об этом так:

Если вы тщательно протестируете свой собственный код и найдете ошибку в этом коде, прежде чем он будет передан QA, вы сможете быстро исправить эту ошибку и, возможно, это выиграет команде дополнительный час времени.

Если же вы найдёте эту ошибку, но не найдёте время, чтобы исправить её самостоятельно, процесс может пойти примерно так:

Тестировщик запускает тест, который находит ошибку в вашем коде.

Тестировщик заново запускает тест, чтобы убедиться, что ошибка действительно существует.

Тестировщик фиксирует баг в системе отслеживания ошибок.

Сеньор или тимлид решает, что ошибка достаточно серьёзна, и назначает её исправление вам.

Вы пытаетесь воссоздать ошибочную ситуацию, но она на вашей машине уже не воспроизводится: у вас всё работает нормально.

Тестировщик воспроизводит ошибку заново и пишет более подробные шаги, приводящие к ней, в задании.

Наконец-то вы можете воспроизвести ошибку и исправить её.

Вы фиксите баг, и обновляете задание, сообщая, что ошибка исправлена.

Тестировщик заново проверяет, что ошибка действительно исправлена, и закрывает соответствующую задачу.

Это большое количество времени, которое все потратят практически впустую.

Не говоря уже о том, что ты в такой ситуации просто ленивая задница, ну и вообще...

Возможно, вам стоит потратить лишние 10 минут, чтобы проверить свой собственный код -- не только собственными тестами, но и, в частности, методом пристального взгляда -- прежде чем отдавать его на тестирование.

Конечно, вы наверняка поймаете далеко не все баги -- но если вы сможете поймать хотя бы 10% ошибок, которые в противном случае попали бы к тестировщикам, вы всё равно сэкономите довольно много времени, не так ли?

Итак, к данному моменту, надеюсь, вы получили достойное представление о том, что такое тестирование, с какой целью оно проводится, какие виды тестирования можно выполнять, и какую роль вы играете во всём этом процессе.

### Задание

Для какого-нибудь вашего проекта составьте план тестирования:

- Каким образом всё будет проверяться?
- Какова ваша стратегия тестирования?
- Какие виды тестирования вы будете проводить?
- Какие функции, модули... вы будете тестировать?
