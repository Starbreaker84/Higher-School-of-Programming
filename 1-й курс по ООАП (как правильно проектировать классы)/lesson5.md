## Три категории методов классов, реализующих АТД

Методы классов для обеспечения всей мощи концепции АТД для удобства проектирования разделим на несколько более точных категорий.

1) **Конструкторы** (возможно, с аргументами), создающие новый объект своего класса.
2) **Запросы** -- методы, которые вычисляют некоторое значение на основе своих аргументов (и возможно, на основе значений каких-то скрытых атрибутов класса), но не меняют значения никаких атрибутов класса (не меняют состояние класса). По сути, это чистые функции, которым требуются предусловия.
3) **Команды**, которые никакое значение не вычисляют, но меняют значения атрибутов класса, меняют состояние класса (возможно, на основе своих аргументов). Для команд требуются постусловия.

**Во всех случаях запросы и команды не должны менять значения своих аргументов (которые, возможно, передаются по ссылке).**

Кроме того, всегда следует избегать формирования операций АТД, подразумевающих некоторую жёсткую последовательность действий или взаимозависимости. Каждая операция должна быть полностью автономна и независима от других, а ограничения для неё задаются исключительно с помощью пред- и постусловий. В идеале это подразумевает, что **никакая из операций АТД не может быть выражена через другие операции (все они атомарны)**. Сам по себе это достаточно сильный и чистый подход, и если АТД удаётся наглядно и просто специфицировать таким способом, то так и надо делать. Однако в ООАП довольно активно применяется концепция **классов поведения**, когда некоторые ключевые методы определяются комбинированием низкоуровневых операций. Кроме того, даже разделение на запросы и команды будет противоречить такому минималистичному подходу. И всё же по возможности желательно хотя бы приближаться к этому идеалу.

### Сила категорий методов

Деление на запросы и команды имеет под собой весьма фундаментальную идеологию. В параллельном программировании существует классическая проблема, когда например есть некоторый запрос списания денег со счёта, который предварительно проверяет, достаточно ли на счету денег, и если их достаточно, списывает нужную сумму. Но в параллельном режиме множество таких запросов будут выполняться пошагово (несколько единичных инструкций за выделенное процессором время). И тогда возможна ситуация, когда к счёту обращаются два запроса. Первый проверил, что суммы достаточно, затем второй проверил то же самое, затем первый списал сумму, и затем второй пытается сделать то же самое. Что должно при этом произойти? Однозначного ответа нет. Проблема в том, что в одном обращении объединена логика и запроса, возвращающего результат, и команды, меняющей состояние системы.

В случае же разделения на запросы и команды всё решается тривиально: отдельный запрос возвращает текущий баланс, и отдельная команда выполняет списание суммы, возвращая либо код успешности, либо код ошибки (например, денег недостаточно). В таком случае, сперва оба запроса баланса от разных клиентов отработают успешно, затем одна команда выполнится успешно, а вторая вернёт код ошибки. Однако при этом не возникнет ни исключительных ситуаций, ни ошибочных сумм -- логика такой работы совершенно прозрачна для программиста.

### Побочные эффекты

Любое непредвиденное, явно не учтённое в спецификации АТД изменение состояния объекта называют **побочным эффектом**. Побочные эффекты необходимо полностью исключить во всех случаях. Методы-команды непосредственно предназначены для изменения состояния объекта, но их деятельность определена в спецификации АТД.

Единственное исключение делают для конструкторов, которые создают новый объект, который этим же конструктором и возвращается.

Однако, говоря об АТД, мы имеем в виду тоже **абстрактные побочные эффекты**. Потому что, например, функции могут временно менять состояние объекта, создавая побочный эффект, однако по завершении своей работы восстанавливают прежнее состояние, откатывая все изменения. С точки зрения АТД, такая функция чистая. Кроме того, методы могут менять значения атрибутов, которые не входят в АТД (как в нашей версии динамического массива, когда имеется дополнительный буфер, о котором пользователь класса не подозревает). В таком случае мы тоже можем говорить, что в рамках спецификации АТД данная функция чистая. Это ещё одна из сильных сторон ООП, отделяющая универсальную спецификацию от реализации.
