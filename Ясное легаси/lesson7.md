### Объектные швы

16. Проблема. Далеко не все вызовы методов будут швами. Если имеется метод A класса B, который переопределяет родительский метод A вышестоящего класса C, то вызов A() в методе D класса E не будет объектным швом, потому что у него нет разрешающей точки. Мы не можем подменить вызов A(), потому что не знаем на момент компиляции, для объекта какого именно класса он будет вызыван.

Решение. Создаём класс F -- наследник класса E, в котором переопределяем метод D нужным нам образом так, чтобы он вызывал A(), например, с явным приведением типа объекта к классу B (если по логике работы или тестирования подразумевается именно это).


### Объектные швы

17. Проблема. Не добавляем ли мы в проект подобным образом слишком косвенную тестовую логику? Если нам так не нравится зависимость, то почему бы просто не перейти к самому коду и непосредственно изменить его (превратить его в разрешающую точку)?

Решение. Иногда такой прием срабатывает, но когда приходится иметь дело с особенно глубоко вложенным и сильно запутанным унаследованным кодом, с совершенно неявными зависимостями и побочными эффектами, зачастую при подготовке тестов лучше стараться изменять такой код как можно меньше.


### Объектные швы

Например, имеется глобальная функция MakeDwarfCombat, которую требуется протестировать.

Во-первых, мы можем использовать компоновочный шов: создать библиотеку с одноимённой функцией-заглушкой и прилинковать её в проект. Разрешающей точкой в данном случае служит файл управления сборкой проекта, или же определённая настройка проекта в среде разработки. Соответственно, придется изменить процесс сборки (например, добавить новый флажок), чтобы приаттачить либо тестовую библиотеку при выполнении тестирования, либо рабочую библиотеку для построения реальной системы.

Во-вторых, если язык позволяет, мы можем использовать шов предварительной обработки -- задействовать препроцессор для определения специально написанной макрокоманды MakeDwarfCombat под режим тестировании. Разрешающей точкой, включающей и выключающей данное макроопределение, будет директива препроцессора (например, #define).

В-третьих, если MakeDwarfCombat -- это метод класса Game, то мы можем использовать объектный шов -- объявить новый метод MakeDwarfCombat, переопределяющий существующий. Где находится разрешающая точка? Там, где мы создаём объект. Например, мы создаём либо объект класса Game, либо объект его тестового подкласса GameTest, переопределяющего метод MakeDwarfCombat.


### Выбор правильного типа шва

Выбор правильного типа шва существенно зависит от конкретного проекта, в определённой степени это мастерство.

Общая рекомендация, что швы предварительной обработки и компоновочные швы полезно выбирать, когда зависимостей слишком много и они слишком сильно размазаны по коду, и лучшей и достаточно простой альтернативы справиться с ними явно не видно. Но поддержка соответствующих тестов сама по себе весьма трудна, поэтому лучше по возможности ориентироваться на объектные швы.


### Модель шва (задания)

======= 19. Можно ли превратить любой метод/функцию в шов?

[ ] да, подбором подходящего типа шва

[ 1] нет, шов не подразумевает изменение тестируемого метода/функции

======= 20. Когда зависимостей в проекте много, лучше применять ...

[ ] объектные швы

[1 ] швы предварительной обработки и компоновочные
