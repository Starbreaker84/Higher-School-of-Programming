## Часть 5. Коллекции и функции высших порядков

Функциональный стиль предлагает использовать стандартные рекурсивные паттерны в форме функций высших порядков.

Функции в стандартных библиотеках F# естественно соответствуют абстрактным понятиям и поддерживают высокоуровневое проектирование программ.

Списки, множества и отображения -- это конечные коллекции (наборы значений, структурированные некоторым способом), запрограммированные в функциональном стиле.

Стандартные библиотеки F# содержат функции высших порядков для работы с основными структурами (типами) данных.

### 41. Списки

**41.1. Функция map (отображение)**

Функция высшего порядка List.map применяет функцию (первый параметр) к каждому элементу списка (второй параметр).

```
List.map f [ x1; x2; ...; xn ] = [ f(x1); f(x2); ...; f(xn) ]
```

Например:

```
(List.map int [1.1; 2.2; 3.3]) = [1; 2; 3] // true

let float2int = List.map int 

(float2int [1.1; 2.2; 3.3]) = [1; 2; 3] // true
```

**41.2. Стандартные функции с предикатом для списков**

В стандартной библиотеке F# есть немало функций, которые используют функцию-предикат типа 'a -> bool применительно к спискам.

Функция List.exists возвращает true, если предикат, примененный ко всем элементам списка, хотя бы для одного элемента вернёт true.

```
List.exists (fun x -> x < 0) [1; 2; 3] // false
List.exists (fun x -> x < 0) [-1; 2; 3] // true
```

Функция List.forall возвращает true, если предикат, примененный ко всем элементам списка, для каждого элемента без исключения вернёт true.

```
List.forall (fun x -> x > 0) [1; 2; 3] // true
List.forall (fun x -> x > 0) [-1; 2; 3] // false
```

Функция List.tryFind возвращает Some x , если предикат, примененный ко всем элементам списка, для первого по порядку подходящего элемента x вернёт true, или None в противном случае.

```
(List.tryFind (fun x -> x > 0) [-1; 2; 3]) = Some 2 // true
(List.tryFind (fun x -> x < 0) [1; 2; 3]) = None // true
```

Функция фильтрации List.filter возвращает список тех элементов из исходного списка, для которых предикат истинен.

```
(List.filter (fun x -> x > 0) [-1; 2; 3]) = [2; 3]
```

**41.3. Функции свёртки fold и foldBack**

Функция List.fold применяет функцию (первый параметр), которая имеет два аргумента, к каждой паре значений списка (третий параметр), и результат "сжатия" списка объединяет со вторым параметром (начальным значением).

Если вместо функции-параметра представить диадический оператор, то он как бы вставляется между элементами списка.

```
let f x y = x + y
List.fold f 4 [1; 2; 3] // 10 = 4 + [1 + 2 + 3] = 4 + [ f( f(1,2) ,3 ) ]
```

Переворачивание списка задом наперёд:

```
let rev lst = List.fold (fun head tail -> tail::head) [] lst
(rev [1; 2; 3]) = [3; 2; 1] // true
```

Функция List.foldBack аналогична фунции fold с тем отличием, что порядок применения функции-параметра противоположный. Список следует вторым параметром, а начальное значение -- третьим.

```
List.foldBack f [1; 2; 3] 4 // 10 = [1 + 2 + 3] + 4 = [ f(1, f(2,3)) ] + 4
```

Если функция-параметр некоммутативна, то результаты работы fold и foldBack могут быть разными.

```
let minus x y = x - y
List.foldBack minus [1; 2; 3] 0 = 2 // 2 = 1 - (2 - (3 - 0))
List.fold minus 0 [1; 2; 3] = -6 // -6 = ((0 - 1) - 2) - 3
```

В функциях fold и foldback допускается указание инфиксных операторов как префиксных.

```
List.foldBack (-) [1; 2; 3] 0
List.fold (+) 4 [1; 2; 3]
```

**41.4. Задания**

41.4.1. Напишите функцию list_filter, которая реализует стандартную функцию List.filter, с помощью List.foldBack.

41.4.2. Напишите функцию sum(p, xs), где p -- предикат int -> bool, и xs -- список целых.
Функция возвращает сумму тех элементов xs, для которых предикат истинен.
Реализуйте sum с помощью List.fold или List.foldBack.

41.4.3. Напишите функцию revrev, которая получает на вход список списков, и перевёртывает как порядок вложенных списков, так и порядок элементов внутри каждого вложенного списка.

```
revrev [[1;2];[3;4;5]] = [[5;4;3];[2;1]]
```

Реализуйте revrev с помощью List.fold или List.foldBack.

Шаблон для отправки на сервер:

```
// 41.4.1
let list_filter f xs = ...

// 41.4.2
let sum (p, xs) = ...

// 41.4.3
let revrev = ...
```

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/s71e38e3b1.html)**

---

**Ответы на задания 40**

```
let rec sum (p, xs) =
    match xs with
        | [] -> 0
        | (x :: xs) when p x -> x + sum (p, xs)
        | (x :: xs) -> sum (p, xs)

let rec count (xs, n) =
    match xs with
        | [] -> 0
        | head :: _ when head > n -> 0
        | head :: tail when head = n -> 1 + count (tail, n)
        | head :: tail -> count (tail, n)

let rec insert (xs, n) =
    match xs with
        | [] -> [n]
        | head :: _ when head >= n -> n :: xs
        | head :: tail -> head :: insert (tail, n)

let rec intersect (xs1, xs2) =
    match (xs1, xs2) with
        | ([],_) | (_,[]) -> []
        | (h1::t1, h2::t2) when h1 = h2 -> h1 :: intersect (t1, t2)
        | (h1::t1, h2::t2) when h1 < h2 -> intersect (t1, xs2)
        | (h1::t1, h2::t2) -> intersect (xs1, t2)

let rec plus (xs1, xs2) =
    match (xs1, xs2) with
        | ([],[]) -> []
        | (xs1, []) -> xs1
        | ([], xs2) -> xs2
        | (h1::t1, h2::t2) when h1 = h2 -> h1 :: h2 :: plus (t1, t2)
        | (h1::t1, h2::t2) when h1 < h2 -> h1 :: plus (t1, xs2)
        | (h1::t1, h2::t2) -> h2 :: plus (xs1, t2)

let rec minus (xs1, xs2) =
    match (xs1, xs2) with
        | ([],[]) -> []
        | (xs1, []) -> xs1
        | ([], xs2) -> []
        | (h1::t1, h2::t2) when h1 = h2 -> minus (t1, t2)
        | (h1::t1, h2::t2) when h1 < h2 -> h1 :: minus (t1, xs2)
        | (h1::t1, h2::t2) -> minus (xs1, t2)

let rec smallest (xs : int list) =
    match xs with
        | [] -> None
        | [x] -> Some x
        | x :: tail -> let x2 = Option.get (smallest tail)
                       Some (if x < x2 then x else x2)

let rec delete (n, xs) =
    match xs with
        | [] -> []
        | x :: tail when x = n -> tail
        | x :: tail -> x :: delete (n, tail)

let rec sort = function
    | [] -> []
    | xs -> let s = Option.get (smallest xs)
            s :: sort (delete (s, xs))

let rec revrev = function
    | [] -> []
    | [x] -> [List.rev x]
    | x :: xs -> (revrev xs) @ [List.rev x]
```
