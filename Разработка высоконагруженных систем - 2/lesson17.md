## Репликация без ведущего узла

Проблема 52. Репликация с несколькими ведущими узлами вполне подходит для сценария репликации между несколькими ЦОДами. Как поступать в таком случае при репликации без ведущего узла?

Решение. Репликация без ведущего узла для такого сценария тоже хорошо подходит, поскольку уже спроектирована в расчете на конфликтующие конкурентные операции записи, обрывы сети и скачки времени задержки. Число реплик n включает узлы во всех ЦОДах, при этом дополнительно указывается, какая часть из n реплик должна находиться в каждом ЦОДе. Поступающая от клиента информация по операциям записи отправляется на все реплики независимо от ЦОДа, но клиент ждёт подтверждения прежде всего от кворума узлов своего локального ЦОДа, так что его не затрагивают временные задержки и сбои связи.

## Репликация без ведущего узла

Проблема 53. В Dynamo-подобных базах данных возможна конкурентная запись значения для одного ключа несколькими клиентами одновременно, что означает вероятность конфликтов даже при использовании строгих кворумов. Сообщения могут поступать в разные узлы в разном порядке вследствие различных сетевых задержек и частичных отказов, и если каждый узел будет просто переписывать значение ключа при каждом получении запроса на запись от клиента, то узлы будут фактически всё время несогласованными.

Решение. Для достижения конечной согласованности реплики должны стремиться к одному значению. В идеале желательно автоматическое разрешение реплицируемыми БД, но, к сожалению, большинство их реализаций в этом плане слабоваты. Чтобы избежать потери данных, разработчикам программной системы, взаимодействующей с СУБД, необходимо хорошо разобраться в том, как эта СУБД разрешает конфликты, и соответствующие нюансы обрабатывать прикладным кодом.

## Репликация без ведущего узла

Один из методов автоматического достижения конвергентности -- условиться, что все реплики должны хранить только самое "свежее" значение, а более "старые" значения могут свободно перезаписываться и игнорироваться. В этом случае все реплики будут естественно стремиться к одному значению.

Проблема 54. Но имеется ли хороший способ однозначного определения, какая операция записи самая "свежая", и гарантии, что каждая операция записи в конце концов воспроизведётся во всех репликах? Фактически ведь не имеет смысла говорить о "первенстве" какой-либо операции записи: они по определению конкурентны, и порядок их выполнения не определен.

Решение. Хотя операции записи не упорядочены сами по себе, мы можем навязать им некоторый порядок. Например, добавляем в каждую операцию записи метку даты/времени, и выбираем эту метку с максимальным значением в качестве самой "свежей", отбрасывая все операции записи с более ранними метками. Этот метод "выигрывает последний" (last write wins, LWW) уже упоминался ранее при первом обсуждении сходимости к согласованному состоянию. Он кстати единственный алгоритм разрешения конфликтов в СУБД Cassandra.

## Репликация без ведущего узла

Проблема 55. LWW позволяет достичь в итоге конвергентности, однако при этом не обеспечивается сохраняемость данных: при нескольких конкурентных операциях записи для одного и того же ключа клиент может получить подтверждение их успешного выполнения (поскольку они записывались на w реплик), но реально только одна из этих операций будет учтена, а остальные будут незаметно проигнорированы. Более того, LWW может игнорировать даже неконкурентные операции записи.

Решение. Единственный безопасный способ использования базы данных с LWW -- гарантировать, что ключ записывается только один раз и считается неизменяемым (как однократное присваивание в декларативной вычислительной модели), благодаря чему можно избежать конкурентных обновлений одного ключа. Но для этого, вероятно, придётся существенно ограничить логику прикладной системы.


### Репликация без ведущего узла (задания)

======= 46. При репликации без ведущего узла с несколькими ЦОДами ...

[ ] возникают проблемы с конфликтующими конкурентными операциями записи

[ ] клиент ждёт подтверждения от кворума всех ЦОДов

[ 1] клиент ждёт подтверждения прежде всего от кворума своего ЦОДа

======= 47. Потенциально возможна конкурентная запись значения для одного ключа несколькими клиентами одновременно

[ 1] соответствующие нюансы обрабатываем в прикладной системе

[ ] это автоматически разрешается реплицируемыми СУБД

======= 48. Как определять в целях конвергентности, какая операция записи самая "свежая"?

[ ] это невозможно

[ ] применять метод "выигрывает первый" FWW

[ 1] применять метод "выигрывает последний" LWW
