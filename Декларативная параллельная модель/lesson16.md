### Исключения

Если компонент вызывает исключение в декларативной модели параллельного программирования, то модель больше не считается
декларативной. Почему?

Во-первых, чтобы компонент был декларативным, надо, чтобы он был детерминирован. Например, если инструкции X=1 и X=2
выполняются параллельно, то такое выполнение уже не будет детерминированным: одна (неизвестно, какая!) инструкция
успешно отработает, но другая вызовет исключение. При этом X будет связана либо с 1, либо с 2; возможны оба варианта.
Это явный случай наблюдаемого недетерминизма.

Исключение -- просто свидетель того факта, что потенциально существует наблюдаемый недетерминизм. Например, выполнение
X=1 и X=2 по порядку, даже в одном и том же потоке, всё равно вызовет исключение, хотя X всегда будет равен 1. Но если
исключений нет, то выполнение, безусловно, детерминировано и, следовательно, декларативно.

Во-вторых, исключение может возникнуть, когда операция не отрабатывает нормально. Это может быть вызвано внутренними
причинами -- например, аргументы вышли за пределы области действия операции (деление на ноль), или внешними причинами (
например, попытка открыть файл, который не существует). В обоих случаях исключение указывает на то, что была предпринята
попытка, выходящая за рамки спецификации. С точки зрения семантики, нет никакой гарантии того, что операция, вызвавшая
исключение, сделала что-то конкретное и предсказуемое; нет, она могла сделать вообще что угодно (испортить оперативную
память, содержимое файла). По этой причине, опять же, операция потенциально стала недетерминированной.

Резюме:  **когда возникает исключение, это свидетельствует либо о недетерминированном выполнении, либо о выполнении вне
спецификации** . В любом случае, компонент больше не может считаться декларативным. В таком случае говорят, что  **
декларативная параллельная модель декларативна по модулю исключений** . И оказывается, что декларативная параллельная
модель с исключениями похожа на параллельную модель с общим состоянием.

Что же делать, когда возникает исключение, как сохранить декларативную парадигму? Во многих случаях компонент может
исправить сбойную ситуацию так, что при внешнем рассмотрении он всё ещё остается декларативным (на уровне своего
интерфейса прежде всего). Основная задача заключается в том, чтобы сделать компонент детерминированным, для этого все
источники недетерминизма должны быть скрыты от внешних наблюдателей. Например, если компонент выполняет X=1 и X=2
одновременно, то минимум, что он должен сделать, это

1) поймать соответствующее исключение (например, охватив блоком try каждое связывание), и
2) инкапсулировать X так, чтобы его значение не было наблюдаемым извне, за пределами компонента.

### Модель с каналами сообщений

В декларативной параллельной модели нити взаимодействуют через общие dataflow-переменные. Оказывается, что существует
тесное соответствие между операциями над dataflow-переменными и операциями над каналами связи, поэтому можно
рассматривать dataflow-переменную как вид канала связи, а нить -- как вид объекта. В таком случае связывание переменной
со значением будет означать отправку сообщения в канал, а ожидание когда переменная будет связана -- приём сообщения из
канала. Соответственно, получается модель, когда в канал может быть отправлено только одно сообщение, но считано оно
может быть сколько угодно раз.

В общем случае, сообщения могут посылаться в канал и приниматься из него, и происходить это может синхронно или
асинхронно: получается четыре варианта.

1) **Связывание переменной соответствует асинхронной отправке сообщения** . Связывание может быть выполнено независимо
   от того, получила ли какая-либо нить отправленное сообщение. Программа "помещает" значение в переменную, однако это
   совсем не значит, что оно тут же будет востребовано.
2) **Ожидание, пока переменная будет связана, соответствует синхронному приёму** . Значение в результате связывания
   должно физически существовать, чтобы нить продолжила выполнение.
3) **Асинхронное получение сообщения означает простое использование переменной до её связывания** . Например, переменная
   может быть размещена в структуре данных до того, как она будет связана. Конечно, любая операция, которой необходимо
   значение такой переменной, будет ждать, пока значение не будет этой переменной "получено". Однако в программе явного
   ожидания связывания не происходит -- она просто откладывает несвязанную переменную, и продолжает заниматься другими
   делами.
4) **Синхронная отправка сообщения означает явное ожидание связывания** до тех пор, пока значение не будет помещено в
   переменную.

Пункты 2 и 4 похожи, но различаются семантикой использования: в случае 2 программе для продолжения вычислений физически
требуется значение переменной, и она будет ждать, когда она свяжется (если она ещё не связана). В случае 4 программа "
наоборот" записывает значение в переменную (канал), дожидаясь окончания связывания, чтобы убедиться, что
значение/сообщение было явно "отправлено".

### Модель с каналами сообщений

Операции отправки и получения сообщений в каналах связи могут быть **блокирующие** и **неблокирующие** (это не то же
самое, что синхронные и асинхронные операции!).

Определяющая характеристика неблокирующей операции в том, что она немедленно возвращает булев результат, показывающий,
была ли операция успешной. В случае dataflow-переменных неблокирующая отправка тривиальна, поскольку она всегда
успешна (значение всегда успешно связывается с несвязанной переменной). Неблокирующий приём соответственно проверяет,
связана ли dataflow-переменная, возвращая соответствующее логическое значение (поступили ли данные в переменную
физически).

Тут есть важный нюанс, что такая проверка по сути проверяет, детерминирован ли идентификатор (связан ли он со значением,
записью или процедурой), поэтому сама по себе она недекларативна.

### 16. Выбор модели вычислений

======= 45. Правильно выбирать ту модель, которая приводит к естественной программе, и при этом ...

[ ] наиболее выразительна

[ 1] наименее выразительна

======= 46. Декларативная параллельная модель может быть естественно расширена ... (выберите неверное утверждение)

[ 1] классами

[ ] состоянием

[ ] портами

[ ] исключительными ситуациями

======= 47. Согласование импедансов -- это ...

[ 1] строим абстракции в более выразительной модели, и реализуем в менее выразительной модели

[ ] строим абстракции в менее выразительной модели, и реализуем в более выразительной модели
