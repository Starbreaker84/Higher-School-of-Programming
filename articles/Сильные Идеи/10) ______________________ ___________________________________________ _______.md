## Антипаттерн "Самодокументирующийся код"

*Далее и под самодокументирующимся кодом, и под самодокументируемым кодом понимается одно и то же :)
Имеется в виду, что код настолько выразителен, что он воспринимается и как код, и как документация к самому себе.*

Одна из самых странных вещей в программной инженерии -- как много людей ненавидят комментарии. Буквально, на самом деле ненавидят. Есть очень авторитетные люди в информатике, которые заявляют, что комментарии -- это признак того, что ваш код плох, и это значит, вы просто не смогли сделать свой код достаточно понятным, чтобы он не нуждался в комментариях.

Комментарии устаревают, комментарии часто врут; код -- единственный источник правды. Вам надо стремиться к самодокументирующемуся коду, с наглядными именами переменных, который хорошо структурирован и хорошо организован, и это всё автоматически делает комментарии излишними. Дескать, другие разработчики поймут, что делает код, просто прочитав его! Таким образом, комментарии в коде не нужны, за редчайшими исключениями.

Очень жаль, но это невозможно. Если вы изучили материалы "3 уровня думания о программе", наверняка уже понимаете, почему.

Большинство "очевидных" вещей таковыми не являются. Об этом отлично знает любой преподаватель. Неважно, насколько просто и очевидно что-то для вас -- это совсем не так просто и не так очевидно для кого-то другого. Это же относится и к программированию.  **Когда вы пишете "самодокументирующийся код", он самодокументируется только для вас** . У вас есть весь этот внутренний контекст (в идеале -- осознанная модель), который делает его самодокументируемым. У других людей такого контекста нет. Им нужно больше информации, чем есть в вашем коде.

Да, вы можете включить часть этой информации в имена переменных и функций, но тут получится только одно-два слова для каждой функции, и вы сможете закодировать только отдельное небольшое понятие. Можно попробовать "закодировать больше", механически разбив функцию на подфункции, но тогда вы усложните код, чтобы сделать его более "читабельным", и получите противоположный эффект. Вы также можете встроить часть этой информации в тесты -- но тогда ваши тесты будут вынуждены сочетать свойства и тестов, и документации, тем самым они нарушат принцип единой ответственности со всеми печальными вытекающими.

Более того, замена комментариев функциями и тестами ведёт к более глубокой, более фундаментальной проблеме: таким методом вы сможете кодировать только определенные классы информации. В программной инженерии этот подход называют "комментировать не что делается, а почему/зачем", чему специально учат начинающих, но  **существует огромный класс информации, помимо "почему/зачем", который не может быть закодирован непосредственно в коде** . Это всяческая анти-информация (код ведь по определению говорит,  **что надо делать** , но в процессе проектирования очень важно исходить из того,  **что не надо делать** , для чего в частности применяем пред- и пост-условия, как на курсах по ООАП). Это всяческие советы на будущее, TODO. Это информация об оптимизации, и т. п. Более того, большинство разработчиков даже не догадываются, что можно документировать такие вещи. Часто в команде даже никакой документации не ведётся, а если она и есть, в неё никто не заглядывает. Но вы можете довольно легко решить эту проблему именно с помощью комментариев.

Да, в интернете огромное количество примеров и статей, показывающих фрагменты "самодокументированного/самодокументирующегося кода". Однако практически у всех у них есть один общий момент: они обучающие, а не рабочие, поэтому представляют собой небольшие и действительно самодостаточные вещи. Однако **разработчику важна прежде всего информация глобального характера: как этот код вписывается в общую программу** (понимание на более высоком уровне дизайна системы). Поведение выразительного кода ничего не может рассказать нам об этом, потому что **сам код не должен ничего знать о программе в целом, иначе это нарушило бы саму идею инкапсуляции!**

Давайте посмотрим на известный учебный проект "чистого кода" [FitNesse](https://github.com/unclebob/fitnesse) от Дядюшки Боба. Это отличная и вдобавок довольно большая программа, написанная самым влиятельным Ясным Кодировщиком, поэтому она вполне достойна стать лучшим кандидатом на самодокументированный код.

Возьмём кусочек кода из этого проекта, [пусть такой](https://github.com/unclebob/fitnesse/blob/master/src/fitnesse/Shutdown.java#L29) (функция run).

Читабельно? Очень даже. Вполне понятно, что этот код делает, и какие переменные и функции за что отвечают. Однако если мы попробуем разобраться в этом коде чуть поглубже (например, требуется его как-то расширить), возникнет например вопрос, кто где и как формирует сигнал выключения (чтобы программа завершилась)? Да, напрашивается, что вызов API скрыт внутри buildAndSendRequest(), но это лишь туманный намёк. Внутри buildAndSendRequest мы найдём ResponseParser.performHttpRequest(), внутри которого встретится RequestBuilder.send()...

Этот код не самодокументирующийся, потому что критическая часть его "документации", понимания -- фактический вызов API -- фактически никак не связана с дизайном, с видением и выразительностью структуры кода и проекта на третьем логическом уровне.

**То, что в проекте очевидно для вас, совсем не очевидно для всех остальных** . Вы можете даже не подозревать о существовании подобных проблем, потому что вы сами настолько освоили свой код, что они кажутся вам слишком тривиальными, чтобы в отношении них возникали хоть какие-то вопросы. Вы смотрите на свой код и думаете: "ага, тут везде отличное самодокументирование", потому что некоторая выразительность кода на втором уровне отвечает на тактические вопросы, а дизайн вы пока относительно успешно держите в голове.

Роберт Мартин кстати в этой связи высказался так:  *"Этому проекту уже двадцать лет, и у него была долгая и разнообразная история... Идеально? Нет. А что идеально?"* . Речь тут о том, конечно, что информация о дизайне отсутствует в коде не потому, что код недостаточно ясен, а потому, что она не может быть легко закодирована в коде.

Но почему же тема самодокументированного кода столь привлекательна для разработчиков? Тому есть множество весьма законных причин:

- **Комментарии вполне могут рассинхронизировываться с кодом** , что делает их менее надёжными. Хотя то же самое может произойти и с именами переменных, методов и тестов, вероятность этого меньше, так как для их сопровождения требуется меньше усилий, и в IDE обычно наличествуют хорошие инструменты быстрого автоматического рефакторинга.
- **Комментарии загромождают код** , существенно увеличивая объём кода в файле.
- Гораздо легче вспомнить случаи, когда **комментарии оказывались устаревшими** и "обманывали" нас, нежели те случаи, когда комментарии нам помогали.
- В программной инженерии разработано множество теорий и практик по поводу того, как писать "более лучший" код -- но не  **как писать хорошие комментарии** .
- Писать хорошие комментарии -- это фактически про общение человека с человеком,  **это софт-скилл** , это совершенно иной навык, нежели писать хороший код, и большинство разработчиков не практикуют его прежде всего по этой причине.

Большой процент разработчиков полагает, что комментарии -- это что-то вроде вежливости, и я на 100% согласен:  **комментарии -- это учтивость по отношению к другим программистам** . Нам нужно что-то более лучшее, нежели комментарии, или, по крайней мере, нам нужна гораздо лучшая технология написания комментариев!

**Но даже в тех случаях, когда комментарии -- это просто вежливость, они все равно остаются единственным средством, которое позволяет нам сочетать код с выразительным общением** .

Код и тесты недостаточно выразительны, чтобы вместить всю полезную информацию. Мы не можем в достаточной степени самодокументировать наш код.
