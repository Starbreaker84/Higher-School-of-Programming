## Три уровня рассуждений о программной системе

Вы когда-нибудь задумывались о том, что значит "программа работает неправильно", "программа ошибочна"? Что-то вроде "ну, это когда она вылетает с ошибкой... но если она вроде работает, а может сломаться гипотетически, при определённых условиях... кхм, подождите...".

Давайте разберемся с этим. Вот первая попытка:

Определение N 1
**Если программа запущена и выдаёт неверный результат, она ошибочна.**

Обычно программы всё равно могут выдавать правильный результат, но быть ошибочными. Вы используете некоторую программу, и у вас никогда не было проблем с ней. Но потом вы выясняете, что если запустить программу в полнолуние, 23-м параметром задать значение 42, и если при этом её запускали ровно дважды за последние 24 часа, то она отформатирует диск. Похоже, это баг :) Итак, мы вносим поправку во второе определение.

Определение N 2
**Программа ошибочна, если существует некое окружение, последовательность событий или некоторые "входные" значения, которые приводят к неверному результату.**

Код всё ещё остаётся неверным. Он может на практике никогда не подвести, однако наше утверждение, что код работает нормально, имеет уязвимость. То, что должно быть простым аргументом для передачи массива, теперь зависит от сложных настроек компилятора и оптимизации памяти, а также от проверок по всей программе, что вот этот вот байт всегда равен 0. И эта уязвимость может привести к реальному сбою в будущих версиях программы: кто-то переставит поля в структуре данных, и код, который не должен был пострадать, начнёт давать сбои. Пройдите для понимания таких, кстати, нередких ситуаций, мой микро-курс "Как правильно мыслить на языке Си".

Мы добираемся до третьего определения:

Определение N 3
**Программа ошибочна, если причина, по которой она должна быть правильной, ошибочна.**

Прогресс! Мы перешли от ясного и простого определения проблемы к тому, что выглядит какой-то логической головоломкой, парадоксом или софизмом, и что вообще невозможно использовать :) На самом деле, это определение довольно строгое, и мы разберёмся с ним, освоив несколько понятий из области формальной верификации кода.


## Три уровня рассуждений о программной системе

Все эти три определения правильны в контексте времени своего применения.

Это один из наиболее фундаментальных моментов в думании о программе:  **когда мы рассуждаем о программной системе, мы всегда делаем это на одном из трёх уровней** .

Вот эти три уровня:

Уровень 1:  **Время выполнения (runtime)** . Уровень выполнения касается конкретных значений/состояний программы и конкретной среды/окружения в ходе одного конкретного выполнения программы. На уровне исполнения, в частности, выполняется большая часть отладки.

Уровень 2:  **Конкретная реализация/исходный код** . На уровне конкретной реализации мы думаем о том (предполагаем), что может сделать текущая реализация при некоторых входных данных и некотором окружении, которые в общем случае могут быть произвольны. При этом существует множество "поведений" программы, которые никогда не могут произойти, и очень важно учиться исключать их из рассмотрения в процессе разработки, даже если для такого исключения требуется сильное системное/формальное мышление. Основная работа по реализации программы ведётся на уровне исходного кода.

Уровень 3:  **Дизайн/проектирование/логика** . На уровне логики рассматривается абстрактная спецификация каждой единицы/сущности/компонента программы (см. цикл курсов "как понять в программировании всё").  **Мы всегда рассматриваем только те "активности" программы, которые определены спецификацией** , причём предполагаем, что они в любой момент могут быть заменены другой реализацией (с сохранением требований спецификации, конечно).

Тут мы подбираемся к ключевому моменту. Многие программы, которые корректны при рассмотрении на уровне 2 (конкретная реализация), некорректны при их рассмотрении на логическом уровне 3, так как реализуют/предполагают поведение, корректность которого никак не гарантируется в будущих версиях. Это ошибка рассуждения, так как нельзя утверждать, что функция корректна, только изучив её код и внешние зависимости (не зная, что она должна делать в рамках всей системы).


## Три уровня рассуждений о программной системе

В большинстве случаев  **проектирование программного обеспечения осуществляется на уровне логики** , хотя сами проектировщики, к сожалению, не осознают этот момент, и часто смешивают разные уровни.

Программисты иногда путают время исполнения и уровень реализации/кода, но не так уж и часто. Уровни исполнения и кода достаточно конкретны: вы присутствуете на уровне исполнения, запуская отладчик и рассматривая стек, а конкретный уровень реализации - это когда вы просто читаете код и думаете о том, что как он работает и что может случиться. Но большинству программистов, оказывается, очень трудно понять, что существует ещё один логический уровень, и я постоянно встречаю путаницу, когда один программист говорит о том, **что** делает компонент, а другой -- о том, **как** он это делает.

Большинство программистов достаточно хорошо выучиваются разнице между интерфейсом и реализацией. Но мало кто способен понимать подробно и точно то, что определяет некоторый "интерфейс" во всей системе, а не только что "это список функций". Потому что полноценно это можно понять только при формальной верификации, когда формальные свойства и характеристики программы заданы и описаны так же конкретно, как и её исходный код. В повседневной разработке эти моменты и рассуждения, конечно, немного наличествуют, только неформально: они беспорядочно разбросаны и перемешаны по документации, комментариям и умам программистов.

**Рассуждения о программе на разных уровнях смешивать нельзя** . Поэтому если по поводу тестируемого API тимлид Коля говорит, что клиенту иногда приходится посылать запрос два раза, и отбрасывать первый результат, чтобы получить корректное значение (уровень 3), а фронтендер Петя объясняет, что это потому, что в коде есть три разных типа обработчиков запросов, один из которых иногда ошибается (уровень 2), то мы быстро запутаемся.


## Три уровня рассуждений о программной системе

**Думать над проектом, над новой фичей, надо всегда прежде всего на логическом уровне** . Иначе мы будем постоянно ошибочно полагать, что наша цель -- поставлять клиентам работающее программное обеспечение, и поэтому правильность на втором уровне реализации -- это всё, что важно.

Нет, наша цель --  **продолжать поставлять, развивать и сопровождать работающее программное обеспечение и сейчас, и в будущем, и делать это долго и продуктивно** .

Логический уровень подразумевает максимально "модульное" взаимодействие между компонентами вашего проекта, и это очень важно, если вы вообще планируете создавать разные версии этих компонентов -- например, если вы захотите переписать один из них завтра.

Программное обеспечение -- это область, в которой мы принимаем решения, которые нельзя отменить и которые должны поддерживаться вечно. HTTP-заголовок "referer" написан с орфографической ошибкой навсегда.

Поэтому крайне важно тренироваться в проектировании программных систем на абстрактном уровне формальных спецификаций, чтобы обязательно можно было утверждать (в идеале -- доказать), что каждая его подсистема, каждый компонент корректен сам по себе, независимо от всей остальной программы, даже если в целом программа прошла все виды тестирования и соответствует внешним требованиям на данный момент. Но что с ней случится завтра, когда начнём добавлять в неё новые фичи и улучшать существующие?

Несколько лет занимаюсь повышением квалификации программистов, обучаю лучшему пониманию того, как избегать роста сложности в проекте, как улучшать инкапсуляцию, как избавляться от зависимостей, как делать код "перспективным". Но, в конечном итоге, все эти понимания проистекают из одного единственного ключевого мастерского навыка: самые важные составляющие нашего ремесла связаны не с кодом, а с логикой, лежащей в его основе. Этот логический слой обычно скрыт, так как не существует в коде и проекте физически; однако это не мистика, за этим слоем стоит более 40 лет научных исследований computer science.

Когда вы научитесь видеть рассуждения, логику, стоящую за вашей системой, так же ясно, как и физический код, тогда вы достигнете программистского просветления.


## Три уровня рассуждений о программной системе

Могу долго бубнить о логике, рассуждениях и предположениях о программе, но чтобы по-настоящему понять это, желательно пощупать исследуемые темы вживую. Три уровня подразумевают разные взгляды на программу:  **исполнение, код и спецификация** . Каждый уровень соответствует своей форме рассуждений, думания о программе.

### Уровень 1. Трейсы и состояния.

На уровне рантайма мы занимаемся состояниями и плохо переводимым на русский трейсами (traces).  **Трейс -- это последовательность событий, которые случаются в процессе работы программы** . Трейсы могут быть очень высокоуровневыми (например, события запуска микросервисов) или очень низкоуровневыми (например, события планирования выполнения машинных инструкций на уровне процессора). Трейсы поясняют, что именно в программе произошло, и дают информацию для понимания текущего состояния системы.

**Состояние -- это набор условных "ячеек" памяти с их текущими значениями** (более подробно, с научной точки зрения, императивная модель вычисления с ячейками памяти изучаем на моих курсах по парадигмам программирования).

На практике состояния – это чаще всего значения в памяти программы, хотя к ним может добавляться окружение (состояние стека например, настройки ОС...) и история (информация, которая ранее была выведена в консоль, файлы, послана по сети...).

Любая инструкция программы, которая может быть выражена в терминах трейсов и состояний, считается относящейся к уровню рантайма.

С точки зрения программиста, абстракция трейсов выражается в виде логов или отладочного вывода в консоль (мы отслеживаем прохождение некоторых ключевых точек, смотрим на программу в динамике), а абстракция состояний возникает, когда мы просматриваем значения переменных и иных объектов в отладчике в пошаговом режиме (смотрим на программу в статике).


## Три уровня рассуждений о программной системе

Соответственно, формальный способ рассуждения на этом уровне очень приземлённый. Он означает рассуждение только о конкретных значениях, без их кванторов (количественных критериев: все, некоторые, многие, несколько, большинство, ни одного).

Например, есть код на Python:

```
left = x - 10
if left < 0:
   left = 0
right = min(x+10, 100)
print(right) # трейс
```

Мы хотим проконтролировать размеры некоторого отрезка вокруг точки x, чтобы его границы не выходили за некоторые пределы (классическая задача в компьютерных играх например, при передвижении по карте). Мы формируем трейс, где следим за правой границей диапазона, и определённое сомнение вызывает условная проверка (с чего это вдруг left стал меньше нуля?). Но выводить какое-то специальное сообщение в трейс в таком случае не лучший вариант. Мы по сути интуитивно подозреваем, что в нашем коде что-то, возможно, уже сломалось, однако можем выяснить это крайне неудобным путём: выводом в логи и затем долгим их анализом (которые даже в случае ошибки могут и не помочь).

Но, допустим, мы выяснили в трейсе, что где-то в процессе работы программы right стал равен 64, и нас интересует, а чему при этом была равна left? В частности, не обнулялась ли она?

Правильный подход на данном уровне -- учиться применять формальные методы. Например, мы можем попросить прувер доказать на основе нашего кода, что
left может стать меньше 0,
если right = 64 и left = x – 10 и right = (if x+10 <=100 then x+10 else 100)

Как правило, такое формальное доказательство сопровождается прозрачным процессом вывода, и мы всегда можем найти истинную причину странной ситуации в коде. Главная проблема, что пока такая формальная верификация кода крайне дорога и трудоёмка, и до массовых проектов доберётся в лучшем случае лет через 10 в каком-то ограниченном виде. Да и вряд ли она станет массовой практикой, потому что даже прозаические тесты пишутся далеко не всегда.

Поэтому тут очень важно научиться формально мыслить "как прувер" о своём коде, постепенно совершенствуя умение "доказывать" в голове правильность и безошибочность своего кода.


## Три уровня рассуждений о программной системе

### Уровень 2. Код.

Это уровень конкретной реализации -- в виде  **исходного кода** .

Теперь мы трактуем каждую инструкцию именно как команду на конкретном языке программирования, записанную в определённом синтаксисе, с определённой семантикой. Но при этом мы уже полностью уходим от состояний и трейсов.

```
public double calculateDamage(int monster1Attack,
                              int monster1Armor,
                              int monster2Defense) {

  int defense = monster2Defense - monster1Armor;

  if (defense <= 0) return 10;

  double k = (double)monster1Attack / (monster2Defense - monster1Armor);
  if (k > 10) return 10;
  return k;
}
```

Подавая различные значения на вход функции, мы будем получать различные результаты – трейсы, потоки состояний. Даже такая простая функция, очевидно, может формировать практически бесконечное количество состояний. Поэтому, если мы на уровне рантайма пытаемся выяснить, возникнет ли в процессе физической работы такого кода ошибка деления на ноль, то на данном уровне мы уже спрашиваем,  **возможно ли потенциально такое выполнение этой функции, этого кода, которое приведёт к ошибке деления на ноль** , пытаясь понять это не по трейсам, а по исходному коду (без его запуска и тестирования)?

Такой стиль рассуждений называется  **логика первого порядка (first-order logic, FOL)** . Это значит, что мы пишем формулы, которые формализуют наши рассуждения в духе "для всех входных значений X, случится ли изменение такого-то свойства?" или "существует ли хоть какое-нибудь входное значение Y, при котором функция сломается?". Только помните, что в FOL мы не можем применять кванторы (для всех, хотя бы для одного…) непосредственно к самим функциям, а только к переменным, именно поэтому эта логика считается первого порядка.

Не буду использовать символы кванторов, напишу по-русски формулу первого порядка, которая "утверждает", что в функции calculateDamage никогда не случится деления на ноль:

```
Для любых значений (monster1Attack, monster1Armor, monster2Defense) :

(defense = monster2Defense - monster1Armor)
И
НЕ (defense <= 0)

следовательно 

monster2Defense - monster1Armor != 0
```

Если нам удастся доказать её истинность, исходя из множества всех подобных формул (аксиом и теорем) по нашей программе, значит, деление на ноль тут гарантированно не случится.


## Три уровня рассуждений о программной системе

### Уровень 3. Спецификации.

Это уровень полноценного формального логического рассуждения о системе. Тут мы применяем спецификации.

В классической разработке это обычно считается уровень проектирования системы, но по-взрослому,  **принципы инкапсуляции и модульности могут быть формально определены только в терминах спецификаций и формальной логики** . Существует много способов задания спецификаций, вы уже познакомились (возможно :) с таким популярным подходом, как  **триплы/тройки Хоара** . Помните, на курсах по ООАП мы изучали пред- и пост-условия в АТД? Вот это они и есть.

Возьмём классическую функцию malloc(n) из Си (выделение n байтов оперативной памяти), которая возвращает либо адрес на выделенный блок байтов, либо нулевой указатель.

```
p = malloc(n)
```

**Предусловие** : всегда запрашивается не менее 1 байта памяти.

**Постусловие** : соответствующая память выделена, и в переменной p оказывается ссылка на неё.


## Три уровня рассуждений о программной системе

На втором уровне (прикладная реализация) мы рассуждаем о специфике реализации malloc, например, не может ли возникнуть перерасход памяти после выполнения системного запроса к ОС? На уровне спецификаций мы обобщаем такие вопросы: возникнет ли в принципе в программе, использующей malloc, ошибка выделения памяти?

Такой стиль рассуждений называется  **логика высших порядков (higher-order logic, HOL)** . В ней используются те же кванторы, что и в FOL, однако теперь мы можем применять их к функциям.

```
malloc_spec(mf) = 

Для любых значений n > 0:

mf(n) != NULL

следовательно 

выделена_память(вызов mf(n), n байтов)
```

Эта запись означает, что для всех значений n больше нуля, любой вызов функции mf(n) гарантированно и корректно выделит память объёмом n байтов. Принципиальный момент, что мы указываем именно абстрактную функцию mf, потому что конкретная malloc из стандартной библиотеки – это будет реализация функции mf, фактически её значение.

Поэтому в конкретном проекте MyProgram мы должны указать (доказать), что

```
Для любых значений mf:

malloc_spec(mf) // истинна

следовательно 

MyProgram_spec(mf, RunMyProgram)
```

Какую бы функцию mf (всевозможные реализации функции выделения памяти) мы не использовали в своей программе MyProgram, спецификация mf всегда истинна (т.е. mf всегда работает корректно и выделяет запрошенную память), следовательно истинна и формальная спецификация для функции RunMyProgram (исполнение MyProgram).

Это и есть пресловутая модульность системы, сведённая к формуле.


## Три уровня рассуждений о программной системе

Очень важная особенность спецификаций в том, что они позволяют задавать такие свойства системы, которые  **невозможно выразить непосредственно в коде** .

Например, спецификация для malloc выражена в терминах условного предиката "выделена_память", но мы можем сформулировать её и с помощью других операций.
Запишем формулу для "выделена_память" (существует хотя бы одна связка mf и n, для которых "выделена_память" истинна), и добавим спецификацию функции free(p) (освобождение памяти), которая освобождает память по указателю p и фактически "разрушает" предикат "выделена_память" (делает его неистинным). И вот теперь, доказав истинность выделена_память(mf,n) для нашей конкретной программы, мы по сути гарантируем, что память, выделенная malloc, всегда будет существовать, и в её работу не вмешается free.

Понятие выделения памяти у нас существует именно на третьем уровне! оно отвязано от кода, от реализации. Возможно, что выделяемая память будет представлять собой некоторую внутреннюю структуру данных, создаваемую менеджером памяти, но также возможно, что код будет успешно скомпилирован для системы с бесконечной непрерывной побайтовой памятью.

---

Мы рассмотрели типичную ситуацию, которая регулярно встречается в самых разных проектах: внутри одного стека, иногда даже при использовании конкретной версии компилятора или стандартных библиотек система работает нормально, но едва реализация функций работы с памятью немного меняется, сразу возникают трудно обнаруживаемые ошибки. Другими словами, нарушается доказательство истинности "выделена_память(mf,n)".


## Три уровня рассуждений о программной системе

Вы закономерно можете спросить: ну и чем поможет такая формальная система спецификаций, если мы всё равно не можем контролировать конкретную реализацию malloc из некоторой стандартной библиотеки, как правило завязанной вдобавок на конкретную ОС (а то и на конкретную версию ОС), когда нету доступа к её исходным текстам?

Да, формально контролировать конкретную реализацию мы не можем, но главный плюс такой системы в другом. У нас теперь имеется  **логически целостный набор правил, которые надо проверять и которым надо следовать при написании кода** . В данном случае, в частности, мы знаем, что надо обязательно проверить, как работает стандартная функция выделения памяти, соответствует ли она своей формальной спецификации.

Главная идея третьего уровня:  **стараться мыслить концептуально, отвлечённо от первых двух уровней** , и затем "механически" переводить (учиться переводить) эти формальные концепции на язык программирования.


## Три уровня рассуждений о программной системе

Третий уровень вроде бы напоминает обычный подход к разработке, когда имеется техническое задание, или менеджеры назначают задачки, но только внешне, различие качественное:  **система спецификаций задана строго формально** , её вполне можно загрузить (как минимум, теоретически) в какой-нибудь пруф-ассистант, и лет через 10 на основе таких спецификаций можно будет, вероятно, (полу)автоматически генерировать программный код. Такие подходы, в принципе, иногда применяются и сегодня, но пока слишком дороги и трудны.

**Cистема спецификаций -- это идеальное техническое задание** , в котором нету никаких противоречий, двусмысленностей или недосказанностей, и при этом оно логически целостное. А при её формировании выявляется огромное количество неясных и, как правило, исходно невидимых человеку технических нюансов, которые приходится формализовывать, осознанно обдумывать и обсуждать.


## Три уровня рассуждений о программной системе

### Заключение

Так что, какие бы проекты вы ни реализовывали,  **всегда думайте о составляющих компонентах с точки зрения абстрактных интерфейсов (в частности, абстрактных типов данных), спецификаций и гарантий правильности, и мысленно переводите их в формулы, подобные приведенным выше** . Немного похож на это подход проектировщиков баз данных, когда они рисуют формальные ER-диаграммы, и затем транслируют их в SQL-скрипты создания структуры БД.

Работает такой подход и для легаси-кода, и в тестировании: можно предварительно покрывать такими спецификациями-"проверками" всяческие подозрительные участки вашего кода. Многое при этом будет становиться яснее именно когда вы этим занимаетесь, ведь  **логика -- это язык проектирования программного обеспечения** .

Как уже говорил, хорошие первые шаги в развитии практического умения создавать подобные формальные спецификации - это TDD, а затем BDD ([подробнее](https://vk.com/wall-152484379_3415)).
