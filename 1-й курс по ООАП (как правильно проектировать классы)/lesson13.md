## Организация модулей в проекте

Ранее упоминался принцип, согласно которому **класс -- это и тип данных (семантическая единица проекта), и модуль (синтаксическая единица проекта)**. Однако линейная схема проекта, в котором могут быть сотни и тысячи классов, плохо подходит для наглядного представления. Поэтому классы обычно группируются в так называемые **кластеры**. Каждый кластер объединяет классы, связанные общим смыслом (например, компоненты пользовательского интерфейса, или элементы библиотеки для работы с сетью).

Однако кластер -- это не какая-то особая самостоятельная, автономная сущность для структуризации проекта, а всего лишь удобный способ управления кодом. Кластер может реализовываться, например, виртуальными папками среды разработки или физическими каталогами операционной системы. Но **единственной модульной единицей в проекте всегда остаётся только класс**.

**Кластер может включать в себя другие кластеры, но не может включать одновременно и кластеры, и классы** (разрешается либо только то, либо только то).

К кластерам не предъявляются особые формальные требования, создание кластеров -- это ответственность прежде всего руководителя проекта или архитектора системы. Единственная рекомендация заключается в том, что в кластере должно быть не более 40 классов (и как правило, не менее 5 классов), и уже при наличии 20 классов желательно начинать разделять кластер на подкластеры. Обычно реализацией одного кластера занимается тоже один конкретный разработчик.

### Legacy (унаследованный код)

Сколь бы старательно мы не продумывали заранее классы и АТД, со временем требования к системе обычно меняются, и подчас весьма сильно.

В ситуации, когда назрела необходимость изменения АТД и, соответственно, интерфейса класса, его реализующего, есть два возможных решения:

1) не менять интерфейсы, что не позволит улучшить систему, а в дальнейшем будет приводить к ухудшению ситуации в целом;
2) изменить интерфейсы, что может существенно усложнить работу нынешних пользователей, но в дальнейшем приведёт к улучшению ситуации в целом. Это решение, в частности, обязательно, если в системе найдены ошибки.

Каждый вариант надо оценивать, исходя из множества особенностей конкретного проекта. В качестве компромиссного в индустрии программного обеспечения принят подход, когда подлежащие удалению возможности (например, классы целиком, или их отдельные методы) официально объявляются **устаревшими**, и при их использовании пользователи получают соответствующие уведомления. Но эти уведомления должны обязательно сообщать срок, когда поддержка устаревших компонентов полностью закончится.
