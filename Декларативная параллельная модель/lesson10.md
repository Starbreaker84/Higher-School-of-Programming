### Потоковые объекты

Мы пишем параллельную программу как сеть нитей, которые обмениваются данными через потоки. Такой подход вводит новое
понятие  **"потоковый объект"** . Фактически, это рекурсивная процедура, которая выполняется в своей собственной нити и
взаимодействует с другими потоковыми объектами через входные и выходные потоки. Потоковый объект может поддерживать
внутреннее состояние (в пределах аргументов внутри своей процедуры, с помощью аккумуляторов).

Потоковый объект мы называем объектом потому, что он имеет внутреннее состояние, доступ к которому осуществляется
контролируемым образом (с помощью сообщений в потоках). Потоковый объект считывает сообщения из входного потока,
выполняет внутренние вычисления и отправляет сообщения на выходной поток. В общем случае, такой объект может иметь любое
фиксированное количество входных и выходных потоков. Потоковые объекты могут быть связаны между собой в граф, где каждый
объект получает сообщения от одного или нескольких объектов и отправляет сообщения одному или нескольким объектам.

Из такого определения мы автоматически получаем формальное определение синхронного программирования, которому вы можете
найти десятки самых разных определений, от технических до просто уровня здравого смысла (пока не закончишь предыдущую
задачу, нельзя перейти к следующей). Однако нам требуется чёткое определение именно в терминах вычислительной модели.

### Синхронное программирование

**Синхронное программирование -- это программирование в рамках направленного графа потоковых объектов** . Потоковый
объект может выполнить свои вычисления только после того, как считает по одному элементу из каждого из своих входных
потоков. Из этого естественно следует, что каждый потоковый объект на графе синхронизирован с любым другим. Потоковому
объекту допустимо опережать в вычислениях своих преемников на графе (которым он передаёт данные), но он не может
опережать своих предшественников (от которых ему поступают данные).

Все учебные примеры параллельного декларативного программирования обычно ограничиваются очень простыми видами графов (
линейные цепи). Однако синхронная параллельная модель применяется и в очень сложных прикладных проектах, в частности,
при проектировании современных электронных схем, состоящих из взаимосвязанных логических вентилей. В синхронной цифровой
логике вся схема может быть смоделирована работой по условным шагам, когда каждый логический вентиль считывает значения
со своих входов, "вычисляет" результат (бит 1/0) и выдаёт его на свои электронные выходы. Шаги по всей схеме физически
синхронизируются тактовым генератором.

В синхронной цепи сигнал изменяется только в дискретных временных интервалах, задаваемых таким генератором, и можно
моделировать сигнал как поток битов (0/1). Логический вентиль -- это потоковый объект, а именно рекурсивная процедура,
выполняемая в собственной нити, которая считывает входные потоки и вычисляет и формирует выходные потоки. Тактовый
генератор -- это рекурсивная процедура, которая формирует исходный поток с фиксированной скоростью.

Каждый вентиль -- это (рекурсивная) функция, которая работает мгновенно, т. е. первый элемент выходного потока
вычисляется непосредственно из первого элемента входного потока. Такой подход позволяет использовать комбинационную
логику (из теории цифровых устройств) -- логические схемы, которые не имеют внутренней памяти. Их выходы -- булевы
функции от их входов, значения выходов полностью зависят от входных значений. Таким образом логические схемы фактически
произвольной сложности моделируются просто комбинацией вызовов таких функций.

### Синхронное программирование

Комбинационная логика однако и ограничена как раз тем, что не подразумевает хранение промежуточной информации. Более
практичны последовательные схемы -- схемы, поведение которых зависит от их собственной предыдущей работы. Проще говоря,
некоторые их выходы возвращаются обратно в качестве входов. Используя эту идею, мы можем построить **бистабильные
схемы** (схемы с двумя устойчивыми состояниями). Бистабильная схема -- это фактически ячейка памяти, которая может
хранить один бит информации (на жаргоне называется flip flop).

Рассмотренный ранее подход тут не сработает, потому что если мы просто соединим выход со входом, программа работать не
будет. Чтобы рассчитать выход, надо сперва считать входное значение. Но входного значения нет, поэтому и выхода тоже не
буде. Фактически, это тупиковая ситуация, существует циклическая зависимость: выход ожидает вход, а вход ожидает выход.

Тут достаточно ввести некоторую временную задержку между входами и выходами, тогда схема сможет корректно брать вход от
своего предыдущего выхода. Такую временную задержку можно смоделировать с помощью вентиля задержки, который просто
добавляет один или несколько элементов в голову потока -- с учётом логики соответствующего вентиля, чтобы он продолжал
свою работу естественно.

**Лингвистическая абстракция для логических вентилей**

Наиболее просто логические вентили реализуются как процедуры, и параметры и результаты которой -- булевы значения.
Однако в общем виде желательно заменить и входы и выходы вентиля потоками (определить поведение вентиля в терминах
потоков), что более естественно позволит использовать их как конвейеры. В таких случаях говорят, что мы **повысили (
lift)** вычисления с булевыми значениями до более "сильных" вычислений с потоками.

### 10. Ленивое и жадное выполнение

======= 26. Трансдьюсер -- это ...

[1 ] промежуточный объект между поставщиком и потребителем

[ ] последовательность потоковых объектов

[ ] фильтр с предикатом

======= 27. Ограниченный буфер -- это ...

[ ] промежуточный объект между поставщиком и потребителем

[ ] трансдьюсер в жадном режиме

[ 1] трансдьюсер, координирующий работу поставщика и потребителя

======= 28. Жадное выполнение -- это то, что происходит, когда...

[ 1] буфер имеет бесконечный размер

[ ] буфер имеет конечный размер

[ ] буфер имеет нулевой размер

======= 29. Ленивое выполнение -- это то, что происходит, когда...

[ ] буфер имеет бесконечный размер

[ ] буфер имеет конечный размер

[ 1] буфер имеет нулевой размер

======= 30. Управление работой поставщика и потребителя через изменение приоритетов -- это ...

[1 ] менее эффективный способ, нежели буфер

[ ] аналогичный по эффективности способ, как буфер

[ ] более эффективный способ, нежели буфер
