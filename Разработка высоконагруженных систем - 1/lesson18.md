### 16. Другие индексные структуры

Индексы типа «ключ — значение» напоминают индекс по первичному ключу в реляционной модели. Первичный ключ однозначно идентифицирует одну строку в реляционной таблице, или один документ в документоориентированной базе данных, или одну вершину в графовой базе.

Распространённой практикой является применение  **вторичных индексов (secondary index)** . В реляционных базах данных в одной таблице можно создавать несколько вторичных индексов с помощью команды CREATE INDEX, причем наличие таких индексов часто критически важно для эффективного выполнения соединений.

Вторичный индекс легко создается из индекса «ключ — значение». Основное отличие от первичного ключа в том, что вторичные ключи неуникальны, то есть может встретиться несколько строк (документов, вершин) с одним и тем же ключом. Эта проблема решается например, так: мы делаем все ключи уникальными, добавив к ним идентификатор строки. В качестве вторичных индексов можно использовать как B-дерево, так и журналированные индексы.


### Хранение значений в индексах

Запросы ищут в индексе ключ, а значение может быть фактической искомой строкой (документом, вершиной) или ссылкой на строку, хранящуюся где-то в другом месте. Во втором случае место, где хранятся строки, называется  **неупорядоченным файлом (heap file)** , и данные в нём хранятся, соответственно, в неупорядоченном виде. Это может быть файл, предназначенный только для добавления данных, или же в нем могут отслеживаться удалённые строки, чтобы позднее перезаписать их новыми данными.

Неупорядоченные файлы используются весьма часто -- они позволяют избежать дублирования данных в случае нескольких вторичных индексов: все индексы лишь ссылаются на местоположение в неупорядоченном файле, а фактические данные хранятся в одном месте.

При обновлении значения без изменения ключа подход с использованием неупорядоченного файла достаточно продуктивен: запись перезаписывается на месте (при условии, что новое значение по размеру меньше старого). Если же оно больше по размеру, ситуация усложняется, так как, вероятно, придется его переместить в другое место, где достаточно свободного пространства. В этом случае придется или обновить все индексы так, чтобы они указывали на новую позицию в неупорядоченном файле, или разместить по старому адресу указатель для переадресации.

В ряде случаев лишний переход от индекса к неупорядоченному файлу — слишком затратная вещь для чтения в смысле производительности, поэтому желательно хранить проиндексированную строку непосредственно в индексе. Такой вариант носит название  **кластеризованного индекса (clustered index)** . Например, в подсистеме хранения InnoDB СУБД MySQL первичный ключ таблицы всегда представляет собой кластеризованный индекс, а вторичные индексы ссылаются на первичный ключ (а не на позицию в неупорядоченном файле). В СУБД Microsoft SQL Server можно например задавать кластеризованный индекс на таблицу.

Компромисс между кластеризованным индексом (хранением всех ключей в индексе) и некластеризованным (хранением в индексе только ссылок на данные) известен под названием  **охватывающего индекса (covering index) или индекса с включёнными столбцами (index with included columns)** . В таком индексе хранится только часть столбцов таблицы, благодаря чему появляется возможность отвечать на некоторые запросы с помощью только одного индекса (и тогда говорят, что индекс охватывает запрос).


### Составные индексы

Обсуждавшиеся до сих пор индексы задавали соответствие отдельного ключа и значения. Этого недостаточно в случае запроса нескольких столбцов таблицы (или нескольких полей документа) одновременно.

Для этого применяются  **составные индексы** . Наиболее распространенный тип составных индексов —  **сцеплённый индекс (concatenated index)** , который просто объединяет несколько полей в один ключ, присоединяя один столбец к другому (в описании индекса указывается, в каком порядке сцепляются поля). Зная порядок сортировки, индекс можно использовать для поиска всех людей с конкретной фамилией или всех людей с конкретным сочетанием «фамилия-имя». Однако он бесполезен, если нужно найти всех людей с конкретным именем, который следует в индексе не первым полем.


### Многомерные индексы

**Многомерные индексы** — более общий способ запроса нескольких столбцов сразу, особенно важный при работе с геопространственными данными. Например, сайт поиска кафе в городе может использовать БД с координатами широты и долготы всех ресторанов. При просмотре пользователем карты сайту необходимо найти все кафе, расположенные внутри текущей прямоугольной области на карте. Для этого необходим двумерный запрос по диапазону вот такого вида:

```
SELECT * FROM restaurants 
WHERE latitude > 51.4946 AND latitude < 51.5079 AND 
      longitude > -0.1162 AND longitude < -0.1004;
```

Стандартный индекс на основе B-дерева или LSM-дерева не сможет обеспечить эффективное выполнение подобного запроса: он выдаст либо все рестораны в определенном диапазоне широт (но с произвольной долготой), либо все рестораны в определенном диапазоне долгот (но в любой точке между Северным и Южным полюсами), но не сможет выдать и то и другое сразу.

Поэтому для поддержки геопространственных запросов применяются **специализированные пространственные индексы** – например, R-деревья (расширение B-деревьев для индексации многомерной информации).

Многомерные индексы можно использовать не только для географических координат. Например, на сайте интернет-магазина можно задействовать трехмерный индекс по осям координат (красный, зеленый, синий), чтобы искать товары в определенном диапазоне цветов. А в базе данных метеорологических наблюдений можно применить двумерный индекс по координатам (дата, температура) для эффективного поиска всех наблюдений за 2020-й год, в которых температура была между 25 и 30 градусами Цельсия. С одномерным индексом пришлось бы либо просматривать все записи за 2020-й год (независимо от температуры), после чего фильтровать их по температуре, либо наоборот. Двумерный индекс способен сузить поле поиска сразу и по метке даты/времени, и по температуре.



### Полнотекстовый поиск и нечёткие индексы

Все обсуждавшиеся до сих пор индексы подходят для ситуации, когда данные точны, только тогда можно предоставить возможность поиска по конкретным значениям ключей или диапазонам значений ключей с заданной сортировкой. Но они не позволяют искать похожие ключи -- например слова с орфографическими ошибками. Подобные **нечёткие (fuzzy) запросы** требуют применения других методов.

Например, системы полнотекстового поиска обычно позволяют расширять поиск по слову путем включения синонимов этого слова, игнорирования грамматических вариантов слов, поиска вхождения слов рядом друг с другом в одном документе. и поддерживают другие возможности, основанные на лингвистическом анализе текста. Применяются тут самые разные подходы, от автоматов Левенштейна, (поиск слов в пределах заданного редакторского расстояния) до машинного обучения.


## Другие индексные структуры (задания)

======= 58. Составной сцеплённый индекс просто объединяет несколько полей в один ключ и ...

[ ] не зависит от порядка полей

[1 ] зависит от порядка полей

======= 59. Многомерные индексы применяются для ...

[ ] геопространственного поиска

[ ] метеорологических наблюдений

[ 1] любого многомерного поиска

======= 60. Нечёткие индексы нужны для ...

[ ] поиска в диапазонах ключей с заданной сортировкой

[ 1] похожих значений

[ ] непохожих значений
