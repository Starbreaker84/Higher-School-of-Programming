### Продуктивное внесение изменений в легаси-код

24. Проблема. Подчас напрашивается (потому что, например, это легко) ввести новое поведение в уже существующие методы. Но если метод создавался правильно, он отвечает принципу единой ответственности SRP и, как правило, выполняет ровно одну полезную функцию. Тогда любой дополнительный код, вносимый в него впоследствии, нарушает SRP и сразу ухудшает системный дизайн, создавая дополнительные логические зависимости.

В плохо сопровождаемых базах кода методы типично проявляют тенденцию к укрупнению -- слабые разработчики добавляют логику в существующие методы, которые в итоге начинают выполнять две или три совершенно разные функции при своём вызове. А в особо тяжелых случаях они могут выполнять десятки, если не сотни функций.

Решение. Переименовываем в новое имя существующий метод, функциональность которого надо расширить. Его старое имя даём новому методу, в котором выполняем композицию новой функциональности и вызов старого метода.\


### Продуктивное внесение изменений в легаси-код

25. Проблема. Добавляемая новая фича (новое свойство) не может быть тесно связано логически со старым свойством (принцип SRP). Она должна быть достаточно автономна (новая операция в АТД) и, соответственно, скорее всего должна выполняться до или после старого метода, поэтому смешивать в новом методе новую логику с вызовом старого метода не очень хорошо.

Кроме того, глобальное переименование старого метода по всему проекту и последующая замена его новым методом выглядят рискованно и требуют аккуратной ручной работы.

Решение. Для подобного рода задач хорошо подходит шаблон декоратора: сначала создаётся абстрактный класс, определяющий ряд операций, требующих поддержки, а затем реализующий его класс, который получает экземпляр класса, методы которого подлежат обёртке, в своем конструкторе, и затем внутри себя вызывает эти методы, добавляя нужное поведение.


### Продуктивное внесение изменений в легаси-код (задания)

======= 23. Когда надо добавить в метод новую фичу и при этом выдержать SRP ...

[ ] создаём новый метод с новым именем

[ ] переименовываем в новое имя существующий метод, расширяя его

[1 ] переименовываем в новое имя существующий метод, а старое имя даём новому методу

======= 24. Какой паттерн проектирования лучше всего подходит при необходимости выполнить композицию нескольких поведений?

[ 1] Декоратор

[ ] Мост

[ ] Адаптер
