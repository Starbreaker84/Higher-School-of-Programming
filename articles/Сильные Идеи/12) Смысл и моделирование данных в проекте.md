## Как найти смысл данных в вашем проекте

Олег разрабатывает игру в жанре IF (текстовые интерактивные истории).

Каждый квест состоит из множества условных локаций. Локация -- это текстовое описание конкретного места/ситуации, в которой можно выбрать один из предложенных вариантов действий, и перейти соответственно к следующей локации. Но даже в самом простейшем случае, когда мы не рассматриваем связи между локациями, начинаются неоднозначные проблемы проектирования.

Очевидно, что каждая локация должна быть связана со своим квестом. В системе может быть много квестов, и в каждом из них может быть много локаций. Олег думает о двух моделях данных. В одной из них каждый квест содержит список всех своих локаций. В другой, в каждой локации есть ссылка на квест, а сам квест содержит только своё название.. Что лучше?

У каждой из этих моделей есть различия в плане того, какие операции они делают проще или сложнее, и на практике часто исходят именно из такого технического уровня. Но ещё до того, как начать обсуждать эти подходы или придумывать иные альтернативы, нужно ответить на основной вопрос:

**Представляют ли эти две модели одно и то же?**

Они эквивалентны, если локации неизменны, но различаются, если локации могут изменяться по ходу игры -- если каждая локация в игре имеет своё состояние (например, флажок "посещена").


### Идентификация сущностей

На первый взгляд, разницы между этими моделями нету. Первая модель заявляет, что квест содержит много локаций. Вторая модель заявляет, что каждая локация связана со своим квестом. Это всё отношения "один ко многим".

Или нет?

Во второй модели довольно очевидно, что ни одна локация не может быть связана с двумя квестами. Но такое вроде как возможно в первой модели.

Но только если локации могут изменяться!

Вы можете возразить, что можно создать иммутабельную локацию, расшарить её двум разным квестам, и вуаля! Но в иммутабельном мире одна копия, используемая дважды, семантически считается тем же самым, что и две независимые копии.

В мутабельном мире вы изменяете заголовок локации, и он обновляется в обоих квестах (так как локация передаётся по ссылке). Но в неизменяемом мире "модифицировать" локацию фактически означает -- создать новую копию исходной локации с новым (изменённым) заголовком, которая будет обновлена в родительском квесте. Чтобы модифицировать другой квест подобным образом, вам нужно будет найти его и выполнить ту же операцию модификации заголовка в её копии соответствующей локации.

Это фундаментальная концепция в программировании:  **у всех изменяемых сущностей имеется своя идентичность (в смысле "самобыстности", личной уникальности)** . А у иммутабельных -- нет.

У иммутабельных значений вообще нету понятия "одно и то же", кроме как "эти две сущности имеют одни и те же значения". Нет способа отличить два квеста, которые содержат одну и ту же локацию, от двух квестов, которые содержат одинаковые копии локации.

С изменчивостью наоборот. Если есть две локации, которые имеют одинаковые значения, и обновление одной из них также обновляет аналогично и другую, то они действительно одинаковы. И наоборот, теперь можно иметь две исходно одинаковые локации (по значениям), которые не считаются формально одинаковыми, потому что изменение одной из них не меняет другую.

Таким образом, тема мутабельности/иммутабельности выходит далеко за рамки обновления значений по ссылке или создания копий.  **Мутабельность/изменчивость прежде всего означает совместное использование** .

Один из способов смоделировать понятие совместного использования -- думать о каждом значении как об условной паре (списке из двух элементов), первым элементом которой будет само значение, а вот вторым -- магическая "лексема/токен", созданная во время выделения памяти под это значение, которая гарантированно будет отличаться от каждой другой такой лексемы в программе. Мы уходим от очень условных низкоуровневых понятий передачи по значению/по ссылке к работе с сущностями, каждая из которых имеет уникальные идентификаторы. В таком случае они всегда передаются "по ссылке", но когда в программе хранится несколько ссылок на такой объект, теперь мы можем всегда явно выяснить, указывают ли они на одно и то же значение (по его уникальной лексеме).

Эта схема объясняет, почему вам необходимо изменить модель данных -- чтобы  **явно добавить каждой сущности некий уникальный идентификатор** . Это, кстати, одна из причин, по которой  **правильно думать об иммутабельности как о неизменяемости по умолчанию** , а о мутабельности -- как о дополнительной возможности (которая требует определённого усложнения модели).


### Качественные различия в моделях

Допустим, вам больше нравится первый вариант "квест содержит список всех своих локаций", в таком случае очень желательно добавить дополнительное правило (инвариант), запрещающее "расшаривать" локации этого квеста. Оно подразумевает дополнительную работу по реализации, но это должно быть легко, а главное, что вы теперь можете просто не заботиться о мутабельности при передаче локаций.

Однако если это требуется, в модели данных понадобятся более глубокие изменения. Например (далее речь только про иммутабельные структуры): в третьем варианте мы храним в квесте не локации как таковые, а лишь некоторую корневую локацию в дереве; у каждой локации, в свою очередь, хранятся локации, в которые возможен из неё переход. Только циклы тут не допускаются (это именно дерево, а не граф).

Четвёртый вариант подразумевает, что квест хранит корневую, крайнюю левую и крайнюю правую локации в дереве локаций, а сами локации, соответственно, хранят только одну родительскую локацию. Третий вариант легко преобразуется в четвёртый просто инверсией связей между локациями.

И вроде бы всё получается красиво -- до тех пор, пока вы не приступите к редактированию, и тут обнаружите, что дерево только притворяется деревом: при каждом его редактировании вам придётся перестраивать большие части. Потому что на уровне реализации иммутабельные локации хранятся по значению, и любое изменение одной из них подразумевает создание нового объекта, который должен содержать новые копии всех объектов в поддереве (так как передача иммутабельных объектов по ссылке в явном виде недоступна).

А вот после добавления изменчивости, оба эти варианта однозначно становятся не одинаковыми. Когда локации получают идентичность, третий вариант теперь легко может представлять произвольные графы -- когда в списке фактически хранятся не локации, а ссылки, можно (ошибочно) добавлять такие ссылки и на вышестоящие локации-узлы, и даже на саму себя.

В четвёртом варианте также возникают подобные странные графы, которые могут иметь циклы, и любая локация в качестве родителя может ссылаться на любого своего наследника. Однако каждая локация тут может иметь только одного родителя, в отличие от третьего варианта.

И в результате вместо думания именно в режиме проектирования ("какая из этих моделей удобнее в использовании") мы переходим к постепенно запутывающейся интеллектуальной игре "какая из этих моделей на самом деле представляет собой нужный нам формат квеста на уровне реализации".


### Изменение полярности

Добавление изменчивости внезапно сделало две исходно иммутабельные модели данных совершенно разными. Случается ли обратное, когда переход к мутируемости может сделать две разные модели одинаковыми?

Вроде бы кажется, что изменчивость лишь добавляет больше различий в модели. Однако, для любого правила о структурах данных часто можно сформулировать обратное правило, поставив структуру данных в "отрицательное положение" -- то есть в качестве аргумента к функции, или в качестве ключа к словарю.

Рассмотрим ещё два варианта, только по локациям. Допустим, в каждой локации мы хотим хранить (в дополнение к её заголовку и описанию) какую-то дополнительную информацию (картинку, перевод на другой язык и т. п.). В пятом варианте мы просто включаем в локацию соответствующие данные в виде строки. Однако более универсальный подход --  **использовать словарь (Map), в котором локация как значение выступает в качестве ключа** . Это весьма популярный шаблон, который позволяет легко расширять существующие структуры данных новыми "полями" без прямой модификации их описания. Например, такие дополнительные "поля" служебные, и прямое их внесение в класса нарушит SRP, и т. п. Такой шаблон часто применяется при расширении API, но он работает, только когда объекты изменяемы (точнее, у всех объектов разная идентичность): ведь два логически разных иммутабельных объекта с одинаковым значением всех их полей дадут одинаковый ключ. В реляционной модели это называется [функциональной зависимостью](https://habr.com/ru/company/JetBrains-education/blog/473882/).

Возможно, вы как-то сможете хакнуть эту схему, заставив функцию вычисления ключа учитывать и уникальный (вероятно) указатель на конкретную иммутабельную структуру, но в целом это делает всю вашу систему некорректной и хрупкой. В случае же изменяемых локаций мы явно предполагаем наличие в них некоторого уникального идентификатора, задающего их идентичность.


### Истинные отношения между сущностями

В самом начале нашего микро-ТЗ говорилось, что квест содержит много локаций, так что не надо ли нам начинать проектирование всё же с самого высокого уровня отношений между квестами и локациями?

Далеко не всегда. Если вы (надеюсь) прошли третий курс по ОО-проектированию, то помните, что мы разрабатываем и прорабатываем каждую сущность достаточно автономно, в отрыве от других, как самостоятельный АТД. И так как в целом вполне имеет смысл обсуждать локацию без привязки к квесту, ни один из подходов "начинать с квестов", "начинать с локаций", "начинать с отношений между локациями и квестами" не будет правильнее других.

Однако, когда мы отмечаем, что в нашей системе существует связь "один-ко-многим", мы в некотором смысле заранее упрощаем нашу систему, придерживаемся некоторого заведомо менее гибкого подхода, от которого впоследствии перейти к более гибкому будет крайне трудоёмко.

Например, возможна ли в будущем ситуация, когда одна локация может принадлежать не одному, а нескольким квестам? Ну почему бы и нет; например, хотя бы в целях отладки такой подход (тестовая проверка небольших сюжетных кусочков длинного квеста, выделенных в отдельный квест) вполне разумен. Стандартный подход проектировщиков баз данных в подобных случаях заключается в расширении отношения до "многие-ко-многим": заводим дополнительную таблицу просто для хранения отношений между квестами и локациями. Вы легко можете получить все локации для квеста, и все квесты -- для локации. Отношения в такой схеме не содержат направления.


Как работу с отношениями выразить на уровне прикладной программы? В 1987 году инженеры-исследователи General Electric придумали [новый стиль программирования](https://www.semanticscholar.org/paper/Relations-as-semantic-constructs-in-an-language-Rumbaugh/ca82d99f69ad34371288e06ab1d6cf264d4319e9), в котором отношения между объектами можно явно создавать, и манипулировать ими так же легко, как и самими объектами. В последнем десятилетии в ИТ наконец возник определённый интерес к этой теме, однако отношения "первого класса" (которыми можно манипулировать наравне с другими значениями (включая и функции)) до сих пор не обрели должной популярности даже в исследовательском мире, поэтому в вашем языке программирования их точно нету.

Однако явная схема отношений "квест-локация", как мы выяснили, была бы крайне полезной, если бы её удалось ввести в программу непосредственно.

В случае классических баз данных, если вы часто используете что-то в одной таблице для того, чтобы по найденным данным выполнять поиск значений в другой таблице, вы можете существенно ускорить этот процесс,  **денормализовав такую структуру: объединив две таблицы вместе** . Да, проектировщики классических реляционных баз данных наоборот всегда стремятся к максимально полной нормализации, однако существует немало конкретных случаев (например, вопрос производительности), когда денормализация помогает. Кроме того, в NoSQL-системах денормализованные данные считаются фактически нормой.


В одном варианте денормализации вы "внедряете" таблицу связей непосредственно в таблицу квестов, оснащая каждый квест списком локаций. А если вы внедрите её в таблицу локаций, то соответственно каждая локация получит ссылку на содержащий её квест. Эти две схемы денормализации соответствуют нашим исходным оригинальным вариантам 1 и 2. Так вот, причина выбирать тот или иной вариант -- тот же самый, что и причина денормализовать таблицу. При выборе между локациями и квестами речь идет прежде всего о том, как часто каждый из них будет задействован при работе программы.

Поскольку наша схема имеют явную тенденцию к росту иерархической структуры и, соответственно, к иерархическому доступу с известной сложностью, стоит ожидать скорее всего, что потребность в извлечении всех локаций квеста будет велика, а вот потребность в работе с локацией некоторого квеста будет незначительной. Это предполагает вариант 1: квесты хранят списки своих локаций (отношения между самими локациями тут мы не рассматриваем!).

Главное, помните, что подобные рассуждения правильно вести прежде всего в контексте денорализации отношений между объектами.

Тут надо также отметить довольно старый метод объектно-ориентированного проектирования [OMT](https://en.wikipedia.org/wiki/Object-modeling_technique), где явно подразумевается семантический смысл связей между объектами, и проектирование требует мышления в терминах отношений, а не иерархии ("объекты -- это точки, а не контейнеры").


### Строительные блоки проектировщика

В контексте изменчивости полезно также обсудить такой довольно тонкий момент, как  **эквивалентность (равенство) двух объектов** . В классическом программировании принято, что если вы с помощью непосредственных инструментов вашего языка никак не можете отличить две сущности друг от друга, то они одинаковы.
См. в частности [Identity_of_indiscernibles](https://en.wikipedia.org/wiki/Identity_of_indiscernibles).

По своей сути, Квест и Локация -- это кортежи. В варианте 1, Квест -- это заголовок и список локаций, в то время как Локация - это заголовок, содержание и список ссылок. В конце концов, единственное, что вы можете сделать с Квестом или Локацией -- это посмотреть их содержимое. Таким образом, если обе компоненты двух Квестов равны, то Квесты неразличимы, а значит, равны. Эта схема легко обобщается на произвольные кортежи.


Но что случится, если одна из этих компонент (например, список локаций) мутабельна? В таком случае Квесты хранят Локации не как полноценные значения, а как ссылки на объекты, и в общем случае разные квесты, как уже отмечалось, потенциально могут содержать ссылки (алиасы) на одни и те же локации. Как в таком случае сравнивать Локации? Если есть по одной локации в двух разных квестах, то это могут быть например физически два разных объекта (ссылки на них), значения всех полей которых одинаковы, или это может быть физически один и тот же объект, на который ссылаются две ссылки в разных квестах.

Так вот, правильный подход к равенству двух сущностей в stateful-модели подразумевает, что **две сущности равны только в том случае, если они идентичны** -- например, по своему явно сформированному магическому токену (уровень кода программы), или по равенству ссылок (уровень реализации). А это возможно только в одном случае:  **если это одна и та же сущность** . То есть **равенство в stateful-модели фактически означает проверку на идентичность** (объект формально равен только самому себе).

Это важное семантическое правило, которое можно долго глубоко изучать, просто примите его как есть. В таком случае два квеста будут равны, только если они содержат ссылки на одни и те же локации. Потому что, допустим, что хотя бы по одной локации в каждом квесте отличаются в том смысле, что это разные объекты. Пусть значения всех их полей полностью совпадают, и если мы будем считать. что такие квесты равны (они содержат ссылки на одни и те же локации, а также разные локации с одинаковыми значениями полей), то изменение любого поля в одной из этих разных локаций мгновенно сделает квесты разными, хотя никаких явных манипуляций непосредственно с ними в программе не происходило.

Конечно, можно определить внутри класса Локация явную операцию сравнения локаций по значениям их полей, если это подразумевается логикой программы, хотя полезность её сомнительна.


Короче говоря: и в частности, и в общем,  **рекомендуется исключать в программе любые операции передачи значений по ссылкам** , и работать как можно ближе к декларативной модели (например, добавить операции быстрого клонирования), если вы исходно не можете чётко и однозначно сформулировать подходящую модель данных, где не могут возникать побочные эффекты (наподобие косвенного изменения локаций в квесте).

Подразумевается, что всё, что вы можете делать с переменной, хранящей "как бы" объект (а реально ссылку на объект):

1) считывать значения полей этого объекта (по переменной-ссылке);
2) перезаписать саму эту ссылку (фактически -- создать новый объект и присвоить ссылку на него соответствующей переменной).

А вот возможность изменения состояния объекта через доступ к его внутренностям по ссылке (например, через сеттеры) желательно полностью исключить.

Этот принцип имеет глубокие последствия в отношении смысла ваших данных в проекте. Очень много проектных подходов сводятся к простому пониманию подобных базовых строительных блоков.
