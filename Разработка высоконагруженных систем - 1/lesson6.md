## Часть 2. HighLoad и базы данных

Современные инструменты и технологии оптимизированы под самые разные сценарии использования и более не укладываются в обычные категории СУБД. Например, существуют хранилища данных, применяемые как очереди сообщений (Redis), и существуют очереди сообщений с уровнем надежности, соответствующим базам данных (Apache Kafka). Границы между категориями постепенно размываются.

Кроме того, современные системы предъявляют такие жёсткие или широкие требования, что отдельный фреймворк уже не способен обеспечить все их потребности в обработке и хранении данных.

Поэтому работа разбивается на отдельные задачи, которые можно эффективно реализовать с помощью отдельного инструмента.

Например, при наличии слоя кэширования (Memcached или аналогичного) или сервера полнотекстового поиска (Elasticsearch, Solr), эксплуатируемых отдельно от БД, синхронизация этих кэшей и индексов с основной базой данных становится обязанностью прикладного приложения.

Получившаяся **интегрированная информационная система** при этом должна будет гарантировать определенные вещи: например, что кэш будет корректно обновляться при записи, и все внешние клиенты увидят непротиворечивые результаты. Таким образом вы становитесь не просто разработчиком, но и  **архитектором информационной системы** .

Большинство современных приложений создаются классическим способом  **наслоения одной модели данных (или модели обработки данных) поверх другой** . Ключевой вопрос для каждого слоя: **как его представить на языке, который характерен для более низкого слоя, непосредственно прилегающего к нему?** В сложном приложении может быть много промежуточных уровней (например, API, создаваемые поверх других API), но исходная идея остается неизменной:  **каждый слой инкапсулирует сложность низжележащих слоев с помощью новой модели данных** .

Но для глубокого освоения даже одной-единственной модели данных придется потратить немало усилий. Посмотрите, сколько уже написано книг по реляционному моделированию данных. Создание крупной системы будет непростой задачей даже при работе с одной моделью данных.

Но поскольку от выбора модели данных очень сильно зависит функциональность основанного на ней программного обеспечения,  **крайне важно выбрать модель, подходящую для вашей конкретной задачи** . На практике, в 99% выбирается реляционная модель и SQL, и такой «мэйнстрим» следует считать порочной практикой. Далее мы рассмотрим группу универсальных моделей, ориентированных на хранение данных и выполнение запросов, и вы научитесь выбирать наиболее подходящую под конкретный проект.

Наиболее известной моделью данных на сегодняшний день считается  **модель данных SQL** , основанная на предложенной в 1970 году Эдгаром Коддом  **реляционной модели** . Данные организованы в отношения (именуемые в SQL таблицами), где каждое отношение представляет собой неупорядоченный набор кортежей (строки в SQL).

Пожалуй, главный её недостаток на сегодня – это так называемое  **объектно-реляционное несоответствие** . Практически 100% фреймворков, используемых в мэйнстриме (прежде всего, в веб-разработке) предлагают объектно-ориентированный подход, который подразумевает  **отображение (маппинг) структуры объектов (полей) в поля реляционных таблиц БД** . В результате появился неуклюжий промежуточный слой между объектами и моделью таблиц, строк и столбцов БД, который формализуется довольно слабо. Такую расстыковку принципиально разных вычислительных моделей иногда называют  **рассогласованием (impedance mismatch)** .

На практике данная проблема маскируется слоями **объектно-реляционного отображения (ORM)** -- например, Hibernate для Java или Django для Python. Они лишь немного ослабляют исходную проблему, добавляя много промежуточных вызовов и обработчиков (буквально на порядок больше, чем если сразу работать с запросами SQL), и при этом всё равно не в состоянии полностью ликвидировать различия между двумя моделями.


## Введение в highload и базы данных (задания)

======= 17. Главная задача ИТ-архитектора?

[1 ] правильно выбрать и бесшовно интегрировать разные технологии

[ ] написать код интеграции разных технологий

[ ] нанять сильных сеньоров

======= 18. На каком языке надо формировать очередной слой ИТ-системы?

[ ] на своём

[1] на языке низлежащего слоя

[] на языке вышележащего слоя

[ ] на SQL

======= 19. ORM -- это...

[ ] это хорошо

[1 ] это приляпка

[ ] разработчику не важно, что это
