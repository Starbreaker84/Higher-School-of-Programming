## Многооператорные транзакции

Проблема 34. Разработчики, привыкшие к комфорту конкурентного доступа, обычно реализуют схему, когда приложение выполняет запрос к базе, читает результат, выполняет ещё один запрос в зависимости от результата первого и т. д. Запросы и их результаты постоянно путешествуют между кодом приложения и сервером базы данных туда-сюда. В результате большое количество времени тратится на обмен сетевыми сообщениями между двумя машинами: пропускная способность в случае отключения конкурентного доступа в СУБД и обработки одной транзакции за раз оказывается на практике ужасной, так как база тратит большую часть времени на ожидание генерации приложением следующего запроса для текущей транзакции.

Решение. В СУБД с однопоточным последовательным выполнением транзакций подобные "интерактивные" многооператорные транзакции запрещены. Вместо них приложение заранее отправляет весь код транзакции в базу данных (например, в виде хранимой процедуры).

## Многооператорные транзакции

Проблема 35. Подавляющее большинство производителей СУБД предлагают свои диалекты SQL и свои языки написания хранимых процедур, несовместимые с другими. А сам код, выполняемый в базе данных, труднее структурировать, сложнее отлаживать, сложнее вести контроль версий, развертывать, мониторить... Да и сами СУБД часто более чувствительны к производительности, нежели серверы приложений.

Решение. По возможности придерживаться стандарта SQL и активнее применять транзакции только для чтения, которые могут выполняться где угодно -- с помощью изоляции снимков состояния, и для масштабирования на несколько ядер процессора и несколько серверных узлов можно секционировать данные (например, поставить в соответствие каждому из ядер свою секцию).

## Многооператорные транзакции

Проблема 36. База данных должна согласовать выполнение любой обращающейся к нескольким секциям транзакции по всем затрагиваемым ею секциям. Соответственно, и хранимые процедуры необходимо выполнять во всех секциях строго синхронно, чтобы обеспечить сериализуемость в масштабе всей системы. В результате многосекционные транзакции работают намного медленнее -- на порядки меньше пропускной способности односекционных транзакций, и увеличить данный показатель с помощью добавления дополнительных машин не получается.

Решение. Надо подумать, можно ли сделать транзакцию односекционной. Это сильно зависит от структуры данных, используемых приложением. Например, данные в формате "ключ-значение" секционировать обычно очень легко, а вот данные с вторичными индексами обычно требуют серьезного межсекционного согласования.

### Проблемы изоляции и сериализуемость (задания)

======= 28. В реплицируемых СУБД ...

[ 1] разрешается создавать несколько конфликтующих версий значения

[ ] запрещено создавать конфликтующие версии значения

======= 29. Aсимметрия записи ...

[ 1] возникает, когда требуемый ресурс исчерпан в конкурентном режиме

[ ] потенциально возможна всегда

======= 30. Универсальное решение проблемы асимметрии записи -- ...

[ ] блокировка на чтение и на запись

[ ] ограничения целостности через хранимые процедуры и триггеры

[ 1] поддержка дополнительных логических ограничений в системе

======= 31. Фантомы -- это когда операция записи в одной транзакции ...

[ ] изменяет результат чтения в другой транзакции

[ ] перезаписывает результат записи другой транзакции

[ 1] изменяет результат запроса на поиск в другой транзакции

======= 32. Сериализуемость -- это ... (выберите неверное утверждение)

[ 1] выполнение по одной транзакции последовательно, в одном потоке

[ ] самый сильный уровень изоляции

[] при конкурентном выполнении транзакций результат останется таким же, как и при последовательном

[ ] предотвращени всех возможных состояний гонки
