### 23. Конструирование программ на основе рекурсивных типов

Это очень мощное и одно из наиболее сильных на сегодня направление в проектировании сложных систем очень наглядно и ясно понимается именно в простой и минималистичной декларативной парадигме. Классический пример -- это любопытное свойство практически всех функций, обрабатывающих списки. Они всегда проверяют, пустой ли параметр-список, выполняя при этом одни действия, а если он не пустой, то выделяют в нём голову и хвост, выполняя над ними другие действия, включающие рекурсивный вызов.

Фактически  **рекурсивная структура функции следует из рекурсивной структуры определения типа** . Список List -- это элемент-голова типа T, сцепляемый с оставшимся списком List. Это свойство, практически всегда истинное для функций, работающих со списками, хорошо помогает при создании таких функций на практике.

Замечание по поводу типов.
В общем случае  **формальное определение типа в конкретном языке дескриптивно/описательно** : оно просто предлагает набор логических утверждений о множестве значений, которые может принять переменная. Однако такие формальные определения, к сожалению, не могут претендовать на полноценную проверку допустимости конкретных значений. Более того, часто их вообще невозможно проверить, и даже простейшие базовые типы (например, положительные целые числа), описанные в декларативной модели, вообще не могут быть проверены компилятором.

Например, требуется написать функцию, которая считает количество элементов в списке, элементами которого также могут быть вложенным списки. Julia допускает такие структуры, например: [[9,7],3,[5,0,1],7]. В таком списке семь элементов.

Как можно определить соответствующий тип NestedList‹T›?

Если обычный список List‹T› определяется так: это ...
-- либо пустой список [],
-- либо элемент T, сцепленный с List‹T›

то NestedList‹T› будет представлен так: это ...
-- либо пустой список [],
-- либо NestedList‹T›, сцепленный с NestedList‹T›,
-- либо элемент T, сцепленный с NestedList‹T›.

Основанная на таком типе функция LengthL(Xs) будет иметь следующую структуру:

-- если Xs -- пустой список [], то return 0

-- если X (голова Xs) -- это NestedList‹T›, и Xr (хвост Xs) -- это NestedList‹T›, то
return LengthL(X) + LengthL(Xs)

-- если X (голова Xs) -- это элемент T, и Xr (хвост Xs) -- это NestedList‹T›, то
return 1 + LengthL(Xs)

```
function LengthL(Xs)

    if Xs == []
        return 0
    end

    head = Xs[1]
    tail = Xs[2:end]

    if isa(head, Array)
        return LengthL(head) + LengthL(tail)
    end

    return 1 + LengthL(tail)
end


println( LengthL([[9,7],3,[5,0,1],7]) ) # 7
```

Функция isa() проверяет тип своего первого аргумента на его "равенство" второму аргументу (в данном случае проверяется, список ли голова).


Изменение структуры типа может приводить к функции с другой логикой. Например, мы хотим посчитать количество элементов в списке только на её "верхнем" уровне (когда каждый вложенный список считаем за единицу, как обычный элемент).

Зададим для этого новый тип NestedList2‹T›:
-- либо пустой список [],
-- либо NestedList2‹T›, сцепленный с NestedList2‹T›,
-- либо элемент "верхнего" уровня.

Его отличие от NestedList‹T› в том, что NestedList‹T› -- это всегда список, а NestedList2‹T› может быть как списком, так и отдельным элементом типа T.

Функция получится такая:

```
function LengthL2(Xs::Array)

    if Xs == []
        return 0
    end

    head = Xs[1]
    tail = Xs[2:end]

    if tail == []
        return 1  
    end

    return LengthL2([head]) + LengthL2(tail)
  
end

println( LengthL2([[9,7],3,[5,0,1],7]) ) # 4
```

Если рекурсия добралась до одиночного элемента (когда хвост -- пустой список), то мы уже не изучаем этот элемент (а не список ли он?), а просто засчитываем его как единицу.


Отсюда следует важный урок:  **надо уметь правильно определять рекурсивный тип перед тем, как писать функцию, которая с этим типом работает** . Иначе очень вероятна, например, "наивная" и неэффективная реализация, или даже ошибки во время выполнения. По этой причине, в частности, функциональные языки (например, OCaml/F# или Haskell) автоматически поддерживают так называемый  **вывод типов (type inference)** , когда компилятор определяет, какого типа каждая функция (её сигнатура) -- по контексту её использования/вызова в коде. Вывод типов гарантирует, что рекурсивный тип используется корректно, но, конечно, качественное проектирование самого типа зависит от опыта и мастерства программиста.

**Многие алгоритмы удобно разрабатывать именно в декларативной модели в силу её минималистичности** : она исключает множество потенциальных ошибок. В частности, часто применяется простая стратегия  **"разделяй и властвуй" (divide-and-conquer)** : выделяем в некоторой рекурсивной структуре две (или больше) примерно равных её частей, после чего применяем этот алгоритм к каждой части. Данная стратегия отлично работает например для списков, деревьев и многих других более сложных типов.


### Конструирование программ на основе рекурсивных типов (задания)

======= 50. Выберите истинное утверждение:

[x]рекурсивная структура функции следует из рекурсивной структуры типа

[ ]рекурсивная структура типа следует из рекурсивной структуры функции

[ ]рекурсивные структуры функции и типа не связаны

======= 51. Изменение структуры типа ...

[ ] не требует изменения работающей с ним функции

[ ] требует функции с другой логикой

======= 52. Выберите истинное утверждение:

[ ] вывод типов гарантирует правильное проектирование рекурсивного типа

[ ] универсальные функции для работы с любыми типами можно проектировать заранее

[x] рекурсивный тип надо правильно определять до создания функции для данного типа

======= 53. Стратегия "разделяй и властвуй" в декларативной модели -- это ...

[ ] декомпозиция функций сверху-вниз

[ ] разделение функций на несколько примерно равных частей

[x] выделение в рекурсивной структуре несколько примерно равных частей
