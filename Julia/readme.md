Julia

В классическом понятии "переменная" традиционно объединяются две концепции: идентификатор (символьное имя переменной в исходном коде) и физическая ячейка в памяти, связанная с этим идентификатором и непосредственно хранящая значение переменной.

Однако существует фундаментальная концепция однократного присваивания, распространённая например в функциональном программировании: после того, как переменная в программе получила первое значение, она становится неизменяемой (своеобразный аналог константы времени выполнения).

Строки в Julia заключаются в двойные кавычки, символьные литералы -- в одинарные кавычки.
К элементам строк можно обращаться по индексам (индексация в строках, массивах и списках в Julia начинается с 1):
println("Hello")
println("Hello"[2])

Внутрь строк можно включать выражения Julia (например, имена переменных), перед которыми ставится знак $ -- в таком случае вместо подобной конструкции с префиксом $ подставится значение выражения, вычисленное динамически.
n = 123
x = 23
println("n = $n ;") # n = 123 ;
println(" $(n*n-x)") # 15106

Если мы хотим вычислить факториал 10! , можно записать такое выражение:

println(1*2*3*4*5*6*7*8*9*10)
Но если мы хотим посчитать 100! , вручную вводить все множители неудобно. В общем случае хотелось бы иметь возможность считать факториал любого целого неотрицательного числа n. Для этого определим функцию с именем fact, которая будет получать параметром значение n.

Функции в Julia определяются так:

function имя ( список параметров через запятую )

тело функции

end
Каждый параметр -- это локальная переменная, которая видна только в пределах тела функции. Каждый раз при вызове функции параметры внутри неё создаются заново с нуля.

Результат, который функция возвращает -- это значение её последнего выражения перед end. В общем случае можно использовать оператор return в любом месте тела функции, и для наглядности рекомендуется использовать return.

Тело функции задаётся с отступами (как в языке Python); рекомендовано делать четыре пробела и не использовать в отступах TAB.

function fact(n)
if n <= 0
return 1
else
return n * fact(n-1)
end
end

println(fact(10))

Функция fact работает так: если условие n <= 0 истинно, вычислится значение "выражения" 1, и return вернёт его в качестве результата работы fact.

Если условие n <= 0 ложно (значение параметра n больше нуля), выполнится ветка else -- вычислится выражение n * fact(n-1). Такой вызов в теле функции её же самой называется рекурсия.

В данном случае вызов n * fact(n-1) раскрутится в n * (n-1) * fact(n-2), и так далее до тех пор, пока n не станет равным 0. Тогда функция в конце такой цепочки вызовов вернёт 1, которое затем будет умножено на 2, и обратно до исходного n.

Вызывав fact(20), мы получим 2432902008176640000, но вызывав fact(50), получим -3258495067890909184. Мы проходили проблему с переполнением значений переменных на базовом курсе. Напомню, проблема в том, что, в зависимости от используемой вами версии Julia и операционной системы, для хранения целого числа скорее всего отведено 64 разряда, и слишком большие числа представляются некорректно.

В Julia поддерживается большой набор базовых целых и вещественных типов, для которых указывается разрядность: Int8, Int64, Int128, Float32, Float64 и т. д. Существуют также типы BigInt с BigFloat с произвольной точностью, но операции с ними эмулируются программно, поэтому увлекаться ими не стоит, если актуальны вопросы производительности.

Приведение некоторого значения V к типу T в Julia записывается так:

T(V)
Если мы хотим, чтобы функция fact() вернула значение типа BigInt, ей надо явно указать, что она получает аргумент этого типа (например, с помощью приведения типа), тогда и все результирующие вычисления с ним будут автоматически приведены к BigInt.

fact(50) # -3258495067890909184
fact(BigInt(50)) # 30414093201713378043612608166064768844377641568960512000000000000

Задействуем функцию факториала для определения количества сочетаний из n по r.

function comb(n, r)
div(fact(n), fact(r)*fact(n-r))
end
В comb() функция fact() вызывается три раза. Такой принцип, когда в определении новых функций используются готовые внешние функции, называется функциональная абстракция. Если таким способом строить большие программы, они становятся похожими на луковицы со многими слоями: функции, вызывающие функции, вызывающие функции...

В Julia допускается компактная запись определений коротких функций, которые умещаются в одной строке:

имя-функции(список-параметров) = тело функции
Например:

comb(n, r) = div(fact(n), fact(r)*fact(n-r))

println(comb(10,3)) # 120

Списки -- более сильная абстракция, нежели массивы, которые, как правило, лучше знакомы программистам на статически типизированных языках. Мы приходим к спискам естественно, как только возникает потребность вычисления и обработки последовательностей чисел и значений других типов. Классический пример -- это последовательность Фибоначчи, когда каждый следующий элемент равен сумме двух предыдущих.

Типа данных "список" (как в Python например) в Julia нету, однако синтаксис типа данных "массив" похож на синтаксис списка. В частности, в Julia допускается массив, содержащий элементы разных типов; мы будем трактовать его как "универсальный" список, без особой привязки к специфике Julia.

Условный список в Julia -- это последовательность элементов произвольных типов, перечисленных через запятую, в квадратных скобках.

[1,2,3,5,8]
x = [] # пустой список
Внутри список (не конкретно в Julia) обычно реализован как цепочка узлов, где каждый узел состоит из хранилища значения узла и ссылки на следующий узел. Списки формируются добавлением по одному элементу, начиная с пустого списка [], и последующим добавлением узлов друг за другом.

Новый узел записывается как H|T, где H -- значение нового элемента, и T -- оставшаяся часть цепочки узлов. Например, начинаем со списка Z=[]. Добавляем первый узел Y=7|Z, и затем второй узел X=6|Y. Теперь X ссылается на список из двух узлов, который может быть записан как [6, 7].

Узел H|T часто называется cons -- термин, который пришёл из языка Лисп.

В Julia добавление значения в голову списка записывается так:

Z = [6, 7]
pushfirst!(Z, 5) # Z == [5,6,7]
Символ ! в конце функции добавления означает, что она модифицирует значение своих аргументов (в данном случае, изменится значение списка Z). По умолчанию все аргументы передаются в функции Julia по ссылке, если позволяет их тип.

Первый элемент списка называется голова (head). В Julia его можно получить обычным обращением к списку с индексом.

Индексация массивов в Julia начинается с 1, не с 0.

Z = [5,6,7]
Z[1] # 5
К последнему элементу массива можно обратиться с помощью условного индекса end:

Z[end] # 7
Z[end - 1] # 6
Оставшаяся часть списка без головы называется хвост (tail). Удалить из списка его голову (оставить хвост) можно командой

popfirst!(Z) # Z == [6,7]
Сцепление списков (добавление второго списка в хвост первого списка) выполняет команда append!

Добавление элемента в хвост списка выполняет команда push!

Создание массива длиной N вещественных чисел, заполненного нулями, выполняет команда zeros:

a = zeros(N)

Сопоставление с образцом (Pattern matching)
Эта мощная классическая техника, своеобразная замена условным операторам, подразумевает проверку некоторого значения по набору шаблонов, и в случае совпадения -- разбор по подходящему шаблону. В оригинальной Julia она реализована в ещё более сильной форме (сопоставляются не значения, а типы), но это тема за пределами данного курса.

Некоторую классическую версию сопоставления с образцом можно добавить в Julia, установив пакет Match.jl. Для этого надо запустить среду Julia, и в командной строке поочерёдно ввести две команды:

using Pkg
Pkg.add("Match")
Pkg -- это встроенный менеджер пакетов Julia (очень удобный). Он автоматически скачает и добавит пакет Match (надо будет подождать несколько минут).

Пакет Match предлагает свой собственный дополнительный синтаксис, не будем погружаться в его детали, рассмотрим такой пример:

using Match
@match([1,2,3], [a, b...])
Команда using подключает в программу пакет, не входящий в стандартную поставку Julia.

Команда @match выполняет сопоставление значения из левой части (список [1,2,3]) с шаблоном из правой части [a, b...]. В данном случае он подразумевает выделение первого элемента "a" в списке, и оставшийся список-хвост "b..." (в переменной b).

В результате сопоставления значения с таким шаблоном/образцом в переменную "а" запишется число 1, а в переменную "b" -- оставшийся список [2,3].

Сопоставление с образцом часто применяется не только для анализа списков, но и как очень мощная замена операторам if/switch, поэтому рекомендую изучить, как эта технология поддерживается в языке программирования, которым вы активно пользуетесь.

Функции над списками

Допустим, мы не имеем возможности индексировать списки. Вообще, это фундаментальное отличие списков от массивов, которые допускают обращение к их элементам по индексам, поэтому формально списки в Julia -- это массивы.

Требуется написать функцию, которая возвращает n-й элемент списка (n >= 1).

using Match

function nth(n, lst)
@match(lst, [a1, b...])
if n == 1
return a1
elseif b == []
return nothing
end
return nth(n-1, b)
end

println(nth(4, [1,2,3,4]))
nothing -- это аналог отсутствия значения (null/None в других языках).

Если n равно 1, то мы уже имеем голову списка в переменной "a" после сопоставления с образцом, и возвращаем её в качестве значения функции.
Если наоборот конечный список пустой, значит выявлена попытка выхода за границы списка (индекс слишком большой).
Во всех других случаях продолжаем рекурсивный поиск n-1 - го элемента в хвосте "b" списка.

Выделение головы и хвоста, какая-то их промежуточная обработка и последующий рекурсивный вызов -- классический шаблон многих функций, работающих со списками.

Правильность/корректность кода

Программа считается корректной, если она делает в точности то, что от неё ожидает разработчик. Но как это определить? Вручную "проиграть" работу достаточно сложной программы практически невозможно. Типовой простой способ -- убедиться, что программа корректна, по результатам её работы. Например, подробное тестирование кода увеличивает доверие к нему, но на практике таким образом удаётся выловить лишь около половины ошибок.

Наиболее универсальный подход -- уметь глубоко и достаточно легко рассуждать о коде программы. Это означает следующее:

1. Нужна математическая модель вычислений для языка программирования, определяющая, что он может делать. Такая модель называется семантика языка (на практике, смысл его инструкций).
2. Надо формально определить, что мы хотим от программы, чтобы она делала. Например, есть математическое определение входных данных и результата, который вычисляется на выходе. Это называется спецификация программы (на практике, например, техническое задание).
3. Нужны математические методы для рассуждений о конкретной программе, используя семантику применяемого языка программирования. То есть мы хотим продемонстрировать (доказать в идеале), что некоторый код соответствует спецификации. Это область формальной верификации кода.

Конечно, программа, правильность которой доказана, всё равно может выдавать некорректные результаты, если например с ошибками реализована система, на которой она реализована и выполняется (компилятор, рантайм, ОС, процессор...).

Одна из классических форм доказательства правильности -- это математическая индукция. Сперва мы доказываем, что программа корректна для простого случая. Затем мы доказываем, что если программа корректна для некоторого данного случая, то она будет корректна и для следующего случая. Из этих двух моментов делается вывод, что программа корректна в целом.

Например, есть пустой список [] или список с одним или несколькими элементами, и из данного списка T следует его продолжение H|T -- мы получили корректное определение списка (иногда такой подход называют рекурсивным типом данных).

Всегда надо иметь в виду, что правильно подобранный алгоритм играет гораздо большее значение для производительности программы, нежели оптимизирующий компилятор или сверхмощный процессор. Просто пока разработано гораздо меньше продуктивных алгоритмов, чем требуется.

Эффективность алгоритмов часто оценивают по так называемой временнОй сложности -- как время работы программы зависит от количества входных данных. Например, взлом криптографических ключей путём грубого перебора всех вариантов имеет экспоненциальную временную сложность 2^n (при добавлении одного нового элемента время работы удваивается). Квадратичную сложность n^2 имеют, например, алгоритмы с двумя вложенными циклами (имея 10 элементов, надо перебрать 10x10 вариантов). Линейная сложность n -- это обычный перебор всех элементов списка. Квазилинейная сложность n * log n -- это алгоритмы сортировки, и т. д. Как правило, алгоритмы со сложностью выше квазилинейной считаются непрактичными, и пригодны для работы с совсем небольшими наборами данных.

Ленивые вычисления

Функции, которые мы делали выше, начинают работать сразу же, как только их вызвали. Эта схема называется энергичные или жадные вычисления.
Другой путь выполнения функций называется ленивыми вычислениями. В ленивых вычислениях функция начинает работу, только когда непосредственно затребован её результат.

В Julia ленивые вычисления поддерживаются пакетом Lazy. Добавьте его в систему:

using Pkg
Pkg.add("Lazy")
В простейшем случае, ленивые вычисления означают, что например элементы списка не будут вычисляться, пока они не затребованы непосредственно. Пакет Lazy вводит новый тип List (ленивый список), который сам по себе содержит базовые операции для классической работы со списками.

Например, список 1,2,3 с помощью этого ленивого типа запишется так:

using Lazy
x = list(1,2,3)
println(x) # List: (1 2 3)
Над списком возможны операции first (получить голову) и tail (получить хвост):

println(first(x)) # 1
println(tail(x)) # List: (2 3)

Здорово, что в Julia разрешается запись списков в каноническом виде, как мы обсуждали выше:

H|T
(вместо "|" в Julia используется ":" ).
Например,
1:list(2,3)
означает список list(1,2,3).
При этом связок элементов ":" в такой записи списка может быть несколько, а между ними разрешается использовать не только константы, но и выражения, что сразу даёт нам мощный механизм формирования ленивых конструкций.

Например, мы хотим определить функцию, которая генерирует бесконечный ленивый список последовательных целых чисел, начиная с заданного. В компактной форме она запишется так:

lazy(n) = n:lazy(n+1)
Однако при её вызове, например, lazy(5) система вылетит с ошибкой времени выполнения -- переполнение стека. Это понятно: функция начинает сразу энергично генерировать бесконечный список, хотя пока им никто пользоваться не собирается.

Поэтому подключим модуль Lazy и инструкцией @lazy укажем, что вычисление должно проходить лениво:

using Lazy
lazy(n) = @lazy n:lazy(n+1)
print(lazy(5))
Мы мгновенно получим результат:

List: (5 6 7 8 9 10 11 12 13 14 15 ...)

где многоточие в конце намекает, что список бесконечный. На самом деле, конечно, он не вычислялся, а просто при запросе print() было сгененировано несколько первых значений.

В Julia существует специальная команда take, которая позволяет получить нужное количество значений от генератора таких бесконечных последовательностей (они обычно называются итераторы). Например, получить список из первых пяти значений:

println(take(5, lazy(25))) # List: (25 26 27 28 29)

Программирование высшего порядка

Что, если мы хотим получить от lazy последовательность не идущих подряд чисел, а по какой-то иной, гораздо более сложной или нелинейной закономерности? Например, через одно, или удваивающиеся значения? Делать для каждого такого случая отдельную функцию неудобно и громоздко.

Хотелось бы иметь одну универсальную, обобщённую версию генератора последовательностей. Её можно сделать, передав функцию, вычисляющую следующее значение, как аргумент нашей функции lazy. Вот такая способность передавать функции в другие функции через их параметры -- когда функции сами выступают значениями -- и называется программирование высшего порядка
(в русскоязычной программистской литературе более распространён термин "функции высшего порядка").

Мы хотим передавать в lazy некоторую функцию, которая будет вычислять следующее значение последовательности произвольным способом на основании текущего значения. Для этого достаточно указать ещё один параметр lazy, который, подразумевается, будет функцией:

lazy(n, f) = @lazy n:lazy(f(n), f)
Например, мы хотим вычислить последовательность, каждый следующий элемент которой в два раза больше предыдущего. Определим соответствующую функцию:

function f2(x)
return x * 2
end
И вызовем lazy (запросим первые пять значений, начиная с 7):

take(5, lazy(7, f2)) # List: (7 14 28 56 112)

Циклы

Промежуточное отступление про циклы в Julia, которые понадобятся в дальнейшем.

Оператор цикла записывается так:

for счётчик in список или диапазон
тело цикла
end
Счётчик последовательно принимает значения из списка, например:
for s in ["one", "two", "three"]
println(s)
end
Список чисел можно задавать начальным и конечным значением:

for n in 1:10
println(n)
end
Цикл while будет выполняться, пока истинно его условие:

while условие
тело цикла
end
Например:
n = 10
while n > 0
println(n)
n -= 1
end
Однако такой код в последних версиях Julia выполняться не будет. Дело в том, что этот мультипарадигмальный язык особое внимание уделяет профилактике типовых ошибок кодировщиков, по которым собрана огромная статистика. В частности, один из популярных багов -- когда значение некоторой переменной изменяется внутри цикла, и потом эта переменная используется в коде где-то позже, о чём программист забывает. Потому что, строго говоря, циклы, как и функции, как правило не предназначены для модификации "внешних" по отношению к ним переменных, и нужны прежде всего для "агрегации" индексируемых или итерируемых данных (например, расчёта суммы элементов списка). Но если локальные переменные, видимые только внутри функций -- это сегодня повсеместная практика, то локальные переменные, видимые внутри циклов, реализованы пока в немногих языках, включая теперь и Julia.

В данном примере в команде n -= 1 переменная n локальна внутри цикла while (переменная n из присваивания n=10 -- это глобальная по отношению к циклу переменная), поэтому когда выполняется команда n -= 1, возникает ошибка, так как локальная переменная n пока не имеет значения.

Поэтому, начиная с Julia 1.5, глобальным переменным внутри циклов надо задавать явную аннотацию global:

n = 10
while n > 0
println(n)
global n -= 1
end

Параллелизм (одновременное выполнение, concurrency)

В современном программировании часто требуется, чтобы программа содержала несколько самостоятельных активностей, каждая из которых выполняется в своём темпе. Этот принцип будем называть для удобства параллелизм -- в смысле одновременного выполнения (concurrency, программная поддержка одновременной работы).

Между активностями не должно быть никаких взаимных помех. Они исполняются абсолютно независимо друг от друга, если только программист не решит каким-то явным и корректным образом организовать их взаимодействие.

Введём понятие параллелизма через нить, тред (thread). Нить -- это обычный выполняющийся код. В предыдущих примерах мы писали небольшой код и запускали программу, последовательно выполнявшую разные функции (это была одна нить).

После введения концепции одновременной работы программе допускается поддерживать более чем одну нить, каждая из которых работает одновременно с другими нитями, и в то же время полностью независимо от других нитей.

Julia поддерживает несколько моделей параллельных вычислений (требуется версия не менее 1.5.0), но чтобы этот режим заработал, надо запустить компилятор с параметром "-- threads n" , где n -- количество одновременных нитей, не менее 2. Например:

julia --threads 4
По умолчанию Julia работает с одной нитью; текущее количество максимально доступных нитей в вашей системе выдаёт функция Threads.nthreads().

Идентификатор текущей нити, начиная с 1 (главный процесс, основная программа), выдаётся функцией Threads.threadid(). На практике идентификаторы N нитей укладываются в диапазон 1..N, однако полагаться на этот нюанс не стоит.

Самая простая модель concurrency в Julia подразумевает использование макрокоманды Threads.@threads , которая задаётся перед оператором цикла for. В итоге каждое выполнение тела этого цикла автоматически "разбрасывается" между нитями, причём никакого подразумеваемого порядка такого разбрасывания в принципе не существует.

Обычный код

for i = 1:10
println("i = $i on thread $(Threads.threadid())")
end
естественно выведет

i = 1 on thread 1
i = 2 on thread 1
i = 3 on thread 1
i = 4 on thread 1
i = 5 on thread 1
i = 6 on thread 1
i = 7 on thread 1
i = 8 on thread 1
i = 9 on thread 1
i = 10 on thread 1
Программа выполняется в одной мастер-нити (идентификатор 1).

Переведём этот цикл в параллельный режим:

Threads.@threads for i = 1:10
println("i = $i on thread $(Threads.threadid())")
end
Теперь результат скорее всего будет каждый раз случайным, например:

i = 9 on thread 4i = 4 on thread 2

i = 1 on thread 1
i = 5 on thread 2i = 10 on thread 4

i = 6 on thread 2
i = 7 on thread 3
i = 8 on thread 3
i = 2 on thread 1
i = 3 on thread 1
Почему так происходит? Потому что механизм распараллеливания выполняет код из соображений эффективности. Программисту при написании прикладного кода правильнее всего полагать, что все повторения тела цикла выполняются одновременно. Иначе возникают вышеописанная проблема, называемая обычно проблемой race conditions.

На практике возможно например, что будут задействованы не все нити, или какие-то нити значительно активнее, нежели другие. Программиста это не должно заботить в том плане, что он исходно обязан учитывать, что никакой последовательности выполнения "тел" параллельного цикла не существует, и можно лишь быть уверенным в том, что тело выполнится нужное количество раз.

Кроме того, операции ввода-вывода из-за необходимости взаимодействия с периферийными устройствами, которые нередко используют свои аппаратные буферы, могут выполняться не совсем так, как ожидается. В данном случае видно, что хотя вывод всей строки выполняется всегда корректно, однако переход на новую строку иногда сбивается: результат работы следующей нити выводится быстрее, нежели перевод строки, отправленный терминалу из предыдущей нити.

Ссылки/указатели в Julia
Промежуточное отступление про ссылки/указатели в Julia, которые понадобятся в дальнейшем.

В Julia поддерживается работа с безопасными ссылками, гарантирующими как корректность данных, на которые они указывают, так и автоматические выделение и очистку памяти. Причём указатели допускаются не только на пользовательские объекты и данные сложных типов, но и на значения базовых типов.

Функция Ref() возвращает внутреннюю ссылку на объект-параметр. Если в качестве аргумента задаётся значение базового типа (например, целое число), Julia автоматически выполнит его размещение в памяти, и Ref() вернёт корректную ссылку на соответствующую "ячейку".

Например, Ref(1) разместит в памяти значение 1 целого типа, и вернёт ссылку (указатель) на это значение:

pnt1 = Ref(1)
В дальнейшем можно как считывать значение, доступное по ссылке, так и менять его. Для этого используются скобки [] , указываемые непосредственно за именем переменной-указателя.

pnt1 = Ref(1)
println(pnt1[]) # 1

pnt1[] = pnt1[] + 11
println(pnt1[]) # 12

Поток данных Dataflow
Что произойдет, если операция попытается использовать переменную, которая еще не определена (идентификатор не связан с конкретным значением)? Даже с эстетической точки зрения было бы неплохо, если бы операция просто подождала, когда в эту переменную загрузится некоторое первичное значение. Например, переменную инициализирует какая-нибудь другая нить, и затем данная операция сможет продолжить работу. Такая парадигма называется dataflow (поток данных).

Её наивная реализация потенциально даже не требует поддержки работы с неопределёнными переменными. Можно просто использовать некоторые значения как флажки, показывающие, может ли операция продолжаться, как и реализовано в различных распространённых языках программирования. Опасность такой ситуации как раз в том, что мы явно привязываемся к конкретным состояниям (а не к их отсутствию), что всегда чревато ошибками, ну и выразительность и простота кода существенно снижается. А ведь именно качественное различие в выразительности кода и формирует различные парадигмы.

В документации Julia приводится такой пример:

Thread 1:
global b = false
global a = rand()
global b = true

Thread 2:
while !b; end
use(a)
Вторая нить ждёт, когда флажок "b" станет истинным (а это произойдёт, только когда в первой нити переменная "a" получит некоторое случайное значение), и лишь после этого начинает обработку переменной "a".

В Julia при желании можно смоделировать и схему с неопределённой переменной, так как формально переменные до их первой инициализации действительно остаются в неопределённом состоянии. Обращение к неопределённой переменной вызовет ошибку времени выполнения UndefValError.

Имеется макро @isdefined, которое проверяет, определена ли некоторая переменная x:

println(@isdefined z) # false
z = 32
println(@isdefined z) # true
Таким образом, факт определения значения некоторой переменной, которая ранее была не определена, может служить флагом для продолжения работы процесса, контролирующего эту переменную.

Thread 3:
while ! @isdefined(a); end
use(a)
Тут надо учитывать потенциальную опасность memory unsafe в конкретном языке, когда например значение переменной "a" может непредсказуемо меняться в разных нитях. Обычно для этого применяется паттерн lock(a)/unlock(a), который блокирует возможность изменения некоторой глобальной переменной другими нитями до окончания её использования.

В целом, парадигма Dataflow отличается, во-первых, независимыми корректными вычислениями -- независимо от того, как они распределяются по параллельным процессам.

Например, имеются три функции, первая из которых возводит глобальную переменную X в квадрат, как только она будет определена. Вторая функция задаёт переменной X значение 9, и третья функция выполняет задержку работы всей программы на 10 секунд. В каком бы порядке мы не стали вызывать эти функции, как бы мы не распределили их по нитям, в парадигме Dataflow итог всегда будет один и тот же: программа замирает на 10 секунд и выдаёт значение 81.

И во-вторых, сами вычисления скромны и терпеливы: они не посылают никаких сигналов, а просто ждут, когда активизируются нужные им данные.

Добавление нитей и временных задержек в программу может кардинально изменить форму её работы, но до тех пор, пока одни и те же операции вызываются с одними и теми же аргументами, результаты программы всегда будут одними и теми же. Это ключевое свойство dataflow-параллелизма. Поэтому данная парадигма предоставляет множество преимуществ параллелизма без излишних сложностей, обычно ему присущих.

Состояние

В идеале функция должна иметь какую-то внутреннюю память. Тогда функция может как-то менять своё поведение от вызова к вызову, для примера, улучшая его. Такого рода память называется явное (эксплицитное) состояние. Как и в случае с параллелизмом, явные состояния в существенной степени моделируют реальный мир.

Например, мы хотим знать, сколько раз вызовется некая функция f(). Для этого в неё надо добавить явное состояние.

Существует множество способов определения явного состояния. Самый простой -- это выделить для него одну ячейку памяти. Это своего рода коробка, в которую можно поместить любое содержимое. Во многих языках программирования её называют "переменная". Пока мы будем называть её "ячейка" (физически существующая в памяти компьютера), чтобы избежать путаницы с переменными, которые больше похожи на математические переменные, т.е. служат просто ярлыками для значений на фазе компиляции.

Формально для работы с ячейкой требуются три операции: создание (выделение) ячейки памяти, запись значения в ячейку и считывание значения из ячейки. На практике они скрыты за классическими переменными.

count = 0

function f(x)
global count += 1
return x*x
end

f(1)
f(1)
f(12)
println(count) # 3

Объекты
Функции с внутренним состоянием, которое в них интегрировано и недоступно за пределами функции, обычно называются объекты (которые не надо путать с объектами из объектно-ориентированного программирования). Это естественный переход - от предыдущего варианта, когда пришлось определять отдельную переменную count во всей программе, а внутри функции обращаться к ней с префиксом global, - к концепции объекта, расширяющего функцию внутренней памятью. Причём эта внутренняя память скрывается от внешнего мира внутри функции -- инкапсулируется, и доступа к ней никакого нету.

Поддержка такой парадигмы (функция с локальной ячейкой внутри как одно целое -- объект) сегодня реализована в единичных довольно экзотических языках.

Классы

Было бы удобно, если объекты из предыдущей секции можно было создавать массово по одному шаблону. Допустим, нам надо 10 функций с внутренним состоянием, но каждый объект -- это уникальное описание функции, поэтому в коде потребуется явно создать 10 формально разных, а фактически одинаковых объектов (функций с внутренней памятью).

Для этого можно создать "фабрику", которая может штамповать такие объекты автоматически в любом нужном количестве. Такая фабрика называется класс.

Класс -- это функция, которая внутри себя создаёт новый объект и возвращает его как свой результат. Такая возможность возврата функции (объект -- это функция) как результата работы функции -- типична для программирования высшего порядка.

В современном объектно-ориентированном программировании классы из соображений простоты и удобства трактуются как типы данных, дополненные специальным синтаксисом (например, особой операцией создания нового экземпляра класса). Класс объединяет некоторые данные (которые можно скрыть, инкапсулировать внутри класса) и операции над этими данными, которые обычно называют методы. У каждого объекта, созданного по шаблону класса, своя собственная внутренняя память, изолированная от других.

Такая парадигма называется объектно-базированной. Когда к ней добавляется концепция наследования, мы получаем классическое объектно-ориентированное программирование. Наследование подразумевает, что новый класс может быть определён в терминах уже существующих классов: достаточно лишь специфицировать, в чём новый класс от них отличается. У этого подхода имеется много специфических особенностей реализации в каждом языке, которые приходится детально изучать.

"ООП" в Julia

1. Пользовательские типы данных в Julia
   В Julia отсутствует понятие "класс" из классического ООП. Julia допускает определение типов данных на основе так называемых структур или записей, имеющихся во многих популярных языках программирования.
   Прим.: статическая проверка типов в Julia отсутствует.

Структура объединяет только именованые значения, она фактически то же самое, что и класс, в котором отсутствуют методы. Экземпляр структуры создаётся с помощью условного "конструктора" -- имени структуры (типа), за которым в скобках перечислены начальные значения его полей в том порядке, в каком они определены в описании структуры.

Например, следующий код задаёт структуру (тип) данных Tiger с двумя полями -- taillength вещественного типа, и coatcolor строкового типа. Далее создаётся экземпляр Tiger (объект) с именем tigger.
struct Tiger
taillength::Float64
coatcolor::String
end

tigger = Tiger(3.5, "orange")
println(tigger) # Tiger(3.5, "orange")
Тип любого объекта можно получить с помощью функции typeof(tigger)

typeof(tigger) # Tiger
Однако принципиальный момент, что "объекты" Julia по умолчанию иммутабельны -- значения их полей изменять нельзя. Так, следующий код выдаст ошибку:

tigger.taillength = 3.3
Можно явно указать, что структура мутабельна, с помощью ключевого слова mutable:

mutable struct Tiger
taillength::Float64
coatcolor::String
end

tigger = Tiger(3.5, "orange")
tigger.taillength = 3.3
println(tigger) # Tiger(3.3, "orange")
Но такой подход настоятельно не рекомендуется, независимо от того, в какой парадигме вы работаете. Когда используются только иммутабельные структуры, конечно, каждый раз чистые функции будут создавать их копии, что создаёт дополнительную нагрузку, и тем не менее её стоит принести в жертву общей выразительности и чистоте кода.

В ситуациях, когда всё же имеются очень веские основания создавать мутабельные объекты, порекомендую библиотеку Accessors.jl ("to make updating immutable data simple"):
github.com/JuliaObjects/Accessors.jl

2. Наследование в Julia
   В Julia можно создавать новые типы данных на основе ранее определённых структур, однако "наследование в лоб" не поддерживается по достаточно глубоким причинам. В частности, из-за того, что структуры -- это совсем не классы, а обрабатываются они с помощью так называемой схемы multiple dispatch.

Простой способ, в детали которого вдаваться не будем -- это объявить родительский класс абстрактным с помощью ключевого слова abstract, что означает, что создание реальных объектов на его основе не допускается.

abstract type Cat end
Но зато теперь на его основе можно создавать другие структуры (типы данных) с помощью "оператора" наследования <: , который на самом деле в computer science и теории ООП известен как subtyping operator.

На основе типа Cat создадим его "наследников" (правильно говорить subtype, но на русском, к сожалению, так и не появилось качественного перевода):

abstract type Cat end

struct Lion <: Cat
maneColor::String
roar::String
end

struct Panther <: Cat
eyeColor::String
end

li = Lion("green", "rrr")
println(li) # Lion("green", "rrr")

3. subtype() и supertype()
   Функция supertype(тип) возвращает "родительский" тип для типа-аргумента.
   Самым верхним супертипом в иерархии типов Julia будет тип Any.
   Например:

supertype(Int64)    # => Signed
supertype(Signed)   # => Integer
supertype(Integer)  # => Real
supertype(Real)     # => Number
supertype(Number)   # => Any
Соответственно, фунция subtypes() возвращает список типов-"наследников" данного. Список, потому что их может быть больше одного, в отличие от "предка" (когда множественное наследование не поддерживается).

4. Передача по ссылке и по значению
   Хотя в других языках программирования структуры обычно передаются по значению, в Julia они передаются по ссылке, как обычные объекты.

abstract type Cat end

mutable struct Lion <: Cat
maneColor::String
roar::String
end

function change(l::Lion)
l.roar = "GHr"
end

li = Lion("green", "rrr")
println(li) # Lion("green", "rrr")
change(li)
println(li) # Lion("green", "GHr")
5. "Полиморфизм" в Julia
Так как методы в структурах Julia недопустимы, применяется потенциально более мощный механизм, называемый multiple dispatch. Наивное объяснение его таково, что в программе допускается определить сколько угодно функций с одинаковыми именами и одинаковыми количествами параметров, которые будут отличаться только типами своих параметров.

Выбор подходящей функции в момент её вызова будет выполнен автоматически в зависимости от типов конкретных аргументов.
В классической реализации ООП такой полиморфизм реализуется в более простой форме, на основании типа только первого параметра метода (this, self, ...).

abstract type Cat end

struct Lion <: Cat
maneColor::String
roar::String
end

struct Panther <: Cat
eyeColor::String
end

mutable struct Tiger
taillength::Float64
coatcolor::String
end

function test(t::Tiger)
t.taillength += 15.0
t.taillength
end

function test(p::Panther)
"grrr"
end

function test(l::Lion)
l.roar
end

li = Lion("green", "rrr")
pant = Panther("gray")
t = Tiger(55.5, "white")

println(test(li))   # "rrr"
println(test(pant)) # "grrr"
println(test(t))    # 70.5

Чуть более сложный пример по multiple dispatch:

mutable struct Tiger
taillength::Float64
coatcolor::String
end

# 

abstract type Cat end

struct Lion <: Cat
maneColor::String
roar::String
end

struct Panther <: Cat
eyeColor::String
end

# 

function fight(t::Tiger, c::Cat)
println("The $(t.coatcolor) tiger wins!")
end

fight(t::Tiger, l::Lion) = println("The $(l.maneColor)-maned lion wins!")

# 

tigra = Tiger(55.5, "white")

fight(tigra, Panther("blue")) # The white tiger wins!
fight(tigra, Lion("yellow","R")) # The yellow-maned lion wins!

fight(Panther("brown"), Lion("red","RAWR"))

# Load Error: no method matching fight(::Panther, ::Lion)

Чтобы избежать последнего бага, надо добавить такую функцию:

fight(c::Cat, l::Lion) = println("The cat beats the Lion")
fight(Panther("brown"), Lion("red","RAWR")) # The cat beats the Lion
Запомните этот пример, он потребуется в последующих тестах.

Недетерминизм и время

Мы разобрались, как добавлять в программу параллелизм и состояние по отдельности. Но если мы добавим обе эти возможности одновременно, программа от вызова к вызову может выдавать разные результаты на одних и тех же входных данных. Так случается потому, что нити могут получать доступ к состояниям в непредсказуемом порядке, который зависит от внешних условий. Подобная изменчивость называется недетерминизм. Его причина в том, что точное время, когда будет выполнена та или иная инструкция в программе, теперь неизвестно -- потому что нити работают независимо и не представляют, какие инструкции выполняются в других нитях.

Сам по себе недетерминизм не проблема: мы уже сталкивались с ним, когда разбирались с параллелизмом. Трудности начинаются, когда возникает наблюдаемый недетерминизм (уже упоминавшаяся ранее конкуренция, race condition).

Возьмём простой пример с нитями:

global a = 0

Thread 2:
a = 1

Thread 3:
a = 2
В результате такой работы в ячейке "a" будет либо 1 либо 2 -- но мы не можем заранее предсказать, что именно.

Однако проблемы наблюдаемого недетерминизма гораздо глубже.
Например:

global a = 0

Thread 2:
I = a
a = I + 1

Thread 3:
J = a
a = J + 1
На первый взгляд, независимо от того, в каком порядке вызовутся нити 2 и 3, в ячейке "а" окажется значение 2, так как в каждой нити её содержимое увеличивается на 1. Однако на самом деле в ячейке "а" вполне может оказаться 1 (и на практике скорее всего так и будет).

Причина в том, что в реальных условиях работа нитей чередуется, причём в общем случае невозможно понять, как. Исходный код программы транслируется в двоичный машинный код, и механизм обеспечения одновременного выполнения нитей выделяет так называемый квант времени поочерёдно каждой нити. За этот квант времени может, например, выполниться всего одна машинная инструкция, то есть явную привязку квантованного выполнения к исходному коду выполнить фактически невозможно.

Но даже если мы будем условно считать, что за один квант выполняется одна инструкция исходного кода, ситуация не проясняется. Вполне вероятен например такой порядок одновременного выполнения нитей 2 и 3:

a = 0
I = a # I = 0
J = a # J = 0
a = I + 1 # a = 1
a = J + 1 # a = 1
Это самый простой пример, а в реальных программах, где смешиваются параллельные вычисления и состояния, постоянно возникают значительно более сложные конфликтные ситуации. Мастерство разработки подобных программ в очень существенной степени связано с пониманием принципов "чередования" работы нитей, квантованного выполнения кода.

Печально известный пример -- канадский аппарат лучевой терапии Therac-25, который из-за подобного бага выдавал пациентам дозы, в тысячи раз превышающие назначенные, что приводило к смертям и тяжёлым заболеваниям. Одна и та же переменная в этом аппарате использовалась сразу в двух задачах, которые могли выполняться одновременно.

Отсюда важный вывод: старайтесь никогда не использовать вместе параллелизм и состояния. Программу практически всегда можно спроектировать так, чтобы разделить эти аспекты, или, в самом крайнем случае, ограниченно и наглядно совместить их в совсем небольшой и хорошо изолированной части проекта.

В общем случае под недетерминированным алгоритмом понимают алгоритм, который при одних и тех же данных возвращает разный результат. Классический пример таких алгоритмов -- вычисление, "угадывающее" результат.

Например, алгоритм вычисления квадратного корня из N может генерировать случайное число, умножать его на само себя, и проверять, будет ли результат близок к N. Понятно, что при однократном испытании такой алгоритм скорее всего не выдаст верный результат, однако если его вызывать много-много раз, в конце концов (возможно, через тысячелетия работы компьютера) мы получим нужный результат.

Другой пример -- поиск индекса нужного значения в массиве. Алгоритм выбирает случайный индекс в массиве, и проверяет, равен ли элемент массива по этому индексу нужному значению.

Такие алгоритмы напрашиваются для реализации в параллельном формате. Вместо того, чтобы ждать тысячу лет, можно собрать компьютер со ста тысячами ядер, запустить на каждом отдельный процесс, и получить результат за один час.

Но особенность недетерминированных алгоритмов в том, что в общем случае они не укладываются в полиномиальное время -- сложность их выше, чем O(n^x), а например, O(2^n).

Атомарность

Один из хороших способов правильно организовать программирование с параллелизмом и состоянием -- это использовать атомарные операции. Операция является атомарной, если мы не можем наблюдать какие-то промежуточные состояния обрабатываемых ей данных. Атомарная операция сразу "прыгает" непосредственно от начального состояния к конечному результату.

Упоминавшаяся проблема race conditions связана с тем, что нити, выполняющие некоторый набор действий над одной общей ячейкой памяти, начинают перебивать работу других нитей, выполняющих аналогичные действия. В результате значение этой ячейки меняется непредсказуемо: одна нить обрабатывает ранее считанное значение, и ещё не записала свой результат обратно, а в это время влезла другая нить и тоже изменила значение на своё. Один из способов борьбы с race conditions -- это организация так называемого потоково-безопасной (thread-safe) работы программы. Программисту предоставляется механизм атомарного выполнения: набор действий над общей ячейкой объявляется некоторой нитью атомарным, и пока он полностью не закончится, никакая другая нить не сможет работать с этой ячекой.

С помощью атомарных операций мы можем решить вышеприведённую проблему с неверным итоговым изменением переменной "a" в нескольких нитях. Идея заключается в том, чтобы обеспечить такой режим работы, когда тело каждой нити будет атомарным. Для этого нам нужен механизм построения атомарных операций.

Однако, атомарность и thread-safe в общем случае не гарантируют недетерминизма.

thread A
начало атомарной операции
y = 0
x = y
конец атомарной операции
print x

thread B
начало атомарной операции
y = 1
x = y
конец атомарной операции
print x
Теперь каждая из операций будет выполняться в своём кванте времени, без перебивки другими, однако итоговый результат всё равно будет непредсказуем (0 1 или 1 0).

Правильная детерминированная модель:

thread A
x = 0
запуск thread B
начало атомарной операции
x = x + 1
конец атомарной операции
ожидание окончания работы thread B
print x

thread B
начало атомарной операции
x = x + 2
конец атомарной операции
завершиться
В результате всегда будет выводиться 3.

Пример на Julia, в котором может проявиться проблема конкуренции (race condition):

global i = 0

ids = zeros(4)
old_is = zeros(4)

Threads.@threads for id in 1:4
global i = i + id
old_is[id] = i
ids[id] = id
end

println(old_is)
println(ids)
Тут вполне вероятна ситуация, когда в одной нити выполнится
global i = i + id
после чего в другой нити также выполнится
global i = i + id
и в результате в old_is обоих нитей запишется одно и то же дважды подряд модифицированное значение i.

Атомарность в Julia, с поддержкой режима thread-safe, обеспечивается специальным типом Threads.Atomic, в который "оборачиваются" значения, обработка которых должна быть атомарной.

i = Threads.Atomic{Int}(0)
{Int} это тип, параметризующий тип Threads.Atomic под нужное значение. Обратите внимание, что global теперь можно не указывать, так как Atomic по определению должен поддерживать "глобальность" переменной.

Вместо обычной операции сложения "i = i + id" теперь надо использовать специальную атомарную операцию Threads.atomic_add!(), которая меняет значение своего первого аргумента (это должно быть имя переменной), добавляя ему значение второго аргумента. Вдобавок эта функция возвращает значение изменённого аргумента, поэтому мы можем выполнить нужное действие в одну строчку, что по сути гарантирует, что в процессе его выполнения не будет переключения на другую нить:

i = Threads.Atomic{Int}(0);

ids = zeros(4)
old_is = zeros(4)

Threads.@threads for id in 1:4
old_is[id] = Threads.atomic_add!(i, id)
ids[id] = id
end

println(old_is)
println(ids)
Существуют также и другие механизмы обеспечения атомарности. Например, функция lock() блокирует некоторую ячейку (переменную) от изменения другими нитями до момента, пока она не будет явно разблокирована с помощью unlock(), хотя квантование времени и переключение между нитями выполняется в обычном порядке. Но эти режимы, как показывалось ранее, в общем случае не гарантируют детерминизм вычислений.
Однако при организации параллельных вычислений всегда обеспечивайте атомарность вычислений, насколько возможно.
