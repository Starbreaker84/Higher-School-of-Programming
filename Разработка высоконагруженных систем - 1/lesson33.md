У подхода RPC есть фундаментальные недостатки. Главная проблема его и схожих моделей, что сетевой запрос в реальных проектах сильно отличается от локального вызова функции, хотя формально между ними как раз стараются не делать различий.  **Локальному вызову функции присуща предсказуемость** : он или завершается успешно, или нет, в зависимости только от контролируемых параметров.  **Сетевой запрос непредсказуем** : запрос или ответ на него может потеряться вследствие сетевого сбоя, удаленная машина может работать медленно или быть недоступной, и подобные проблемы вне контроля разработчика. А проблемы с сетью встречаются очень часто, и их нужно предугадывать -- например, путем повтора отправки неудавшихся запросов.

Локальный вызов функции или возвращает результат, или генерирует исключение, или вообще ничего не возвращает (поскольку, например, попадает в бесконечный цикл вследствие фатального сбоя системы). У сетевого запроса есть ещё один вероятный исход: может произойти возврат, но без результата вследствие превышения времени ожидания (таймаут). В этом случае клиент просто не будет знать, что произошло: пока не получен ответ от удалённого сервиса, никак не возможно понять, был ли доставлен и выполнен запрос (это классическое и потенциально неразрешимое противоречие).

Если попытаться отправить «неудавшийся» сетевой запрос повторно, то надо учитывать возможность того, что предыдущие запросы на самом деле доставляются и выполняются, а теряются лишь ответы. В этом случае повтор отправки приведет к повторному выполнению действия, что может привести к фатальным последствиям (например, запрос списывает со счёта клиента некоторую сумму за покупку). Для обхода этой проблемы в протокол обмена встраивается  **механизм дедупликации (идемпотентности)** , хотя и тут решение получается не абсолютное, а относительное.


Каждый вызов локальной функции занимает примерно одно и то же время. Сетевые запросы выполняются намного медленнее вызовов локальных функций, причем задержка варьируется гораздо сильнее. В удачных случаях запрос может выполняться за миллисекунды, но если сеть или удаленный сервис перегружены, то лаг может составить и многие секунды.

Локальной функции при вызове можно передать ссылки (указатели) на объекты в локальной памяти. При выполнении сетевого запроса все эти параметры приходится кодировать в байтовые последовательности, которые можно отправить по сети. В случае параметров, относящихся к простым типам данных (например, строк или чисел), никаких проблем нет, но для больших объектов, содержащих другие объекты, причём такая вложенность может быть произвольной, всё резко усложняется.

Клиент и сервис могут быть реализованы на разных языках программирования (и так почти всегда и происходит), но при этом фреймворку RPC придется преобразовывать типы данных одного языка программирования в типы данных другого языка. Но типы далеко не всех языков одинаковы или даже хотя бы совместимы на элементарном уровне целых чисел. А в случае одного процесса, написанного на одном языке программирования, эта проблема отсутствует.


Главный вывод: **не надо пытаться сделать удаленный сервис похожим на локальный сервис** (объект) языка программирования, поскольку это принципиально разные вещи. Подход REST, в частности, более привлекателен, потому что не пытается скрывать сетевую природу протокола (хотя некоторые RPC-библиотеки и создаются на основе REST).

Новое поколение фреймворков RPC уже явно декларирует различие между удаленным запросом и локальным вызовом функции. Например, получили популярность такие концепции, как  **фьючеры (futures) и промисы (promises)** , инкапсулирующие потенциально сбойные асинхронные действия. Фьючеры также упрощают ситуации, при которых приходится выполнять параллельно запросы к нескольким сервисам с последующим объединением их результатов. А технология gRPC поддерживает  **потоки данных (streams)** , где вызов состоит не просто из одного запроса и одного ответа, а из последовательности производимых в течение некоторого времени запросов и ответов.


## Особенности технологии RPC (задания)

======= 110. В RPC локальные и сетевые вызовы выполняются ...

[ ] одинаково продуктивно

[1 ] локальные лучше

[ ] сетевые лучше

======= 111. Несовместимость типов клиента и сервера RPC характерны ...

[ ] для локальных вызовов

[ 1] для сетевых вызовов

======= 112. Надо ли стремиться сделать локальный и удалённый вызовы одинаковыми?

[ ] да, это отличная универсальность

[ 1] нет, это принципиально разные подходы

======= 113. Тренды развития RPC
(выберите одно лишнее)

[ ] инкапсуляция потенциально сбойных асинхронных действий

[ ] параллельные запросы к нескольким сервисам с последующим объединением их результатов

[ 1] автоматическое преобразование типов данных разных языков программирования

[ ] вызов составляется из последовательности запросов и ответов
