## 44 правильных вопроса при разбирательстве с легаси-системой

*по материалам [asking-answering-fse06.pdf](https://www.cs.ubc.ca/~murphy/papers/other/asking-answering-fse06.pdf)*

Само по себе изучение кода проекта "в вакууме" довольно абстрактно и бессмысленно. Вместе с кодом у вас должна быть работающая система, сформированная из этого кода, с которой вы взаимодействуете через UI.

Разбирательство начинается с выбора некоторой фичи UI или некоторой активности программы -- например одной из самых важных в программе, или той, которая связана с активностью приложения, которую вам надо подкорректировать. В учётной системе это может быть главная форма с полями, или реакция на кнопку генерации отчёта, или вывод сообщения об ошибке, в игре -- движение персонажа на карте, и т. п.

Этап 1. Сперва ищем  **начальную точку фокуса в коде** , на которой надо сосредоточиться. Это ситуация, когда вы знаете о проекте очень мало или вообще ничего, и конечно сильно заинтересованы в поиске любой начальной точки, с которой можно начать изучение системы.

1. Какой тип (как правило, класс в ООП) представляет данную сущность предметной области, или данный элемент пользовательского интерфейса, или активность?

Ищем в коде класс, который определяет экранную форму (как принято во многих средах визуального проектирования UI, например в C#), или класс персонажа, который содержит метод его передвижения, или класс с методом-обработчиком нажатия на кнопку выдачи отчёта. Как правило, тут находится исполняемый код, где задействована нужная сущность.

2. Где именно в коде проекта находится соответствующий метод, или текст сообщения, или компонент UI?

Перемещаемся непосредственно к коду (скорее всего, в найденном классе), где определён соответствующий метод или атрибут. F12 в Visual Studio например :)

3. Где находится код, реализующий это поведение или иную логику?

На предыдущем вопросе мы могли переместиться, например, к сигнатуре метода или функции, которая в языках наподобие Си/С++ отделена от реализации. Или это мог быть абстрактный класс. Теперь надо найти сам код, реализующий найденный класс/метод/функцию.

4. Есть ли ещё в проекте похожие сущности, другие прецеденты, которые, возможно, реализуют изучаемую фичу?
5. Есть ли в текущей семантической единице (например, в модуле, пакете, классе) сущности с похожим названием?

Вопросы 1-4 решаются обычно с помощью простого текстового поиска по файлам проекта, чаще всего внутри IDE. Однако вопросы, подобные пятому, сложнее решаются с помощью обычного поиска по тексту, потому что разработчик обычно имеет пока лишь общее представление о том, что он ищет, и как может называться соответствующая сущность -- и то в не слишком частом случае, когда в проекте соблюдаются правила хорошего стиля кодирования и именования. Тут требуется больше усилий, от простой прокрутки кода и более внимательного code review до обзора проекта на более высоком уровне (через просмотрщики древовидной структуры проектов и классов). Нередки также ситуации, когда объём выдачи поиска или количество кандидатов, определенных иным способом, будет довольно большим, и тогда необходимо ответить на фундаментальный вопрос:  **что тут является релевантным** ?

Для этого можно использовать отладчик: ставить точки прерывания в возможных местах (совсем не обязательно предварительно тщательно изучая код), и смотреть, какие из этих точек прерывания сработают во время выполнения изучаемой функции. Такая расстановка точек может выполняться даже случайно, прерывания устанавливаются в большом количестве, чтобы сперва отобрать реальные кандидаты, потому что нередки ситуации, когда например некоторые классы -- вроде бы подходящие кандидаты, оказываются никак не связанными с нужной логикой.

Этап 2. Когда мы нашли место в коде, напрямую ответственное за реализацию нужной фичи, далее надо определить другие места,  **сущности в коде, связанные с изучаемой по смыслу** . Делается это через анализ связей исходной точки с её окружением.

Тут надо помнить, что  **мы ищем ближайшее окружение к текущей точке -- условную схему "звезда"** , когда исходная точка в центре, и к ней на расстоянии 1-2 связи расположены другие точки. Ошибочно будет формировать схему "цепочка", когда мы находим новую точку, и от неё по новой связи уходим всё дальше и дальше от исходного места.

6. Какие ещё сущности входят в состав текущего типа (класса)?
7. В какие типы входит текущий тип через наследование?
8. Где данный тип находится в иерархии типов? Поизучайте эту иерархию вверх и вниз на 1-2 шага.
9. Есть ли у данного типа "братья и сёстры"? Когда мы определили родителя данного класса, надо посмотреть, какие ещё у родителя имеются потомки.
10. Где поле данного типа используется в других типах? Надо выяснить, задействован ли данный тип в других типах через композицию (как тип компонента другого класса).
11. Если данный тип -- интерфейс или абстрактный класс, то как он реализуется?

Следующие вопросы в этой категории направлены на  **обнаружение сущностей и отношений, которые фиксируют входящие соединения с изучаемой сущностью** .

12. Где данный метод вызывается, или имеются ссылки на данный класс?
13. Когда в процессе работы программы вызывается данный метод (как например выглядит стек в момент вызова метода)?
14. Где в коде создаётся соответствующий объект (экземпляр класса)?
15. Где в коде происходит обращение к данной переменной или структуре данных?
16. Какие данные запрашиваются у данного объекта?

Наконец, следующие вопросы касаются  **исходящих "коннекторов" от изучаемой сущности** . Эти вопросы направлены на изучение поведения этой сущности.

17. Что предположительно делает данная сущность в проекте, если судить по её определению?
18. Какой смысл параметров данной функции?
19. Какими бывают аргументы этой функции во время работы программы?
20. Какие данные модифицируются в данном коде?

На одни вопросы в этой категории можно ответить напрямую с помощью инструментов IDE -- например, просмотром стека вызовов в отладчике, на другие -- приблизительно, изучением структуры классов и точек вызовов методов, что обычно предоставляют современные среды разработки. Ситуация нередко усложняется, если в коде активно применяется полиморфизм, наследование и рефлексия -- появляется много дополнительного шума при интерпретации "смысла" изучаемой сущности. В таких случаях стоит посмотреть, например, на более сложные и нестандартные инструменты.

Этап 3. Понимание графа сущности.

Третья категория вопросов касается  **понимания сущности в контексте множественных отношений с другими сущностями** . Тут требуется понимание общей структуры соответствующего подграфа, включающего изучаемую сущность.

Различие этой категории и предыдущей в том, что теперь мы рассматриваем не просто прямые связи с конкретным объектом, а рассматриваем подграф системы в совокупности со всеми другими объектами. Мы добираемся уже до целостной структуры определенных частей кодовой базы, пытаемся понять, "почему" всё происходит именно так, как происходит, и какая логика стоит за той или иной декомпозицией.

21. Как экземпляры типов, связанных с изучаемой сущностью, создаются и конструируются?
22. Как эти типы или объекты связаны?
23. Как именно реализован этот подграф (управление объектом, работа пользовательского интерфейса, и т. д.)?
24. Что в этом подграфе обеспечивает разные варианты работы?
25. Какие виды поведения подграфа (как правило, он --- абстрактная структура данных) обеспечивают совместную работу его элементов, и как эти поведения распределяются между типами, входящими в подграф?
26. Каков "правильный" способ использования этого подграфа или доступа к нему?
27. Как этот подграф "выглядит" (представлен в памяти) во время работы программы?

Другие вопросы в этой категории касаются  **данных и потока управления** . Обратите внимание, что это не вопросы типа "кто вызывает этот метод?", а вопросы о потоке управления или потоке данных с участием разных методов и нескольких сущностей, например "как мне в этом месте получить вон то значение?".

28. Как могут быть конкретные данные получены (как организовать к ним доступ) в данной точке кода?
29. Как поток управления в программе добирается (отсюда и до) сюда?
30. Почему поток управления в программе не добирается досюда?
31. Какой путь выполнения кода происходит в данном случае (use case)?
32. При каких обстоятельствах вызывается данный метод или генерируется данное исключение?
33. К каким частям этой структуры данных осуществляется доступ в данном коде?

Для ответа на эти вопросы постоянно приходится возвращаться к сущностям, повторяя вопросы, описанные в первых двух категориях.

"Я забыл, что мы выяснили ранее... Я хочу ещё раз взглянуть на этот компонент... Становится очень трудно представить в голове, как это работает...".

Отчасти проблема заключается в том, что разработчик ранее обнаружил и рассмотрел соответствующие сущности и отношения по отдельности, но этого не всегда достаточно для мысленного построения ответа на вопросы данной категории, поэтому те сущности были поняты слишком поверхностно или ограниченно.

Этап 4. Понимание групп подграфов.

Четвертая категория включает вопросы о  **связанных группах подграфов** . Вопросы из предыдущего раздела связаны с пониманием одного подграфа, в то время как вопросы данной категории связаны с пониманием отношений между несколькими подграфами, или с пониманием схемы взаимодействия между подграфом и остальной частью системы. Например, вопрос 29 связан с пониманием конкретного потока "активности", проходящего через ряд методов, в то время как вопрос 34 из данного раздела касается отличий между связанными потоками управления.

34. Как поведение всей системы зависит от этого типа данных?
35. В чём различие между этими типами?
36. В чём разница между этими схожими частями кода (например, между множествами методов)?
37. Какова раскладка между этими типами пользовательского интерфейса UI и между типами модели?

После формирования представления о связанных структурах надо понять,  **как изменить эти структуры** , для чего в свою очередь желательно понять, как сами эти структуры связаны с остальной частью системы.

38. Куда следует добавить это дополнение, или обработать этот случай?
39. Где в пользовательском интерфейсе может быть добавлена данная функциональность?
40. Чтобы перенести эту функцию в тот код, что еще нужно переместить вместе с ней?
41. Как мы можем узнать, что этот объект был создан и проинициализирован правильно?
42. Каким будет (или уже было) прямое воздействие этого изменения?
43. Каково будет общее воздействие этого изменения?
44. Решит ли это проблему полностью, или лишь обеспечит некоторое улучшение?

---

В целом,  **эта работа оказалась гораздо слабее, нежели я изначально рассчитывал** . Вопросы довольно часто сформулированы нечётко, неоднозначно; непонятно, а что делать-то надо. Возможно, оригинальный материал для открытого доступа был ограничен и не включил какие-то уточняющие важные детали.

Резюме, что, в общем, подход, представленный в этом чек-листе, сам по себе неплохой, но слишком "инженерный", слабовато формализован, много белых пятен. Пройтись по этому чек-листу при изучении неведомой системы, конечно, точно будет полезно, но с другой стороны, ожидать высокой продуктивности от него не стоит. Надеюсь, что на моём курсе Ясное Легаси эту тему получится проработать гораздо более глубоко.
