## Транзакции

Проблема 1. В реальном проекте многое может пойти не так:

- софт или аппаратура могут отказать в любой момент (например посередине операции записи);
- в любой момент может случиться фатальный сбой системы (например когда последовательность операций в базе данных выполнена наполовину);
- обрывы сети могут отрезать приложение от СУБД или один узел базы от другого;
- несколько клиентов могут выполнять операции записи в базу одновременно, перезаписывая изменения друг друга;
- клиент может прочитать данные, которые не имеют смысла, поскольку были обновлены только частично другим клиентом;
  и т. п.

Решение. Многие подобные проблемы решаются абстракцией  **транзакций** : благодаря ей приложение больше не обращает внимания на отдельные проблемы конкурентного доступа и большинство классов сбоев аппаратного и программного обеспечения. Широкий класс ошибок сводится к простому прерыванию транзакции, которую далее достаточно просто повторить.

**Транзакция** -- это способ группировки нескольких операций записи и чтения в одну логическую единицу. Все эти операции выполняются как одна: вся транзакция либо целиком выполняется успешно -- **фиксируется** (с фиксацией всех изменений в базе), либо целиком завершается неудачно и **откатывается** (с полным прерыванием своей работы и откатом базы к исходному состоянию до старта транзакции).

*По материалам учебника
**"Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems"**
автор  **Martin Kleppmann** .*


## Транзакции

Проблема 2. Транзакции были созданы именно для упрощения модели программирования, где активно ведётся работа с базами данных. С помощью транзакций приложение может игнорировать определённые сценарии ошибок и проблемы конкурентного доступа: теперь этим занимается СУБД. Говорят, что она предоставляет  **гарантии функциональной безопасности** . Однако какова цена таких гарантий? Подчас она оказывается весьма высока в плане требуемых ресурсов.

Решение. 10-15 лет назад, с ростом популярности нереляционных (NoSQL) баз данных были довольно серьёзно пересмотрены популярные модели данных, технологии репликации и секционирования. В частности, многие NoSQL-СУБД полностью отказались от транзакций, или существенно ослабили набор функциональных гарантий. В результате даже стало популярно мнение, что транзакции вообще мешают масштабируемости, и современной highload-системе лучше от них отказаться -- ради сохранения хорошей производительности и высокой доступности.


## Транзакции

Проблема 3. В то же время по понятным причинам оставался высокий спрос на СУБД, которые способны обеспечить высокие транзакционные функциональные гарантии для серьёзных, критически важных приложений, однако постоянно возникали сложности с полноценной оценкой таких гарантий.

Решение. Гарантии функциональной безопасности, обеспечиваемые транзакциями, задаются тем, что записывается как аббревиатура **ACID** (atomicity, consistency, isolation, durability):  **атомарность, согласованность, изоляция и сохраняемость** .


## ACID

Проблема 4. Как поступать при серьёзном сбое? Например, при фатальном сбое процесса, разрыве сетевого соединения, переполнении диска, нарушении ограничений целостности и т. п., когда клиент выполняет несколько операций записи, но выполнена пока лишь их часть.

Решение. Помогает **атомарность** (буквально -- "невозможность разбиения на меньшие части"). Если операции записи сгруппированы в атомарную транзакцию, и её не удаётся завершить (корректно зафиксировать все изменения) из-за сбоя, то она прерывается, и СУБД отбрасывает (откатывает) все уже выполненные в рамках этой транзакции операции записи.

Атомарность в смысле ACID -- это скорее прерываемость, возможность прервать выполняющуюся транзакцию при внешней ошибке и аккуратно проигнорировать все её операции записи.


## ACID

Проблема 5. Понятие атомарности активно используется и в других областях информатики. Например, если в параллельной системе одна из нитей выполняет атомарную операцию, это означает, что другие нити ни при каких обстоятельствах не смогут увидеть промежуточные результаты этой операции. Система может "дискретно" находиться либо в состоянии, в котором была до атомарной операции, либо в том, в котором она окажется после, но не в каком-то промежуточном.

Решение. **В контексте ACID атомарность не связана с конкурентным доступом** и никак не определяет, что происходит, когда несколько процессов пытаются обратиться к одним и тем же данным одновременно, потому что относится к понятию изоляции в ACID.


## ACID

Проблема 6. Информация, хранящаяся в базе данных, должна быть согласована в смысле "разумности", но как это определить формально?

Решение. Подразумевается, что определенные утверждения относительно данных и взаимосвязей с ними (так называемые  **инварианты** ) внутри БД всегда остаются справедливыми. Например, в системе бухгалтерского учета кредит всегда должен сходиться с дебетом по всем счетам. Если транзакция стартует в справедливом (удовлетворяющем всем инвариантам) состоянии базы данных, и любые производимые во время транзакции операции записи сохраняют эту справедливость, то считаем, что система всегда консистентна. Обратите внимание, что мы требуем, чтобы согласованность сохранялась не только после выполнения транзакции в целом, но и в процессе её работы (с учётом возмоожного отката в будущем) после выполнения каждой её операции записи.


## ACID

Проблема 7. Что именно представляют собой инварианты в системе, как они реализуются -- по большому счёту, обязанность не СУБД. Это более высокий логический уровень; например, если внутри транзакции программист ошибочно записал команду удаления содержимого некоторой важной таблицы, то она нарушит согласованность данных, однако СУБД этого конечно не "понимает". Она способна проверять лишь некоторые специальные виды инвариантов -- через ограничения внешних ключей или ограничения уникальности, но логическая согласованность данных определяется приложением, а СУБД только обеспечивает их хранение и низкоуровневую обработку.

Решение. **Согласованность в смысле ACID** -- единственное из четырёх классических свойств, которое ошибочно относят к базам данных, но его  **правильно относить к свойству приложения** .
