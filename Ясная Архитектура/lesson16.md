### 13. Архитектура на монадах состояний

Допустим, мы хотим организовать пакетную обработку команд роботу в наиболее выразительном и наглядном стиле синтаксически. Тут нам хорошо помогут **монады состояний** -- архитектура на их основе становится значительно прозрачнее.

Мы хотим визуально организовать очевидную цепочку вычислений -- что-то вроде

```
... >> move(100) >> turn(-90) >> set_state(SOAP) >> ...
```

**Монада** -- это тип, который позволяет строить подобные конвейерные цепочки вычислений. Между этими вычислениями передаются только монады, что и делает эти цепочки в некотором смысле универсальными. Традиционная операция шага такой цепочки называется  **bind** . Первый (левый) аргумент этого оператора -- монада, правый -- это функция, которая получает в качестве параметра обычное значение (не монаду), а возвращает снова монаду. То есть мы как бы прогоняем входную монаду через функцию: оператор bind вытаскивает из входной монады обычное значение и передаёт его функции, а потом оборачивает результат функции обратно в выходную монаду.

**Монады состояний** "оборачивают", в отличие от обычных монад (контейнеров значений), не данные, а наоборот -- функции. Причём не все функции, а только такие, которые получают на вход единственный параметр -- состояние (экземпляр любого определённого типа), а выдают список из двух элементов: некий результат своей работы и результирующее состояние. Фактически, совершенно произвольная цепочка обработки входного состояния завершится предсказуемо и однозначно.

Наш набор функций из модуля pure_robot надо теперь обернуть монадами состояний. Здесь есть один принципиальный момент.

Монады состояний выполняют две задачи: непосредственно формируют цепочку вычислений над некими входными данными (немонадическими), и одновременно передают "стейт" -- некий монадический тип, хранящий дополнительную информацию. Например, таким образом удобно организовывать фоновый лог выполняющихся вычислений.
