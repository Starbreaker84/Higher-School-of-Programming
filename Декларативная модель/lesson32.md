### 26. Очереди

Структуру данных "очередь" мы изучали на первом курсе по алгоритмам и структурам данных. Напомню, что очередь работает по принципу FIFO (первый вошёл - первый вышел) и представляет собой список с двумя операциями без дополнительных аргументов. Операция добавления добавляет элемент в хвост очереди, а операция удаления удаляет элемент из её головы (что соответствует работе реальной очереди).

В императивной модели очередь реализуется легко и эффективно с помощью двухсвязного списка, что позволяет выполнять эти две операции за константное время O(1). Однако в декларативной модели у нас нету ни переменных, ни указателей, и если добавление элемента в голову -- это обычно тоже константная по времени операция, то удаление из хвоста приходится реализовывать "вручную", и оно подразумевает сложность O(n).

Поэтому была разработана отдельная достаточно эффективная реализация очереди именно для декларативной модели, обеспечивающая O(1) и для добавления, и для удаления элемента в очереди. Для этого будем использовать две операции (добавление в голову и удаление из головы), которые работают за константное время, в отличие от операций, работающих с хвостом.

В ООП мы естественно представляли очередь как объект (экземпляр класса со скрытой реализацией), но в декларативной модели нам доступны лишь списки и записи. Будем считать очередью запись, состоящую из двух элементов: F и R, где имена F и R связаны со своими значениями-списками. То есть  **очередь -- это структура из пары именованных списков** .

Так как в декларативной модели мы не можем менять значения полей в записи, каждая из операций над очередью (добавление или удаление элемента) всегда создаёт (возвращает в качестве своего значения) новую очередь. Соответственно,  **конкретная очередь в программе сама по себе -- понятие эфемерное** , формально она существует с момента своего создания до момента, когда она больше не используется в программе.

Очередь создаётся например, когда в неё (а на самом деле, в другую будущую, эфемерную очередь) добавляется новый элемент: операция выдаёт новую очередь взамен старой, которая сразу перестаёт существовать. По этой причине нельзя использовать одну и ту же очередь (условную переменную) в качестве входного объекта для нескольких операций.

F хранит список, в котором находится первая часть очереди, и R хранит список, в котором находится вторая часть очереди, перевёрнутая от конца к началу. Зачем? Так как добавление элементов осуществляется в хвост очереди, эта операция требует O(n) для списка, поэтому мы переворачиваем вторую часть очереди (список), чтобы добавлять новый элемент в голову этого списка за O(1), учитывая, что этот хвост весь перевёрнут. Удаление элемента из головы списка F также выполняется за константное время.

Однако как только очередь потребуется целиком где-то в программе, её надо будет представить в виде обычного списка. Для этого необходимо, во-первых, перевернуть список R, и во-вторых, добавить его к списку F: в новой очереди эта композиция запишется в F, а R станет пустым списком. Такая операция, понятно, требует уже совсем не константное время.

Если операции и использование очереди перемешаны (в любой момент может выполниться добавление в хвост, считывание из головы или запрос всей очереди для внешних операций), то средняя эффективность будет явно хуже константной. В то же время, если удастся разделить пакет операций обработки очереди (добавление и удаление элементов) и её внешний запрос в виде списка (а на практике так часто и бывает), то данная конструкция будет работать с эффективностью, близкой к константной, пока список F остаётся не пустым.

Более того, если аккуратно использовать списки различий, можно ещё существенно повысить эффективность такой реализации (когда, например, итоговое сцепление F с перевёрнутым R выполняется за константное время).

### Очереди (задания)

======= 60. Очередь реализуется в декларативной модели ...

[X]за O(1)

[ ]за O(N)

[ ]за O(log N)

======= 61. Очередь в декларативной модели -- это структура из пары именованных списков ...

[ ] где списки не перевёрнуты

[ ] где первый список перевёрнут

[X] где второй список перевёрнут

======= 62. Если операции очереди и её использование перемешаны, то её средняя эффективность будет ...

[ ] явно лучше константной

[X] явно хуже константной

[ ] примерно константной
