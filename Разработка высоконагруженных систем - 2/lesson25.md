### Перебалансировка

Проблема 79. Происходит ли перебалансировка автоматически, или её нужно выполнять вручную?

Автоматизация перебалансировки опасна в частности, если она сочетается с автоматическим обнаружением отказов. Например, один из узлов перегружен и отвечает на запросы слишком медленно. Другие узлы полагают, что перегруженный узел отказал, и автоматически выполняют перебалансировку кластера. В результате появляется дополнительная нагрузка и на этот и так перегруженный узел, и на другие узлы и сеть, что только ухудшает положение дел и потенциально приводит к каскадному сбою.

Решение. Наличие человека в цикле перебалансировки -- хорошая идея. Это медленнее, чем полностью автоматический процесс, однако позволяет предотвратить многие неприятные сюрпризы.


### Перебалансировка

Проблема 80. Откуда клиент, выполняющий запрос, знает, к какому узлу ему нужно подключиться? При перебалансировке распределение секций по узлам меняется. Необходим какой-то "наблюдатель" за изменениями, который может ответить клиенту, по какому IP-адресу и к какому порту ему нужно подключиться, если он хочет прочитать или записать значение для ключа foo.

Решение. Это частный случай более общей задачи, называемой  **"обнаружение сервисов" (service discovery)** , которая относится не только к базам данных.

1. Разрешить клиентам обращаться к любому узлу (например, с помощью циклического балансировщика нагрузки). Если на этом узле случайно окажется секция, которая нужна для ответа на запрос, то он обработает запрос непосредственно, в противном же случае узел сам перенаправит запрос соответствующему узлу, дождётся ответа и вернёт его клиенту.
2. Отправлять все запросы сначала маршрутизирующему звену, которое определяет, какой узел должен обрабатывать данный запрос, и само его переправляет. Это звено не обрабатывает никаких запросов, а лишь учитываюет секции и балансирует нагрузку.
3. Требовать, чтобы клиенты сами учитывали секционирование и распределение секций по узлам. В этом случае посредники не нужны.

### Перебалансировка

Проблема 81. Откуда отвечающий за маршрутизацию компонент (один из узлов, маршрутизирующее звено или клиент) узнает об изменениях в распределении секций по узлам?

Решение. Для отслеживания подобных метаданных кластера используется отдельный сервис координации -- например ZooKeeper. Все узлы регистрируются в сервисе, который поддерживает актуальную карту соответствий секций узлам. Маршрутизирующее звено или учитывающий секции клиент могут подписываться на данную информацию в ZooKeeper.

Cassandra и Riak применяют другой подход: используют для обмена сообщениями между узлами gossip-протокол для распространения всех изменений состояния кластера. Запросы можно отправлять любому узлу, который перенаправит их к узлу с соответствующей секцией. Эта модель усложняет сами узлы, но позволяет избежать зависимости от внешнего сервиса координации наподобие ZooKeeper.


### Параллельное выполнение запросов

Проблема 82. Типичный запрос к хранилищу данных обычно содержит сразу несколько операций соединения, фильтрации, группировки и агрегирования. На практике, во многих задачах аналитики, требуется поддержка гораздо более сложных типов запросов, нежели чтение или запись значения для одного ключа (плюс фрагментированные запросы в случае секционированных вторичных индексов).

Решение. Использовать, например, реляционные СУБД с  **массово-параллельной архитектурой (massively parallel processing, MPP)** . Оптимизатор запросов MPP разбивает сложный запрос на несколько стадий выполнения и секций, и многие из них можно выполнять параллельно в различных узлах кластера. Подобный параллелизм приносит особенную выгоду запросам, для которых требуется просмотр больших частей набора данных.


### Перебалансировка (задания)

======= 68. Как лучше выполнять перебалансировку?

[ ] автоматически

[ 1] вручную

======= 69. Как клиенту узнать, к какому узлу ему нужно подключиться? (выберите неверный вариант)

[ ] клиенты сами учитывают распределение секций по узлам

[ 1] клиенты обращаются к ведущему узлу, а на сервере узлы сами разберутся

[ ] запросы отправляются маршрутизирующему звену

[ ] клиенты могут обращаться к любому узлу, а на сервере узлы сами разберутся

======= 70. Как маршрутизатор узнаёт об изменениях в распределении секций? (выберите неверный вариант)

[ ] использовать выделенный сервис координации

[ ] использовать gossip-протокол для обмена сообщениями между узлами

[1 ] клиенты сами учитывают распределение секций по узлам
