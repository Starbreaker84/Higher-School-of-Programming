### Декомпозиция в ходе проектирования

Довольно принципиальный момент, вызывающий и по сей день множество споров -- применять ли функциональную декомпозицию в ходе проектирования, или декомпозицию типов (например, в виде иерархии классов)? Точнее, в каких случаях какой подход будет более продуктивным?

Пусть имеется АТД, базирующийся на родительском типе T, и имеющий подтипы T1, T2, T3 и набор операций F1,...,Fn. Как лучше его организовать в программе?

В декларативной парадигме мы конструируем функции, следуя определениям типов. В ООП мы конструируем иерархии типов, тоже по сути следуя определениям типов.

Однако в результате мы получаем программы, сильно различающиеся по структуре -- будем называть эти структуры результатом функциональной декомпозиции, или декомпозиции типов.

В **функциональной декомпозиции** каждое определение функции целостно само по себе, но сами типы "размазаны" по всем функциям. В **декомпозиции типов** каждое определение типа целостно само по себе, но сами функции "размазаны" по всем типам. Что выбрать?

При функциональной декомпозиции можно изменить существующую функцию или добавить новую функцию без изменения определений других функций. Однако изменение существующего типа или добавление нового типа потребует изменения всех или большинства определений функций.

При декомпозиции типов можно изменить существующий тип (класс), или добавить новый тип (например, с помощью наследования) без изменения других определений типов. Однако изменение существующей функции или добавление новой функции потребует изменения определений всех или большинства классов.

Перед разработкой программы полезно спросить себя, какой вариант из этих двух выглядит наиболее подходящим. Если система типов в программе относительно проста, и подразумевается большое количество операций над типами, то лучше выбрать функциональную декомпозицию.

Если же система типов сложная (напрашивается иерархия), и с относительно небольшим количеством операций, то подход через декомпозицию типов может быть более ясным.


### Правильно ли считать всё объектом? Сильные объекты.

Сторонники ООП часто провозглашают принцип "всё должно быть объектом", однако обычно без точного определения, что именно он должен означать.

Разумно определить этот принцип так:  **"все языковые сущности должны быть экземплярами АТД с (по возможности) максимально общими свойствами"** .
В своей крайней форме он подразумевает пять характеристик:

- все языковые сущности должны задаваться классами;
- все языковые сущности должны быть расширяемыми с помощью наследования;
- все языковые сущности должны уникально идентифицироваться;
- все языковые сущности должны инкапсулировать состояние;
- доступ ко всем языковым сущностям должен осуществляться с помощью единого синтаксиса.

Иногда для определения сущностей со всеми этими свойствами используется слово "объект". Чтобы избежать путаницы, будем называть их  **сильные объекты** .

**Объектно-ориентированный язык называется чистым (pure), если все его сущности -- сильные объекты** .

Стремление к чистоте языка даёт ряд полезных вещей. Например, во многих языках есть понятие "исключения" для обработки аномальных событий во время выполнения, и будет очень удобно, если исключения оказываются объектами в иерархии наследования. Это позволяет легко классифицировать их по различным категориям, ловить их, только если они относятся к определенному классу (или его подклассам), и, возможно, изменять их (добавлять информацию), если они поддерживают состояние.


Практически не существует пока популярных языков, в которых бы все сущности были сильными объектами. Например, целые числа в Java (не Integer, а int) -- это чистые значения; они не определены классом и не инкапсулируют состояние. Объект в Java может иметь атрибуты с характеристикой final, что не позволяет их изменять и означает, что объект не имеет состояния. Массив в Java не может быть расширен с помощью наследования, а сами они ведут себя так, как если бы они были определены с final, и т. д.

Но должен ли язык (или система типов в проекте) вообще поддерживать только сильные объекты? Ответ -- нет, по многим причинам.

Во-первых, важную роль могут играть объекты без состояния -- с ними становятся возможны мощные методы из декларативного программирования. Именно по этой причине многие языки допускают их использование. Кроме того, сущности без состояния необходимы для того, чтобы сделать прозрачным проектирование распределенных систем.

Во-вторых, не все сущности нуждаются в уникальной идентичности. Например, явно структурированные сущности (кортежи в базе данных) идентифицируются по их содержимому, а не по именам.

В-третьих, вроде бы напрашивающаяся простота единообразного синтаксиса в случае сильных объектов оказывается на практике иллюзорной.

В итоге у нас остались две характеристики из пяти:

- все сущности языка должны быть экземплярами АТД, и
- синтаксическое единообразие при работе с АТД должно использоваться, когда это целесообразно.
  Одни АТД будут обладать всеми свойствами сильных объектов; другие -- только некоторыми из этих свойств, но также и некоторыми другими, совершенно отличными свойствами. Эта схема хорошо согласуется с использованием множественных моделей вычислений, пропагандируемых на данных курсах.

**Правильное проектирование системы заключается, прежде всего, в разработке абстракций и их реализации в виде АТД** .


### Сильные объекты и чистый объектно-ориентированный язык

======= 33. Когда лучше выбрать декомпозицию типов, а не функциональную декомпозицию?

[1] Если система типов в проекте сложная, напрашивается иерархия

[ ] Если количество операций над типами велико

======= 34. Выберите лишнюю характеристику сильного объекта

[0 ] доступ ко всем сущностям осуществляется единым синтаксисом

[ 1] все языковые сущности должны поддерживать полиморфизм

[ 0] все языковые сущности должны расширяться через наследование

[ 0] все языковые сущности должны инкапсулировать состояние

[0 ] все языковые сущности должны задаваться классами

[0 ] все языковые сущности должны уникально идентифицироваться

======= 35. Какая из двух ключевых характеристик сильного объекта для применения на практике, в данном списке лишняя?

[ ] синтаксическое единообразие при работе с АТД

[ ] все сущности языка должны быть экземплярами АТД

[ 1] все сущности должны задаваться классами
