### Тестовое покрытие

Всегда полезно и нужно иметь тесты, окружающие участки кода, где вносятся изменения (если это возможно, конечно).

7. Проблема. Практически все затруднения, связанные с покрытием кода тестами, связаны с нежелательными зависимостями между различными частями этого кода. Разрывание зависимостей -- одна из самых сложных проблем в разработке программного обеспечения, и к сожалению,  **большая часть унаследованного кода требует разрыва множества зависимостей** , иначе изменение такого кода будет крайне сложным.
   Например, если в клиентском или автономном настольном, мобильном, веб-приложении используется графический пользовательский интерфейс (а это сегодня не менее 90% приложений), к этому UI, очевидно, не существует программного интерфейса, вся логика завязана непосредственно на взаимодействие конечного пользователя с экземплярами классов UI. И что же тогда нам с этим делать?

**Дилемма унаследованного кода** . При внесении изменений в код нужны покрывающие его тесты. Но при подготовке таких тестов зачастую приходится изменять сам тестируемый код (например, когда в процессе создания таких тестов обнаруживаются новые ошибки).

Решение. Прежде всего необходимо начать с разрывания зависимостей между разными частями кода, и затем выполнить связанные с этим практики, которые разбираются далее. Когда мы разрываем зависимости, то зачастую получаем возможность полноценно писать тесты, делающие радикальные изменения более безопасными.

Главное, чтобы начальные виды реорганизации кода делались весьма осторожно, и в целом, конечно, гарантированно безопасной методики не существует, риск ухудшить ситуацию и запутаться ещё больше остаётся всегда. В таких ситуациях, кстати, нередко даже приходится жертвовать эстетичностью кода во имя надёжности.

### Общий алгоритм изменения унаследованного кода

1. **Определение точек изменения** .
   Места, где требуется внести изменения, напрямую зависят от задачи, архитектуры и дизайна конкретной системы.
2. **Нахождение тестовых точек** .
   Иногда нетрудно найти соответствующие изменениям области в коде для покрытия их тестами, но в унаследованном коде это как правило оказывается достаточно сложно.
3. **Разрывание зависимостей** .
   Это ключевой момент в алгоритме.  **Зависимости -- самая очевидная помеха для тестирования** , причём сложности возникают как при формировании объектов для тестирования, так и при непосредственном тестировании. В идеальном случае удаётся покрыть тестами всё вокруг точки разрыва, но чаще всего такая возможность отсутствует.
4. **Написание тестов** .
   Написание тестов для безопасного изменения унаследованного кода несколько отличается от их написания при добавлении нового кода.
5. **Внесение итоговых изменений** и, при необходимости, реорганизация/рефакторинг кода. Рекомендую для этого разработку через тестирование (TDD) для добавления новых фич в унаследованный код (на курсе карьеры есть вводное занятие по TDD).

### Тестовое покрытие

8. Проблема. Чтобы протестировать класс, вроде бы ничего особенного не нужно: создаём экземпляры этого класса и пишем тесты с использованием объектов. Однако на практике формирование конкретных групп объектов для тестирования существенно затрудняется из-за запутанных зависимостей между классами. При создании объекта нужного класса ему часто требуются объекты другого класса, а для них в свою очередь объекты ещё одного класса и т. д., и в итоге в тестирование оказывается втянутой едва ли не вся система.

Или, например, некоторый класс может обращаться к реальной сетевой аппаратуре. Требуется ли она при тестировании экземпляра данного класса? Как нам узнать, что именно делает сетевая аппаратура, какой отклик возвращает? Ведь с точки зрения разбирающегося в легаси-коде класс -- это закрытый чёрный ящик.

Решение. В большинстве случаев удаётся обойтись таким разрывом зависимостей, который просто даёт доступ различными способами к исходно инкапсулированным значениям. Однако подчас приходится заниматься этим и в более сложных случаях, когда не удаётся "поместить" в среду тестирования даже фрагмент кода, настолько он завязан на своё окружение.


### Имитация взаимодействующих объектов

Как минимум, если мы можем подменить код в некотором интересующем нас месте на другой, и затем протестировать его, значит, потенциальная возможность написать тесты имеется. В случае ООП мы обычно можем подменить класс и создать так называемый **фиктивный объект** с помощью наследования, либо использовать препроцессор для явной замены кода.

9. Проблема. Применение фиктивных объектов выглядит как ненастоящее тестирование -- оно не показывает реальный результат, не работает с реальной аппаратурой например.

Решение. Это так, но из этого совсем не следует, что такой тест ненастоящий. Когда мы пишем тесты, то должны действовать по принципу "разделяй и властвуй". Подобный тест просто проверяет, каким именно образом объекты соответствующего класса взаимодействуют с сетевой аппаратурой как с внешней сущностью, и со своим окружением. Вполне возможно, что мы обнаружим программную ошибку в логике работы нашего класса как "клиента" сетевой аппаратуры, и хотя подобный тест будет вспомогательным средством, мы без сомнения можем повысить качество системы и сэкономить немало времени.

Более того, всегда, когда мы пишем тесты для отдельных структурных единиц, то в конечном счете получаем небольшие вполне понятные фрагменты кода и тесты как его полуформальные спецификации, что облегчает осмысление всего кода в целом.


### Имитация взаимодействующих объектов

10. Проблема. Оригинальный класс подменить или наследовать получается не всегда, или же таких классов, требующих подмены, много, и работа по их замене получается слишком объёмной. Тогда применяют другой известный способ --  **имитирующие объекты (mocks)** , которые программно эмулируют, например, устройство, на которое завязан тестируемый класс.

В случае, когда работы получается немного по подмене самих тестируемых классов, используем фиктивные объекты.

В случае, когда работы получается немного по эмуляции сущностей, внешних по отношению к тестируемым классам, используем имитирующие объекты.


### Тестовое покрытие и разрывы зависимостей (задания)

======= 10. С чего начинается правильное внесение изменений в легаси-код?

[1 ] с разрыва зависимостей

[ ] с покрытия тестами изменяемого участка кода

[ ] с рефакторинга

======= 11. Какой пункт в последовательности приёмов разрыва зависимостей лишний?

[ 1] организация доступа к инкапсулированным значениям

[ ] создание фиктивных объектов

[1 ] рефакторинг

[ ] имитация взаимодействующих объектов

======= 12. Как вы думаете, существуют ли хорошие общедоступные библиотеки с набором готовых mock-объектов для многих типичных ситуаций?

[ ] нет, как минимум общедоступные не найти

[1] да, существуют хорошие
