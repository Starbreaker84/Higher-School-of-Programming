### Декларативная параллельная модель, управляемая данными

Почему параллельная модель, управляемая данными (добавлены нити) - это форма декларативного программирования? Потому что
основной принцип декларативного программирования заключается в том, что  **результат работы (выход) декларативной
программы должен быть математической функцией от её входа** . В функциональном программировании это наглядно и понятно:
программа выполняется, получая некоторые входные значения, а когда завершается, то возвращает некоторые выходные
значения. Выходные значения являются функциями входных значений. Но что это означает в параллельной модели, управляемой
данными?

Тут имеются два важных отличия от функционального программирования. Во-первых, входы и выходы не обязательно являются
полноценными значениями -- они вполне могут содержать несвязанные переменные. Во-вторых, выполнение может вообще никогда
не заканчиваться, так как входные данные могут быть потоками, которые бесконечно растут!

### Частичное прекращение

В первом случае периодически может возникать так называемое **частичное прекращение (partial termination)** работы
программы.

Например, имеется рекурсивная функция Double, которая получает на вход список, внутри разбирает его по изученному
шаблону (голова-значение и хвост-список), удваивает значение головы, и возвращает список из пары "удвоенное значение"
+ "рекурсивный вызов Double для хвоста списка". Double фактически возвращает список, каждый элемент которого увеличен в
два раза.

В параллельной модели однако подразумевается такая схема, что пока в потенциально бесконечном входном списке (аргументе
Double) имеются значения, Double тут же формирует результат, выдавая очередное значение в хвост списка-результата. А
если во входном списке встречается несвязанная сущность, возникает частичное прекращение: функция Double просто ждёт (
возможно, бесконечно долго), когда соответствующая связь выполнится.

Что будет на выходе функции, которая находится в состоянии частичного прекращения? Например, на входе список
Xs=1|2|3|Xr (Xr - несвязанная переменная), и при вызове

```
Ys = Double Xs 
```

будет получен результат Ys=2|4|6|Yr, где Yr - несвязанная переменная.

### Логическая эквивалентность

Давайте разберёмся, как в декларативной вычислительной модели реализована так называемая  **логическая эквивалентность**
.

Например, есть две программы:

```
X = 1
Y = X
```

и

```
Y = X
X = 1
```

В первом случае в хранилище однократных присваиваний окажутся значения X = 1 и Y = X (Y -- это алиас). Во втором случае
ситуация качественно иная: X = 1 и Y = 1. Но с точки зрения программиста, в обоих случаях и X и Y "содержат" значение 1.

При выполнении параллельной декларативной программы, если например "X = 1" и "Y = X" разнесены по разным нитям, возможны
две вышеописанные последовательности их выполнения. Ключевой момент тут в том, что итоговый результат будет "одним и тем
же", однако "один и тот же" совсем не значит, что каждая переменная будет связана одной и той же формой.

**"один и тот же" означает только логическую эквивалентность результата** .

### Логическая эквивалентность

Параллельная программа считается декларативной, если для всех возможных её входов истинно следующее:
все возможные варианты выполнения программы с некоторым множеством входных значений приводят к одному из двух
результатов:

1) все они не завершаются, или
2) все они в конечном итоге достигают частичного завершения и выдают логически эквивалентные результаты.

Другой способ выразить это -- понять, что  **наличествует отсутствие наблюдаемого недетерминизма** . Это определение
справедливо как для жадного, так и для ленивого выполнения. Более того, в недекларативных моделях (например, с
добавлением исключений или явного состояния) это определение используется в качестве основного критерия: если часть
недекларативной программы подчиняется этому определению, мы можем считать её декларативной.

Существуют и более общие декларативные модели: например, параллельная модель, управляемая запросами. Она довольно
универсальна: поддерживает нити и как жадное, так и ленивое выполнение (тот факт, что что она при этом декларативна,
поразителен).

### 4. Недетерминизм и планирование

======= 9. Выполнение считается недетерминированным, если ... (выберите неверное утверждение)

[ ] возникает выбор "что делать дальше"

[ ] возникает выбор, какую нить продолжить

[1] возникает выбор, какой шаг выполнения продолжить

======= 10. В декларативной параллельной модели недетерминизм не наблюдаем, так как ... (выберите неверное утверждение)

[ ] dataflow-переменные могут связываться только с одним значением

[ 1] любая операция выбирает, ждать или нет связывания

[ ] любая операция всегда ждёт, когда нужная переменная будет связана

======= 11. Планировщик считается справедливым, если ...

[ ] он не позволяет ни одной готовой нити никогда простаивать

[ ] он учитывает, что выполнение одной нити зависит от выполнения какой-либо другой нити

[ 1] он не позволяет ни одной готовой нити долго простаивать
