### Диаграммы классов

В 1990-е и начало 2000-х получила большую популярность **концепция визуального моделирования** -- представление иерархий классов в виде диаграмм. Был, в частности, разработан так называемый  **универсальный язык моделирования UML** , реализовывалось множество попыток создания визуальной модели предметной области на UML, и затем её отображение в программный код, однако ни одна из них так и не завоевала даже небольшой популярности. Причин этому три:

- UML не определяет функциональность класса. Например, если методы поддерживают некоторый инвариант, то этот инвариант не отображается на диаграммах;
- UML не умеет моделировать (или делает это очень слабо) динамическое поведение, эволюцию программы во времени. Для разных фаз работы программы обычно требуются разные диаграммы. Приложения часто работают параллельно, независимыми частями, которые взаимодействуют некоторыми согласованными способами, которые нужно тоже наглядно представлять;
- UML моделирует только один уровень в иерархии компонентов системы.

Подход UML частично признаёт эти ограничения и предоставляет инструменты, которые как-то облегчают их: например, есть диаграммы взаимодействия для динамического поведения и диаграммы пакетов для иерархии. Но на практике в итоге процесс моделирования оказывается весьма сложным, подразумевается довольно высокий порог входа, а итоговый выигрыш слабо понятен.

### Паттерны проектирования

При разработке программных систем часто приходится сталкиваться с одними и теми же проблемами снова и снова. Причина этого, скорее всего, в том, что люди, обучающиеся схожими способами, делают схожие ошибки. Подход, основанный на паттернах проектирования, явно это декларирует и предлагает "шаблонные" решения.

Паттерн проектирования -- это инженерная техника, которая решает одну из общих типовых проблем. Данный цикл курсов "как понять в программировании всё" в некотором смысле полон таких паттернов проектирования, только они формировались в основном научным подходом, а не обобщением типовых ошибок проектирования. Например, в декларативном программировании это правило "конструировать программу, следуя типу (рекурсивной структуре данных)", а при создании защищённых АТД использовался паттерн "обертывание функциональности в безопасный слой", который применим к любому АТД.

Впервые паттерны проектирования были популяризированы в известной книге **"Design Patterns: Elements of Reusable Object-Oriented Software" ("Приемы объектно-ориентированного проектирования. Паттерны проектирования")** от Банды четырёх (Гамма, Хелм, Джонсон, Влиссидес), в которой предлагается каталог паттернов проектирования в ООП и объясняется, как их использовать. В каталоге приводятся паттерны, основанные на наследовании.

Давайте рассмотрим типичный паттерн проектирования с точки зрения программиста, который думает в терминах моделей вычислений.

Классический паттерн **Компоновщик (Composite)** предназначен для формирования иерархии объектов. Пусть имеется некоторая иерархия объектов, которые могут быть вложены друг в друга: например, графическая фигура, которая может представлять собой либо конкретную фигуру, либо контейнер графических фигур. В теме множественного наследования предлагался вариант, когда графическая фигура наследуется одновременно от абстрактной фигуры и от списка. Паттерн Компоновщик предлагает более абстрактный подход: иерархия строится из компонентов, поддерживающих интерфейс Компоновщика (операции add и remove и некоторая универсальная execute), которые в свою очередь могут быть либо конкретным объектом, либо контейнером, содержащим дочерние компоненты с этим же интерфейсом. Внутренняя реализация Компоновщика может использовать произвольные подходящие структуры данных.

Потребность в паттернах наподобие Компоновщика возникает прежде всего потому, что в популярных языках отсутствует возможность использования классов как значений, иначе, получив на вход класс, функция компоновки могла бы вернуть новый класс, расширенный указанным интерфейсом. Но и тут есть ограничения, так как даже в случае поддержки классов как значений функция компоновки должна вернуть суперкласс (класс-родитель) для заданного класса, а на практике реализации такого программирования высшего порядка позволяют создавать лишь класс-потомок (так как новый класс-родитель должен аккуратно вписаться в вышестоящую иерархию, которая в общем случае неизвестна).

Подобную двойственность в отношении паттернов проектирования как, по большому счёту, вынужденных приляпок из-за фундаментальных ограничений конкретного языка программирования, предлагается решать так:  **рассматриваем эти паттерны в первую очередь как способ инженерного мышления** ; совершенно не обязательно, чтобы они нативно поддерживались в языке программирования. Конструкции паттернов легко реализуются во всех популярных языках (Java, C#, Python, C++, PHP, JavaScript...), и хотя они не поддерживаются в них как полноценные встроенные абстракции, их несложно внедрить, например, с помощью препроцессора или системы макросов.


### Диаграммы и паттерны

======= 27. В чём слаб универсальный язык моделирования UML? (выберите ложное утверждение)

[ ] UML плохо моделирует функциональность класса

[ ] UML плохо моделирует динамическое поведение

[ 1] UML плохо моделирует структуру класса

======= 28. Паттерн проектирования -- это ...

[ 1] инженерная техника, решающая типовую проблему

[ ] абстракция наследования

[ ] декларативная техника конструирования программы

======= 29. Паттерн проектирования -- это ...

[ ] использование классов как значений

[ 1] способ инженерного мышления

[ ] синтаксический сахар
