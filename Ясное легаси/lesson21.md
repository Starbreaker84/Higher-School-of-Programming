### Легаси-код написан на "старом" процедурном языке

63. Проблема. Легаси-система написана на процедурном языке (например, Си), и в отличие от ООП и функционального программирования, в таком случае появление швов в программах подчас просто невозможно (код очень монолитен). Даже если сам код написан аккуратно, и зависимости корректно учитываются, проект всё равно получается настолько запутанным, что даже его постепенное изменение и покрытие тестами становится весьма затруднительным.

Решение. Cначала организуем тестирование крупного фрагмента кода, внутри которого где-то планируются изменения, и затем используем эти тесты, по возможности постепенно их детализируя, для получения обратной связи в процессе дальнейшей разработки.

Сперва находим точку сужения (место в коде, где можно написать тесты, которые покроют сразу обширное множество изменений), а затем используем например компоновочный шов (и/или шов предварительной обработки, если в языке имеется макропрепроцессор), чтобы включить нужный код в процесс тестирования.


### Легаси-код написан на "старом" процедурном языке

64. Проблема. В некоторых случаях оказывается, что код делает нечто такое, что выходит за рамки компетенции как самой программы, так и разработчика/тестировщика. Его просто необходимо модифицировать.

Решение. Унаследованный процедурный код всегда лучше расширять добавлением новых функций, а не модификацией уже существующих. Как минимум, для новых функций можно написать тесты. А чтобы не усложнять уже наличествующий легаси-код, придерживайтесь методики TDD. Следуйте конечно рекомендациям прежде всего декларативной модели из цикла "как понять в программировании всё", и очень посоветую также в развитие темы в СильныхИдеях материал "Как проектировать программы in small" (выжимка и развитие идей легендарной книги "Ho to design programs?").


### Легаси-код написан на "старом" процедурном языке

65. Проблема. Легаси-система неплохо написана в императивной модели, но её выразительности для дальнейшего развития явно недстаёт.

Решение. Проверьте, возможно, в языке этой легаси-системы сегодня уже поддерживается ООП, или например, его своеобразный (и потенциально даже более мощный) аналог [multiple dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch).

Например, код на Си потенциально можно вполне аккуратно переносить на С++.

ООП предлагает гибкие удобные объектные швы, которые легко выявляются в коде и позволяют наглядно декомпозировать код на более мелкие и понятные фрагменты, что полезно отнюдь не только для тестирования.

Как правило, первый шаг в этом направлении подразумевает инкапсуляцию глобальных ссылок для получения независимых фрагментов кода.

К тому же, аккуратно созданные модули (интерфейс и реализация) сами по себе фактически уже готовые объекты: реализация и локальные переменные инкапсулированы внутри модуля, а доступные внешние функции представляют собой операции надо некоторой структурой данных (представленной модулем).


### Легаси-код написан на "старом" процедурном языке (задания)

======= 56. Легаси-система написана монолитно на процедурном языке.

[ ] надо начинать с юнит-тестов

[ ] надо начинать с выявления швов

[ 1] надо начинать с интеграционных тестов

[ ] надо начинать с тестирования чёрным ящиком

======= 57. Легаси-код таков, что его просто необходимо модифицировать.

[ ] аккуратно модифицируем существующие функции

[ 1] добавляем новые функции

======= 58. Легаси-системе недостаёт выразительности.

[ ] аккуратно модифицируем существующие функции

[ ] по возможности переходим на multiple dispatch

[ 1] по возможности переходим на ООП
