### В легаси-системе полно слишком крупных классов

66. Проблема. В легаси-системе нередко встречаются крупные классы, дальнейшее развитие которых нежелательно.

Решение. Следуем принципу единственной ответственности SRP. Пройдите в этой связи мини-курс "Быстрая прокачка в ООП", где предлагается 9 формальных правил организации кода, следуя которым, вы естественным образом получите систему, отвечающую SOLID и, в частности, SRP.

Очевидные способы тут -- создание классов-наследников, или переопределение методов.

В самой простой интерпретации придерживайтесь принципа SRP так:  **у каждого класса должен быть только один публичный метод** .


### В легаси-системе полно слишком крупных классов

67. Проблема. Напрашивающееся возражение -- у меня есть класс Dwarf, который может выполнять десятки разнообразных активностей, или, совсем просто, класс Котик, который может бегать, спать, кушать, мурлыкать, и каждая эта активность прямо напрашивается отдельным публичным методом в классе. Как быть?

Решение. Активности сами по себе можно представить отдельной иерархией классов. Dwarf оснащается отдельным полем -- самостоятельная структура (тип) данных "список активностей" со своим набором операций (пройдите в частности мини-курс "Быстрая прокачка в ООП").


### В легаси-системе полно слишком крупных классов

68. Проблема. В легаси-коде немало классов, у которых куча самых разных по смыслу методов, что с ними делать?

Решение. Пройдитесь по структуре классов, и спрашивайте по каждому методу: почему он находится здесь, что он вообще делает в данном классе? Постарайтесь сгруппировать некоторые методы (например, явно схожие по именам и, возможно, по назначению), объединив их в один.

Уделяйте особое внимание непубличным методам. Если их много в некотором классе, то это обычно верный признак того, что из данного класса можно отпочковать новый класс (самостоятельную структуру данных) со своим уникальным предназначением.

Пересмотрите взаимосвязи между полями классов и методами. Имеются ли такие атрибуты, которые используются в одних методах и не используются в других? Это как правило признак плохо спроектированного класса.

Попробуйте описать одним предложением возлагаемую на класс ответственность, и затем представить её ровно одним публичным методом.


### В легаси-системе полно слишком крупных классов

69. Проблема. Иногда SRP обвиняют в том, что он провоцирует создание слишком большого числа мелких классов. В результате для получения доступа к некоторому "глубинному" полю по цепочке вложенных атрибутов приходится вызывать длинную цепочку геттеров, каждый из которых представляет всего лишь вызов геттера для одного из своих полей.

Решение. В общем случае необходимость обращения к более чем одному промежуточному геттеру -- признак плохого проектирования системы классов в целом. Глубину композиции, как и глубину наследования, на практике желательно ограничивать двумя, максимум тремя уровнями.

В некоторых случаях хорошо помогает паттерн Синглтон: например, если в большой и сложной игре главный герой заведомо один, то вполне логично будет как раз не описывать его в виде одного класса, в который понапиханы самые разные по смыслу сущности, а выделить каждую такую сущность (например, инвентарь, список слотов тела, набор скиллов...) в свой отдельный класс (статический или синглтон). Если же героев много, то надо подумать, как ограничить количество геройских атрибутов двумя-тремя (например, инвентарь и скиллы). Но исходить всегда надо в первую очередь из общесистемной логики: какие конкретно операции от каждого класса будут требоваться для обеспечения работоспособности системы в целом, какие интерфейсы востребованы?


### В легаси-системе полно слишком крупных классов (задания)

======= 59. Общий подход приведения крупных классов к принципу SRP -- это ..

[ ] переопределение методов

[ ] создание классов-наследников

[1 ] у класса должен быть только один публичный метод

======= 60. Если в классе много приватных методов ...

[ ] можно выделить атрибуты, которые используются не во всех методах

[ ] можно сгруппировать такие методы по назначению

[1 ] из такого класса можно выделить новый класс
