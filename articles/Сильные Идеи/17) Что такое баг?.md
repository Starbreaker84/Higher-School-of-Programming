## Что такое баг?

*По материалам [Hillel Wayne](https://www.hillelwayne.com/) ("Practical TLA+")*

---

Простой пример: в проект добавлен класс Rect (прямоугольник).

```
class Rect():
    def __init__(self, l, w):
        self.l = l
        self.w = w

    @property
    def l(self):
        return self._l

    @property
    def w(self):
        return self._w

    @l.setter
    def l(self, _l):
        self._l = _l

    @w.setter
    def w(self, _w):
        self._w = _w
```

И затем программисты понаписали в разных местах проекта вызовы некоторого API, где используются объекты-прямоугольники (их длины и ширины).

```
def complicated_api_call(r: Rect):
   api.one(r.l, r.w, more_params)
   api.two(r.l, r.w, ...)
   api.tre(r.l, r.w, ...)
```


## Что такое баг?

Однако через некоторое время обнаруживается, что разработчики совершенно неправильно поняли интерфейс API (очень частая ситуация, сам не раз сталкивался). Хотя предполагалось, что порядок параметров в вызове функций API -- длина и ширина, на самом деле порядок параметров должен быть ширина и длина. Это ошибка, которую обычно исправляют, изменяя аргументы во всех вызовах API (а их возможно уже десятки, или сотни, или тысячи...).

Или мы можем поступить тупо так: просто подменить обращение в сеттерах к ширине на длину, и наоборот. Тоже кстати нередкий случай, причём обычно он случается под давлением менеджеров -- нету времени аккуратно править тысячи вызовов, давайте вот такую приляпку быстренько зафичагим, и когда-нибудь "потом" обязательно отрефакторим как правильно.

```
    @l.setter
    def l(self, _l):
-      self._l = _l
+      self._w = _l

    @w.setter
    def w(self, _w):
-      self._w = _w
+      self._l = _w
```

Однако в результате ситуация лишь резко ухудшилась:
-- теперь любой вызов API, в котором явно подразумевается порядок "длина и ширина", будет ошибочным, а программист, написавший такой код, даже не подозревает об этом, потому что по сигнатуре вызова он сделал всё верно;
-- геттеры получения длины и ширины в результате стали работать ошибочно -- а они возможно используются в проекте за пределами вызовов API.


## Что такое баг?

Ok, после горячего фикса сеттеров подобной приляпкой менеджеры пообщались с тимлидом, и договорились о таком рефакторинге: везде, где сейчас используются сеттеры, вместо них будем сразу конструировать Rect параметрами в конструкторе, чтобы избежать обращения к изменённым сеттерам; геттеры тогда выдадут для такого "Rect без сеттеров" корректные значения. Ну, при условии, если в конструкторе впоследствии тоже не возникнет путаницы с длиной и шириной...

В итоге первоначальная ошибка была "исправлена", а нового неправильного поведения пока не появилось (согласно тестам). Но не будет такое ли "исправление" всё ещё ошибкой?

Интуитивно, да, ошибка всё ещё сохраняется, потому что почему сеттер длины изменяет ширину. Однако системный подход рекомендует думать об ошибках в духе "система не делает правильных вещей" -- но в данном случае она делает всё верно. Ни одно из наблюдаемых существующих поведений не выглядит неправильным, потому что мы не используем его ни в каких случаях, где оно стало бы неправильным.

Поэтому нам нужно расширить определение "ошибки", когда мы точно знаем, что это ошибка, но не можем внятно объяснить стороннему наблюдателю, почему это есть ошибка (за исключением наших словесных рационализаций).


## Что такое баг?

Wayne тут предлагает, как и подобает его статусу, достаточно формальный инженерный подход.

**1. Это не баг.**

Хотя это выглядит как баг, это не баг. В конце концов, система ведь ведёт себя так, как и ожидалось.

Очевидно, это довольно глупый аргумент, но, опять же, мы взяли маленький пример. Если бы все вызовы API выполнялись со старых клиентов, код которых мы уже не контролируем, то введение такого "исправления" будет видимо наименее плохим вариантом. Нередко оказывается, что правильно исправить ошибку гораздо сложнее, чем поставить заплатку (и пусть даже совсем кривую приляпку). Только не используйте это пожалуйста как оправдание для подобной практики.


## Что такое баг?

**2. Это не баг (а что-то другое)**

Это не ошибка, а какая-то другая плохая вещь в проекте. Например, стилистически плохой код и антипаттерны -- это не баги, но все равно это плохо. Может быть, "технический долг"? К сожалению, технический долг выглядит слишком мягким термином. Данная ситуация столь явно кричит "баг", что желательно, чтобы он им и был.


## Что такое баг?

**3. Это сбивает людей с толку**

Любой нормальный разработчик, который посмотрит на такой код, скажет, что это неправильно. Такие моменты существенно усложняют понимание для новых разработчиков, которым приходится осваивать странную конвенцию "использовать длину, когда подразумевается ширина". Это всегда чревато ошибками. А если таких моментов в проекте будут десятки? Их невозможно всегда держать в голове.

Данный пункт означает, что ошибки связаны не только с поведением программы. Ошибка может быть чем-то таким, что сбивает с толку программиста. Это своеобразный "софт как артефакт", когда мы рассматриваем кодовую базу как объект, отличный от его цели. Ошибка относится к сущности, а не к цели её работы. Код как сущность содержит ошибку, но его цель (нормальное исполнение) достигается успешно (пока).

Однако будет ли любой источник подобной путаницы ошибкой? Скорее всего, нет. Много путаницы возникает "естественно" -- просто в сложных по своей природе областях. Вероятно, надо распознавать разные типы путаницы.


## Что такое баг?

**4. Это хрупкость**

В принципе, в других материалах в Сильных Идеях я это уже подчёркивал не раз, и вот синхронизм с очередным гуру: нельзя думать о программе статически -- как о "срезе" на некоторый момент, обязательно надо обдумывать её в динамике, на перспективу. Как этот код будет развиваться дальше, насколько будет сохраняться его лёгкое понимание и безошибочность?

Программы изменяются. Хотя сейчас ошибка ни на что не влияет, она, скорее всего, сработает, когда мы добавим новые функции. Это настолько очевидный риск, что мы должны просто исправить его как следует должным образом.

Таким образом, ошибка "латентна". Она не влияет на текущее поведение системы, но намерена испортить будущее поведение. В рамках работы с формальными методами выявлено множество примеров, когда например типичная проблемная ситуация параллельной "конкуренции" встречается в системах постоянно, однако долгое время не вызывает проблем (буквально годы), пока не вылезет, как правило, в самый неподходящий момент.

Одна из версий хрупкости: ошибка не нарушает ничего из того, что мы наблюдаем, но вызывает проблемы в тех местах, которые мы не наблюдаем. Тоже частый пример -- кривая работа клиентского API, который с точки зрения бэкенда работает вроде бы нормально, однако на фронтенде приходится городить кучу приляпок.

## Что такое баг?

**5. Не соответствует требованиям OSHA (Администрация по охране и гигиене труда США)**

Комбинация двух предыдущих пунктов. Новый программист приходит на работу, видит этот ужасный код, пишет "исправление", и ломает продакшен. Виноват в этом код, который побуждает нормальных людей делать что-то опасное. Фактически, он мотивирует их к этому.


## Что такое баг?

**Неустойчивое равновесие**

Все эти пункты объединяет одно общее: код "неустойчив". Он решает проблему здесь и сейчас, но существует слишком много путей, которыми он проявит негативный эффект в будущем. Наша инженерная интуиция буквально кричит, что это, очевидно, сломано в принципе, даже если это не сломано (пока) на практике. Множество историй и мемов, когда программисты просят выделить время на рефакторинг, но менеджеры категорически против, так как им совершенно непонятно, что конкретно в виде проектных фич это даст. Но у нас уже есть богатый опыт, как развиваются программные системы, и мы нередко видим немало печальных вариантов в будущем, когда всё сломается.

Но можно ли считать "ошибкой" то, что вызывает подобное чувство? В целом нет, многие решения приводят к будущим фейлам, но это может быть как низкокачественный код, так и проблемы с фреймворком или библиотеками, или плохие требования, или ещё что-то в этом роде. Может быть, дело в уровне риска? Однако абсолютно большая часть "опасного" кода приводит к сбоям лишь в некоторых ситуациях будущего, а вот явно ошибочный код приводит к фейлам в будущем почти всегда.


## Что такое баг?

Однако исправление ошибки само по себе также достаточно рискованно (подробно разбираем эту тему на Ясном Легаси). Если вы решите подправить все вызовы API на правильный порядок длины-ширины, то имеется весьма высокая вероятность, что какой-нибудь вызов вы пропустите, и получите в итоге очень странные результаты, которые крайне сложно отлаживать. К сожалению, на практике "исправить ошибку" означает перевести систему в краткосрочной перспективе из состояния "без наблюдаемых ошибок" в состояние "большое количество наблюдаемых ошибок".

## Что такое баг?

Резюме, что в итоге мы только запутались ещё больше, чем раньше :)

Большинство багов всё же не бывают столь коварными, так что стоит ли вообще это исследовать? Не знаю (хотя интуиция подсказывает, что надо). Поразительно, но в программной инженерии нету какого-то особого, отдельного раздела об ошибках. Да, собрано огромное количество статистики, есть много академических исследований, есть немало инструментов для отладки, анализа и тестирования.

Но вы можете получить около 90% основной теории этого всего, прочитав пару-тройку моих материалов с курса карьеры (отладка, тестирование). Поэтому исследование странных краевых случаев кажется хорошей идеей, потому что это приближает нас к дальнейшему развитию дисциплины об ошибках.
