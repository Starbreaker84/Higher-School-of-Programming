## Программирование с применением рекурсии.Программирование со списками

Рекурсивные вычисления -- это сердце декларативного программирования.

Списки -- очень лаконичный тип данных, и в то же время потенциально такой мощный, что позволяет закодировать любую сложную структуру данных. Декларативное программирование работы со списками получается простым и выразительным и предлагает следующие базовые подходы:

- **рекурсивное мышление** : как решать задачу в терминах более простой задачи;
- **преобразование рекурсивных вычислений в итеративные** (обычно в рекурсивных вычислениях размер стека растёт пропорционально размеру списка);
- **выяснение правильности итеративных вычислений** (простой и мощный способ -- через инварианты состояний);
- **конструирование программ на основе системы типов** (функция, работающая с некоторым типом, почти всегда имеет рекурсивную структуру, очень близкую к определению типа).

Рассмотрим эти подходы более подробно.


### 20. Рекурсивное мышление

Список -- рекурсивная структура данных, определённая в терминах более маленькой версии себя. Напомню определение, которое мы давали списку: это либо nil (отсутствие значения), либо некоторое значение, сцепленное с последующим списком-"хвостом".Поэтому функция для работы со списками будет состоять из двух частей:

- базовый случай, для небольших списков (ноль, один или два элемента) результат возвращается сразу;
- рекурсивный случай, для крупных списков функция вычисляет результат в терминах результата из более мелких списков.

Простая рекурсивная функция, вычисляющая по такой схеме длину списка:

```
function Len(lst)

    if lst == []
        return 0
    end

    head = lst[1]
    tail = lst[2:end]

    return 1 + Len(tail)

end
```


Другой пример: функция, которая должна объединить два списка, сформировав из них третий список. По индукции разбор надо начинать с первого списка.

```
function Append(Ls, Ms)

    if Ls == []
        return Ms
    end

    return pushfirst!(Append(Ls[2:end], Ms), Ls[1])

end
```

Смысл в том, что мы выделяем голову из первого списка, рекурсивно вызывая Append() для хвоста первого списка и второго списка, после чего добавляем эту голову к результату рекурсии. Мы как бы "выносим" голову первого списка из рекурсии наружу. И так как функция всегда работает только с первым аргументом, постоянно его уменьшая, она гарантированно закончится (это важное требование к декларативным программам).

*Операции pushfirst! и подобные ей конечно не входят в декларативную модель, так как непосредственно модифицируют значения списка-аргумента. В декларативной модели операции над списками обычно создают новые списки, поэтому они практически всегда низкоэффективны, за исключением добавления элементов в голову или хвост, хотя это тоже зависит от реализации* .


### Рекурсивные вычисления (задания)

======= 41. Список -- это...

[ ]линейная структура данных

[ ]стандартная структура данных

[X]рекурсивная структура данных

======= 42. Функция для работы со списками состоит из...

[X] базового и рекурсивного случаев

[ ] рекурсивного вызова

[ ] итеративной обработки

======= 43. В декларативных функциях важно учитывать ...

[ ] гарантированную рекурсию

[X] гарантированное завершение

[ ] модификацию параметров
