### 27. Персистентные очереди и объекты

В ряде случаев бывают востребованы так называемые  **персистентные (persistent) структуры данных, для которых хранится история их изменения** . Например, очередь исходно пуста, потом мы три раза добавляем элементы, затем два раза удаляем, и таким образом получаем одно текущее и четыре исторических состояния. Очередь, которая поддерживает одновременно такое множество состояний, называется персистентной.

Самый простой наивный способ -- хранить каждое состояние как отдельную очередь, и организовывать доступ к её содержимому в режиме "только чтение" ( **неизменяемая, immutable-очередь** ). Однако если в очереди много элементов (тысячи, миллионы, ...) и она быстро изменяется, такой подход ведения истории оказывается крайне неэффективным и в плане быстродействия, и в плане использования памяти. Поэтому были придуманы различные специальные алгоритмы ведения истории распространённых структур данных.

Одна из известных проблем персистентных структур -- это неоднозначность их будущего, неоднозначность дальнейшего усложнения, которое начинает очень сильно зависеть от конкретной схемы работы со структурой, что делает затруднительным универсальный анализ учетных стоимостей. Можно конечно брать классическую наихудшую оценку, но она скорее всего будет сильно неэффективной и может существенно отличаться от реальной. Кроме того, персистентные структуры могут сильно разрастаться по критерию памяти, а работа сборщика мусора для них (ведение счётчиков ссылок на конкретные экземпляры в памяти) может стать ощутимо медленной. В некоторых случаях даже становится эффективнее обходить весь граф персистентной структуры в целом в поисках объектов, которые можно удалить из памяти. Вдобавок счётчики ссылок сами по себе по сути лишают систему иммутабельности.

### 28. Деревья

Немного коснёмся такой не менее популярной структуры данных, как деревья, встречающиеся в огромном количестве проектов. Если список -- это всегда линейная структура, и за каждым его элементом следует более маленький список, то  **дерево -- это структура иерархическая** . За каждым элементом дерева "следует" произвольное количество (начиная с нуля) более маленьких деревьев.

Подробно деревья, разновидностей коих существует множество, и алгоритмы работы с ними вы изучали на отдельном курсе.

Познакомимся с деревом как с рекурсивным типом данных в рамках декларативной модели.

Дерево состоит из элементов двух типов: **листья** (элементы дерева, у которых нету поддеревьев) и  **узлы** , которые содержат одно или более деревьев (называемых поддеревья). Каждый элемент дерева независимо от типа также содержит некоторое значение, обычно называемое  **ключ** . В деревьях не может быть замкнутых циклов связей.

```
Тип Tree -- это:
-- либо лист Leaf, хранящий значение Key;
-- либо узел, хранящий значение Key и 
        множество поддеревьев Tree1, Tree2, ..., TreeN.
```

В некоторых видах деревьев вводятся дополнительные типы узлов – например, левый и правый узел (поддерево) для двоичных деревьев.

Из такого рекурсивного определения достаточно легко, как описывалось выше, реализуются рекурсивные функции работы с деревьями.


### Персистентные очереди и деревья (задания)

======= 63. Персистентная структура данных -- это ...

[X]структура, для которой хранится история изменения

[ ]иммутабельная структура

[ ]неизменяемая структура

======= 64. Проще всего реализовать персистентную структуру данных ...

[] через доступ к её внутренней структуре

[ ] через сборщик мусора

[X] через хранение каждого исторического состояния

======= 65. Узел в дереве ...

[] может хранить пустое множество поддеревьев

[X] не может хранить пустое множество поддеревьев
