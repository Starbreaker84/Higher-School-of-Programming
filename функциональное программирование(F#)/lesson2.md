## 5. Объявление, определение функций

**5.1. Функция**

Функция -- это базовый тип F#, поэтому она определяется с помощью ключевого слова let , как и другие идентификаторы.

В дополнение к идентификатору (имени функции) определение функции должно включать аргумент (параметр функции).

Функция в F# всегда имеет один аргумент.

В правой части определения функции задаётся вычисляемое ей выражение.

```
let circleLen R = 2.0 * 3.14 * R 
```

**5.2. Функциональный тип**

Функция как тип данных определяется типом своего аргумента и типом результата, перечисляемых через стрелку -- комбинацию символов ->.

Стрелка -- это функциональный тип, функция, которая отображает одно множество значений в другое.

Тип функции circleLen -- это тип float -> float (вещественное значение подаётся как аргумент функции, и вещественное значение возвращается как результат её работы).

Значением имени функции circleLen будет функция типа float -> float.

```
let circleLen R = 2.0 * 3.14 * R
let r = circleLen 5.0 // вызов функции circleLen с параметром 5.0
printfn "length = %f" r // 31.400000
```

```
let circleLen R = 2.0 * 3.14 * R
printfn "length = %f" (circleLen 5.0) // 31.400000
```

**5.3. Анонимные функции (лямбда-функции)**

При объявлении функции её имя можно не указывать, такая функция называется анонимной.

Анонимные функции используются в функциональных выражениях, которые вычисляют значение типа функции (новую функцию).

Простое функциональное выражение (лямбда-выражение) задаётся с помощью ключевого слова fun, за которым следует аргумент, и выражение над аргументом, отделённое символом ->.

```
fun R -> 2.0 * 3.14 * R 
```

Тип анонимной функции записывается аналогично типу обычной функции, например float -> float.

В общем случае функция circleLen с помощью анонимной функции запишется так:

```
let circleLen = fun R -> 2.0 * 3.14 * R 
```

**5.4. Функции с несколькими параметрами**

Функции с несколькими параметрами в F# эмулируются специальным синтаксисом и использованием кортежей (см. далее).

Простая компактная форма функции с несколькими параметрами подразумевает запись параметров в круглых скобках.

В случае "нескольких параметров" их тип указывается перечислением через символ * (см. далее).

Если функция состоит из набора инструкций, эти инструкции задаются после её заголовка с отступами, которые показывают вложенность, локальность этих инструкций.

В качестве своего результата функция возвращает значение последнего выражения в своём теле.

```
let sum3 (x,y,z) = 
    let a = x + y
    a + z

sum3(1,2,3) // 6
```

Тип функции sum3 -- int * int * int -> int.

**5.6. Обобщённая запись типов**

Вместо конкретного типа (например, int) может указываться обобщённый тип. Например, в качестве параметра может быть значение любого типа, если из исходного кода нельзя явно вывести конкретный тип параметра.

Символ ' перед идентификатором a,b,... обозначает, что в данном случае может использоваться значение любого типа.

Например, тип функции

```
let f x = 1
```

будет 'a -> int, где 'a -- произвольный тип параметра x.

Ещё несколько примеров типов функций:

```
let f (x) = x * 3.14 // float -> float
let f (x, y) = x // 'a * 'b -> 'a
let f (x, y) = x + y // int * int -> int
let f x y = 1 // 'a -> 'b -> int
let f x y = x * y // int -> int -> int
```

Обратите внимание, как автоматически компилятор выводит предполагаемые типы функций.

**5.5. Задания**

5.5.1. Напишите функцию g(n) = n + 5 без использования анонимной функции, и в комментариях укажите её тип.

5.5.2. Реализуйте функцию gg(n) = n + 5 с помощью лямбда-функции.

5.5.3. Напишите функцию h(x,y) (тип float * float -> float), где h(x,y) вычисляет корень из суммы квадратов параметров. Для расчёта корня используйте стандартную функцию System.Math.Sqrt.

Шаблон для отправки на сервер:

```
let g ... // тип?

let gg ...

let h (x,y) = ...
```
