### Планирование работы нитей

Ранее отмечалось, что планировщик должен быть справедливым -- каждая готовая к работе нить в конечном итоге будет выполнена. Однако полноценный планировщик должен делать гораздо больше, нежели просто гарантировать справедливость.

**Временные срезы**

Планировщик помещает все готовые нити в очередь. На каждом шаге он берет первую нить в очереди, позволяет ей выполнить некоторое количество шагов, а затем помещает её обратно в очередь (в конец). Это классическое  **круговое планирование (round-robin scheduling)** . Оно гарантирует, что процессорное время распределяется равномерно между работоспособными нитями.

Однако этот подход будет неэффективным, если позволять каждой нити выполнять только один шаг вычислений (например, одну инструкцию кода). Накладные расходы на управление очередью по отношению к фактическим вычислениям оказываются высокими. Поэтому планировщик обычно позволяет каждой нити выполнить достаточно много шагов, прежде чем вернуть её в очередь.

Каждая нить получает некоторое максимальное время, в течение которого ей разрешено выполнятьcя. Этот интервал времени называется **временным срезом (time slice)** или, чаще,  **квантом** . После того как временной интервал нити заканчивается, планировщик останавливает её выполнение и возвращает в очередь. Остановка запущенной нити называется  **упреждением (preemption)** .

Для отслеживания того, что каждая нить получает примерно одинаковую долю процессорного времени, планировщик придерживается одного из двух примерно одинаковых в плане практичности подходов.

Первый -- это **подсчёт шагов вычислений** и позволение выполнять их примерно одинаковое количество. Это детерминированный подход, который применяется например в критически важных системах жёсткого реального времени.

Второй -- это  **использование аппаратного таймера** , который даёт одинаковое время каждой нити. Однако такой планировщик уже не будет детерминированным, и любое событие на уровне ОС (например, дисковая или сетевая операция), повлияет на реально выполненное число шагов в нити.

### Уровни приоритетов

Для многих систем подход раунд-робин оказывается недостаточным. Например, в ходе вычислений может произойти событие, требующее срочной обработки, когда надо отложить все остальные вычисления.

С другой стороны, нельзя допускать, чтобы подобные срочные вычисления приводили к излишнему замедлению нормальных вычислений.

Компромисс, который хорошо работает на практике, заключается в добавлении нитям уровней  **приоритета** . Каждому уровню приоритета отводится минимальный процент процессорного времени. В пределах каждого уровня приоритета нити распределяют процессорное время справедливо.

В типовых некритических системах часто используются три уровня: высокий, средний и низкий. Распределение времени между ними задаётся например в пропорции 100 : 10 : 1. Каждый десятый квант работы нитей с высоким приоритетом отдаётся нитям со средним приоритетом, а каждый десятый квант работы нитей со средним приоритетом отдаётся нитям с низким приоритетом.

### Наследование приоритетов

Когда нить создаёт дочернюю нить, то ей присваивается тот же приоритет, что и у родителя (это особенно важно для нитей с высоким приоритетом). Однако на практике само задание приоритета требует некоторых ресурсов, по умолчанию нити получают средний приоритет, и не исключена ситуация, когда дочерняя нить, получив при создании средний приоритет, будет отложена планировщиком в плане выполнения надолго, и ей придётся долго ждать повышения своего приоритета, что в параллельных системах приводит к трудно обнаруживаемым ошибкам. Поэтому надо всегда стремиться к такой реализации, когда дочерняя нить ни при каких условиях не будет иметь более низкий приоритет, чем родительская нить.

Про классический пример конфликта приоритетов рассказывал тут: [история сбоев на Mars Pathfinder](https://vk.com/wall-152484379_3458).

### Длительность кванта

Короткий квант даёт очень "тонкий" параллелизм: нити быстро реагируют на внешние события, однако и накладные расходы на переключение между нитями становятся значительными. Как тут правильно искать компромисс? Для этого надо определиться с реализацией упреждения: будет ли сама нить следить, как долго она работает, или же это делается внешним планировщиком?

Оба решения вполне жизнеспособны, но второе гораздо проще в реализации. Современные многозадачные ОС (Linux/Unix, Windows Server, Mac OS X) поддерживают таймерные прерывания, которые вполне можно использовать для программных прерываний работы нитей. Они работают с относительно большим квантом (например, 0.1 секунды), а на практике вполне возможна ситуация, когда приложение организует 100,000 активных нитей. Но тогда каждая нить получит свой квант лишь каждые 1000 секунд, что конечно долго. Однако такая модель вполне допустима, если нити взаимодействуют лишь друг с другом, а не с внешним миром, потому что если их работа сильно зависит от работы других нитей (прежде всего в плане ожидания связывания переменных), то они обычно используют лишь малую часть своего кванта времени.

В то же время достаточно большие системы, конечно, постоянно обращаются к внешнему миру: каждая нить не зависит от других, но активно запрашивает и отправляет данные за пределами родительского приложения (например, по сети, из файлов, из базы данных...). Однако в этом плане неудовлетворительны ни современные ОС, ни само аппаратное обеспечение. В идеале надо использовать ОС жёсткого реального времени, работающую на особом типе аппаратного обеспечения.

---

Как уже говорилось, декларативная параллельная модель очень проста и очень элегантна, однако качественные её реализации практически отсутствуют. Выход? применять немного другие вычислительные парадигмы одновременных вычислений (например, модель акторов), которые мы рассмотрим отдельно.

### 7. Базовые техники программирования с нитями

======= 17. dataflow-переменные в недекларативных языках программирования...

[ 1] легко моделируются, но совсем невыразительны

[ ] легко моделируются и хорошо выразительны

[ ] трудно моделируются и совсем невыразительны

[ ]  трудно моделируются, но хорошо выразительны

======= 18. Как планируется выполнение нитей? (выберите неверное утверждение)

[ ] вытесняющим планированием

[ ] справедливо

[ 1] через связывание значений с переменными

[ ]  с помощью временных срезов

======= 19. Любую декларативную программу можно сделать параллельной?

[ ] нет

[ ] да, добавив мьютексы, async/await...

[ 1] да, добавив понятие нити
