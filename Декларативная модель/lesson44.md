### Поддержка модулей в Julia

В Julia поддерживается концепция модулей, весьма близкая к вышеописанной декларативной модели: [docs.julialang.org/en/v1/manual/modules/](https://docs.julialang.org/en/v1/manual/modules/)

В качестве примера определим модуль MyList, содержащий функции для работы со списками.

Создадим файл MyList.jl, и обозначим его как модуль с соответствующим названием с помощью ключевого слова module, заканчивающегося end:

```
module MyList
 # ...
end
```

Мы определим в модуле три функции:

- Append(), которая добавляет новый элемент в хвост списку;
- Is(), которая проверяет, присутствует ли элемент в списке;
- Sort(), которая сортирует список.


Экспортируемые из модуля функции, типы и другие сущности (имена) задаются в разделе экспорта, после ключевого слова export.

Добавим для простоты стандартные реализации.

```
module MyList

export Append, Is, Sort, x, y

function Append(Ls, Elem)
  return vcat(Elem, Ls)
end

function Is(Ls, Elem)
  return Elem in Ls
end

function Sort(Ls)
  return sort(Ls)
end

x() = "x"
y = "y"
z() = "z"

end
```

Мы также добавили две функции x() и z(), одна из которых x() экспортируется из модуля, а другая z() доступна только внутри него. Кроме того, в модуль добавлена экспортируемая переменная y.


Как использовать модуль в своей программе? Это правильнее делать с помощью инструкции using или import, но они подразумевают, что модуль установлен в системе Julia с помощью менеджера пакетов. Поэтому для простоты воспользуемся такой схемой:

```
include("MyList.jl")

import .MyList: x

print( x() )
```

Сперва мы включаем с помощью include код модуля из файла MyList.jl, находящегося в текущем каталоге, в файл с данным кодом, который расположен в одном каталоге с MyList.jl.
Затем мы импортируем модуль MyList, что называется, in place – непосредственно из текущего файла, для чего ставим точку перед именем импортируемого модуля:

```
import .MyList
```

Наконец, после имени импортируемого модуля через двоеточие задаётся перечень импортируемых из этого модуля имён:

```
import .MyList: x
```

Выполняя import или using, мы вызываем функтор MyList, который создаёт и возвращает «экземпляр» модуля MyList со всем его физическим содержимым. Например, выполнив

```
import .MyList: x, y
```

мы получим в нашей программе полноценную переменную y, проинициализированную значением "y1".

Как видно, модуль как функтор вычисляется в реальном времени. Он вполне может содержать данные, рассчитываемые в момент вызова. Функтор может быть размещён в отдельном файле, и при этом он может быть совсем «лёгким» -- например, хранить один объект или класс.

Фактически функторы – это значения, однако в Julia модули позиционируются прежде всего как синтаксические единицы, как пространства имён для инкапсуляции и разграничения видимости. В любом случае, модули сегодня присутствуют практически в любом языке программирования и поддерживают схему компонентно-ориентированного программирования, которая особенно продуктивна в языках с динамической типизацией: компоненты (модули) создаются и гибко связываются в реальном времени. При этом полезная возможность, поддерживаемая в Julia – это предварительная компиляция модулей для их быстрой загрузки, если они не требуют ввода данных из внешнего мира.

Но следует помнить и о типичных проблемах иерархий модулей, когда потенциально возможны, например, закольцованные ссылки. Чем больше модулей в системе, тем тщательнее надо продумывать взаимосвязи между ними.


### Модули в Julia (задания)

======= 94. Модуль в Julia -- это ...

[x]функтор, вычисляемый в реальном времени

[]файл, компилируемый заранее

======= 95. Функтор в Julia -- это ... (выберите неверное утверждение)

[x]интерфейс

[]значение

[]синтаксическая единица

[ ]пространство имён для инкапсуляции

[ ]элемент иерархии модулей

[ ]программный компонент
