## Ассоциативный массив

Хэш-таблицы хоть и реализованы в большинстве языков программирования, в стандартных библиотеках, однако напрямую используются редко, так как сами по себе не очень полезны. Однако существует такая очень популярная структура данных, как  **ассоциативный массив (или словарь)** , когда мы храним данные в формате ключ - значение. Такой массив отличается от обычного тем, что в качестве индексов выступают не целые числа, а произвольные значения (например, строки). Вот тут мы и находим точку пересечения с хэш-таблицами.

Стандартный словарь Python позволяет записать в переменную набор пар ключ-значение:

```
my_dict = {"key1": "значение 1", "ключ 23": 512}
```

и в дальнейшем получать нужное значение, указав ключ в качестве индекса:

```
my_dict["ключ 23"] # 512
```

Можно изменять значения в словаре:

```
my_dict["ключ 23"] = 1024
```

Для реализации ассоциативного массива воспользуемся хэш-таблицей, реализованной в предыдущем занятии. По сути, требуется лишь дополнить ее вторым массивом self.values -- в дополнение к массиву self.slots, который будет хранить ключи.
self.values по размеру будет таким же, как и self.slots, а записываются в него значения, соответствующие ключу слота (с таким же индексом).

Главное отличие ассоциативного массива от хэш-таблицы в том, что он обычно не ограничен каким-то фиксированным размером (количеством ключей), и либо исходно под конкретную задачу создаётся с гарантированным запасом по размеру, либо сочетает возможности хэш-таблицы и динамического массива.

Если по каким-то причинам реализация с хэш-функциями не подходит (например, возникает слишком много коллизий), то для реализации словаря вполне можно использовать упорядоченный массив фиксированного размера, который хранит, например, объекты с двумя полями ключ и значение.
Другой вариант -- использовать для реализации словаря двоичное сбалансированное дерево, где поиск ключей происходит очень эффективно (все важные виды поиска проходим на курсах по деревьям графам и сортировкам). Но сама реализация будет сложнее, она подразумевает работу с указателями и динамическим выделением памяти, а изменение структуры дерева (добавление новых узлов и балансировка) может требовать дополнительных накладных ресурсов, если, например, счёт идёт на миллионы элементов.

Реализуйте три метода:

- put(key, value) - сохранение внутри класса ассоциативного массива пары ключ-значение по описанной выше схеме;
- is_key(key) - проверка, имеется ли в слотах такой ключ;
- get(key) - поиск и извлечение значения по ключу, или None, если ключ не найден.

4. Сделайте тесты, проверяющие, как работают put(), is_key() и get():

- добавление значения по новому ключу и добавление значения по уже существующему ключу с проверками что записалось, проверка присутствующего и отсутствующего ключей, извлечение значения по существующему и отсутствующему ключу.

**[предыдущее](https://skillsmart.ru/algo/py-kf32y/re8af6c877.html)**

---

В данном обучающем примере исходим из фиксированного размера ассоциативного массива. В автоматических тестах этот размер гарантированно не будет превышен.

## заготовка класса для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/py-kf32y/github_py.html)

```
class NativeDictionary:
    def __init__(self, sz):
        self.size = sz
        self.slots = [None] * self.size
        self.values = [None] * self.size

     def hash_fun(self, key):
         # в качестве key поступают строки!
         # всегда возвращает корректный индекс слота
         return 0

     def is_key(self, key):
         # возвращает True если ключ имеется,
         # иначе False
         return False

     def put(self, key, value):
         pass
         # гарантированно записываем 
         # значение value по ключу key

     def get(self, key):
         # возвращает value для key, 
         # или None если ключ не найден
         return None
```
