## Семь неочевидных проектных ошибок

Один из лучших методологических подходов, прекрасно работающий во многих инженерных областях, и в частности, в программировании – это не

"позволять разработчику делать всё, что не запрещено, запрещать по минимуму, и стараться давать свободу творчества",

а наоборот:

**"не позволять разработчику делать то, что запрещено, и запрещать исходно по возможности вообще всё".**

Первый подход даёт наглядно печальные результаты в ИТ: в популярных языках программирования допускается полная свобода и огромное количество возможностей даже для начинающих, что приводит к бесконечному количеству ошибок и ужасным программным архитектурам. Прежде всего потому, что базовых универсальных инструкций в программировании, по сути, всего три: присваивание, условие и цикл, с их помощью можно запрограммировать любую логику. Это классическая вычислительная модель Тьюринга, что было доказано теоремой Бёма -- Якопини (Дейкстра и структурное программирование). Все ассемблеры на ней построены фактически. Не умея программировать по этой модели, хорошим программистом невозможно стать. Однако и начинать с такого уровня тоже далеко не лучший вариант. Но тут без полной свободы не обойтись, потому что инструментарий совсем слабенький: три инструкции и концепция состояния (долгосрочная память), добавляющая страданий.

Но чем сильнее язык программирования, чем больше в нём  **"soundness"** , тем больше смысла он позволяет контролировать на уровне синтаксиса, и тем меньше он даёт свободы (нередко перебарщивая и запрещая даже корректные варианты (что не должна делать "complete" система типов), но это нормально для прикладных задач). Увы, но ни Java или C#, ни даже TypeScript или Scala, не считаются soundness. Они может и претендуют на это, но пока у них в реализациях кучи багов вроде "не могу считать проперть...".
soundness -- это Haskell например (за F# кстати с ходу не скажу).

Однако второй подход "не позволять разработчику делать то, что запрещено..." почти не распространён, потому что его сложно реализовать ровно по причине популярности языков программирования с полной свободой. Существуют различные методики, накладывающие определённые ограничения (точнее, правила) на процесс кодирования и проектирования. Одна из таких методик Бертрана Мейера изучается на моих курсах по объектно-ориентированному проектированию. В частности, на основе концепции абстрактных типов данных каждый класс однозначно задаёт в проекте конкретную структуру данных с чётко определённым набором операций над ней, и никакие другие активности в системе не допускаются.


Сегодня также делаются попытки реализовать данный подход с помощью нового поколения AI-систем формального доказательства теорем и верификации кода, которое зародилось буквально 10 лет назад благодаря работам математика Владимира Воеводского (унивалентные основания математики и гомотопическая теория типов). Такие системы следят, например, за семантической допустимостью очередной инструкции, вводимой программистом – не нарушает ли она формально заданного смысла кода. Пока такой подход сложен в эксплуатации и труден в обучении, поэтому мы пойдём обходным путём: попробуем "встроить" сразу в голову своеобразную логическую машинку, которая и будет выполнять роль такого AI.

Начнём с небольшого перечня правил кодирования, которые не говорят, "как правильно", но говорят, "как неправильно". В немалом числе книг по "чистому коду и архитектуре" приводятся десятки и сотни рекомендации и пояснений, что такое хороший код и как правильно его писать. Однако чтобы даже просто прочитать их, потребуется не один десяток часов, а уж запомнить и начать регулярно применять тем более нереально.

Далее вы познакомитесь с контринтуитивными правилами создания хорошего кода "от противного", которые выработаны специалистами Массачусетского технологического института и были проверены на практике повышения квалификации сотен разработчиков самой разной квалификации, от начинающих до сеньоров.


## Как же создавать отличный код?

Это, как ни удивительно, недостаточно изученный вопрос. Много всего написано и пишется о том, как запрограммировать мобильное приложение или построить отказоустойчивую систему, или как стать тимлидом и возглавить команду разработчиков. В сравнении с потоком книг и статей на эти темы сравнительно мало (крайне мало!) было написано полезного например на такую абсолютно актуальную любой команде программистов тему "как формировать кодовую базу проекта так, чтобы программисты через год продолжали с ней работать свободно, легко и с удовольствием".

И всё же нету ничего загадочного в том, как хорошо писать код. Это обычный навык, которому можно обучиться так же, как и изучить Java или веб-фреймворк. Сермяга в другом. Любой программист знает, что код должен быть простым, а система должна иметь ясный и чёткий дизайн (дизайн не в смысле UI, а в смысле проектирования, внутренней структуры, которую часто смешивают с технической архитектурой). Стандартные правила ясного кода известны каждому и растиражированы в сотнях книг и статей. Однако они не дают того эффекта, который от них ожидается.

Дело в том, что сильные идеи и принципы good code design гораздо глубже, чем кажется. Программисты часто говорят о "простоте", а затем так "упрощают" свой код, что он на самом деле становится только более сложным.

В данном материале вы познакомитесь с основными контринтуитивными идеями по поводу того, что делает код плохим, и узнаете, как с этим бороться, чтобы повысить свой уровень программирования. Некоторые из них, возможно, уже будут вам знакомы, однако вы увидите их в совсем новом свете.

И если вы вынесете из этого материала хотя бы одну сильную идею, которая вас удивит и изменит ваши представления о том, что такое хороший код, тогда моя миссия будет выполнена.


## 1. Отладка, логи, проверки – это плохой подход.

На накачивание своего кода всяческими внутренними проверками (так называемое "защитное программирование"), на организацию логов в системе, и тем более, на поиск ошибок в отладчике программисты традиционно тратят много времени и ресурсов (часто заметно больше 50%).

Нередко в функциях присутствуют длинные цепочки условных операторов, которые проверяют, в корректных ли диапазонах оказались значения параметров, допустимо ли расширение файла, была ли сделана нормальная инициализация, и т. д. Такие проверки напоминают валидаторы на сайтах, которые сообщают, если пользователь ввёл, например, недопустимое отрицательное значение в поле. Или ситуацию, когда вы покупаете плеер и читаете в инструкции, что нельзя задавать отрицательный уровень громкости, иначе он "зависнет".

При хорошем дизайне системы такие проблемы невозможны. Дело не в том, чтобы разрешать вводить отрицательные значения туда, где они недопустимы, такой запрет вполне нормален. Проблема в том, что подобные проверки разработчики фронтенда, например, "прикручивают" механически, не имея никакого представления о функционировании системы в целом. Такие проверки никак не вытекают логически из дизайна системы, это просто инженерная страховка "от дурака" на самом низком уровне.

Длинные цепочки условных операторов – такой же плохой дизайн, как и в случае с плеером.  **Когда вы проектируете свои API, типы и структуры данных, вы фактически выбираете, в каком множестве состояний может находиться ваша программа** .

Так что просто  **сразу проектируйте такое множество, которое не содержат ошибочных состояний** . В этом, в частности, помогает тщательное продумывание системы типов проекта, которая фактически и задаёт допустимое множество состояний.

Защитное программирование, защитный код означают, что в программе уже есть от чего защищаться. Так что не препятствуйте ошибкам специально.  **Делайте ошибки невозможными** .


## 2. Рефакторинг – это не коробка для мусора.

Допустим, в популярном веб-фреймворке имеется класс для сохранения поступившего блока данных (например, изображения) в заданный файл. Его конструктор содержит длинный список проверок, удостоверяющих, что путь к файлу существует и корректен, а файл доступен для перезаписи. Программист взялся за рефакторинг этого кода и переместил все проверки в отдельный метод, который назвал is_valid.

Другой программист в это время улучшал сложную логику и, дабы сделать её более наглядной и гибкой, выделил её часть в новый модуль с набором функций с множеством параметров.

Третий программист нашёл сомнительный момент в одном из классов, но чтобы не нарушать принцип Открыт-Закрыт, добавил новый класс в отдельном файле, который уточняет это сомнительное поведение.

Такая работа напоминает уборку квартиры, когда мы ходим по комнатам, собираем валяющиеся на полу вещи, и бросаем их все в одну коробку. В ней потом эти вещи найти будет легче, ведь правда?

**Во всех этих случаях возможно сделать сам код существенно проще** . Но для этого потребуется гораздо больше думать. Потребуется найти ключевые концепты системы и выразить их напрямую, вместо того, чтобы бросать код в коробку.

Переписывание текстовой заметки -- это не изменение её пунктуации. Это про то, чтобы подумать о том, что именно вы хотите сказать -- и сказать это по-другому. Рефакторинг -- это не перемещение кода в функции и модули. Надо постоянно думать о дизайне, о построении вашего кода, и стараться придумывать, как его можно структурировать более эффективно.

Факторинг – это представление чего-то в виде композиции частей.
Ре-факторинг -- это представление чего-то по-другому.
Итак, при рефакторинге надо изменять структуру, изменять дизайн, изменять саму конструкцию.


## 3. Почему некоторые проектные решения нельзя отменить.

Чтобы понять, почему некоторые решения не могут быть отменены, представьте себе попытку изменить формат USB-разъёмов. Сначала надо разработать более продуктивный формат. Потом нужно будет добиться, чтобы вся электронная индустрия обновила все свои продукты. И в заключение потребуется, чтобы каждый владелец гаджетов и компьютеров заменил старые USB-платы и установил новые на каждое "старое" устройство. Очевидно, этого скорее всего не случится.

Или, например, вы работаете в Adobe и решили переделать формат PDF с нуля и выбросить весь старый код его поддержки, потому что он слишком сложный. Возможно, в таком случае вам будет проще заменить все USB-разъёмы в мире.

Вы можете менять внутреннюю часть вашей системы, как вам вздумается. Но её границы похожи на USB-разъём. Код, который вы пишете, содержит ваши предположения и допущения по поводу того, как лучше обрабатывать данные. Эти предположения фактически заложены в структуры данных, и ваш будущий код должен с ними хорошо справляться.

Если клиенты используют ваше программное обеспечение в течение 20 лет, тогда вы становитесь зависимы от своего решения 20-летней давности. Эта специфика и методы её решения подробно рассматриваются, в частности, на моём курсе по высоконагруженным проектам, где большую роль играют форматы данных и обеспечение их совместимости.

**Границы вашей программы должны быть спроектированы исключительно хорошо** , потому что вам придётся жить с ними долгое время.


## 4. Не переусердствуйте с интерьером.

Когда программисты начинают совершенствовать свой стиль кодирования, это напоминает включение света в заброшенном подвале. Куча бессмысленных или абстрактных имён переменных, повсюду магические константы и некрасиво запутанные строки кода. Вычистим это всё!

Но когда через некоторое время эти же программисты начинают заниматься просмотром кода джуниоров, они начинают требовать от них того же: пишите строки короче, делайте напрямую стандартные вызовы, добавляйте больше комментариев… Они движутся к лучшему коду постепенно, шаг за шагом.

Однако очень часто при таком подходе они оказываются отнюдь не на самой высокой знаниевой вершине.  **Они нашли лишь локальный максимум** , откуда до сияющей вершины Фудзиямы теперь стало добираться ещё труднее.

Упрощение нескольких строк кода сегодня не поможет в лёгком добавлении новых фич завтра. А вот создание правильного дизайна проекта такую возможность даёт.

В вашем здании может быть самая ужасная и запутанная компьютерная сеть в мире -- но если никому не требуется её обслуживать, то это не проблема. Но если сетевые кабели нового оборудования, которое требуется срочно ввести в эксплуатацию, не подключаются к ней как следует, вам, возможно, придется перебрать всё кабельное хозяйство полностью, по всему зданию, чтобы исправить проблему.

Неопытный ревьюер кода фокусируется на деталях анализируемого кода.
Мудрый ревьюер обращает пристальное внимание не на его форму, а в первую очередь на то,  **как код влияет на остальную часть проекта** .


## 5. Качество кода (в значительной степени) не имеет отношения к самому коду.

Разработчики получили задание изучить кодовую базу нового проекта. И вот через несколько минут довольный тимлид наблюдает, как большинство ребят уже копается в разных функциях, пытаясь построчно в них разобраться. Это неправильный подход -- программисты перегружены низкоуровневой работой.

Правильное понимание и в программировании, и в других инженерных областях, заключается в том, что человек думает о том,  **"что делается"** , а не о том, "как это делается".

Если сперва думать о хороших структурах (типах) данных, то чистый код последует за ними естественно. А делать наоборот – это разукрашивать свинью помадой :)

Наглядно это поясняю на цикле курсов по парадигмам программирования, где мы начинаем как раз с декларативной парадигмы, учимся думать на уровне "что", и только потом, очень постепенно, двигаемся к императивной stateful-парадигме "как", плавно получая понимание, что "как" даже в императивных языках требуется на самом деле весьма ограниченно.

Как сказал Линус Торвальдс: "Плохие программисты беспокоятся о коде.  **Хорошие программисты беспокоятся о данных и об их взаимоотношениях.** ".


## 6. Застревание в старом дизайне.

Программист пришел к сеньору, чтобы пожаловаться на проблему: надо импортировать (скопипастить, проще говоря) некоторую функцию из файла в соседнем проекте, но в том файле имеется ещё много другого кода, импорт которого создаст проблемы. Что ему делать? Ему и в голову не пришло, что он может разделить тот файл на два, декомпозировать нужную семантику. Это тоже создаст некоторые проблемы в соседнем проекте, но не такие большие, как если пытаться механически импортировать кучу чужого кода.

Многие программисты считают, что их работа -- это какие-то страдания с монолитными глыбами. Они пытаются выполнять свои задачи, но при этом либо только пишут новый код, либо только заменяют один модуль другим. Существующие компоненты обычно не реализуют в точности то, что требуется, и поэтому программисты большую часть времени работают над их "рефакторингом". Бесконечные преобразования данных и вереницы условных операторов.

Важное тут -- уметь вносить структурные изменения в кодовую базу так, чтобы поддержка того, что вы делаете, стала простой. Это нелегко сперва, но это отлично окупается позже. Код и дизайн становятся ясными.

Почитайте дополнительно занятие с курса карьеры по сопровождению кода.

**В любом проекте возможен дизайн, который сделает код, который вы пишете, красивым и простым** . Если выбранные проектные конструкции для этого не подходят, то просто измените их.

Так что не бойтесь --  **смело делайте нелокальные изменения проекта** , только не теряйте при этом адекватность, и не превращайте такие изменения в переписывание системы с околонуля.


## 7. Что делает плохие тесты плохими?

Есть два способа писать плохие тесты.

Один из них -- не проверить как следует, что код делает именно то, что он должен делать. Большинство программистов знает об этом.

Другой -- тестировать слишком много. Избыточные тесты немного похожи на ЕГЭ, когда от школьников требуется запоминание дат событий вместо понимания смысла и предназначения этих событий.

Тесты фактически проверяют ожидания разработчиков от кода, поэтому они слишком специфичны. Ожидания быстро меняются и часто бывают ошибочными сами по себе.

Непонимание этих моментов и приводит к слабым тестам. Во многих компаниях пишутся тесты, которые "покрывают код на 100%": проверяют каждую строку кода и все детали работы программы. Зачем проверять, что метод bar() вызывается 3 раза? Потому что он вызывается один раз напрямую, и дважды методом foo(), вот почему.

**Понимание системы -- это о чём-то большем, нежели просто покрытие кода тестами** . Речь идет об одном из фундаментальных положений программной инженерии:  **думать о смысле, о предназначении программы, которое отличается от самой программы, от её кода** .

Так что не проверяйте, что код делает то, что в нём непосредственно написано.  **Убедитесь, что код делает именно то, что должен делать в рамках всей системы в целом** .
