## Восстановление после отказа

Проблема 14. При асинхронной репликации новый ведущий узел мог не получить все сообщения о записи от старого ведущего из-за его отказа. Когда старый ведущий узел, переназначенный в ведомые, попытается присоединиться к системе, те операции записи, которые на нём оставались после сбоя, и никуда не были отправлены, скорее всего станут конфликтовать с новым состоянием. Вероятна и обратная ситуация: новый ведущий, пока он был ведомым, мог не получить или не обработать до конца все операции записи от старого ведущего.

Решение: Отбросить нереплицированные записи старого ведущего узла.

## Восстановление после отказа

Проблема 15. Отбрасывание нереплицированных записей всегда опасно, а главное, не обеспечивается сохраняемость и приватность данных, причём такая конфликтная ситуация отнюдь не какая-то экзотика. Например, известный случай сбоя GitHub, когда ведомый узел с не самыми свежими данными был переведён в ведущие, но в его базе автоматически увеличиваемый счетчик для присвоения первичных ключей новым строкам отставал от прежнего. В результате сгенерировалось множество первичных ключей, совпавших с уже существующими, такое повторное использование первичных ключей привело к несогласованности между MySQL и Redis, в результате чего оказались раскрытыми ряд приватных данных совершенно разных пользователей друг другу.

Решение. Прежде чем объявить ведущий узел недоступным, следует выждать некоторое время, чтобы ведомые узлы досинхронизировали свои реплики.

## Восстановление после отказа

Проблема 16. Долгое ожидание означает ухудшение пользовательских характеристик системы, а слишком короткое время ожидания приведет к ненужным восстановлениям после мнимых отказов (например, из-за временного пика нагрузки). Ещё довольно нередкий случай, когда в процессе такого ожидания сразу два узла почти одновременно посчитают себя ведущими (т.н. "разделение вычислительных мощностей"). Это совсем плохо: они вдвоём принимают операции записи, а процесс разрешения конфликтов в таком случае весьма усложнён, возникает большая вероятность потери или порчи данных.

Решение. В подобных случаях часто вводят механизм отключения одного из таких узлов в случае обнаружения двух ведущих.

## Восстановление после отказа

Проблема 17. Если не спроектировать такой механизм отключения второго ведущего очень тщательно, возможны случаи, когда оба ведущих узла перестанут работать.

Решение. Сегодня восстановления после отказов, как и раньше, часто выполняется системными администраторами в ручном режиме, даже если система поддерживает подобную автоматическую возможность. Ситуации могут быть очень сложными и запутанными, когда в один клубок сплетается множество проблем: отказы узлов, ненадежные сети, несогласованность реплик, низкие надежность и доступностью, большое время задержки.

Это всё и есть фундаментальные проблемы распределенных систем.

### Отказы узлов (задания)

======= 15. Новый ведущий (или ещё старый ведомый) узел мог не получить все сообщения о записи ...

[1 ] отбросить нереплицированные записи старого ведущего

[ ] отбросить нереплицированные записи старого ведомого

[ ] отбросить нереплицированные записи нового ведущего

[ ] отбросить нереплицированные записи нового ведомого

======= 16. Отбрасывание нереплицированных записей не обеспечивает сохраняемость и приватность данных

[1 ] выждать, чтобы ведомые узлы досинхронизировались

[ ] выждать, чтобы ведущие узлы досинхронизировались

======= 17. Сразу два узла почти одновременно посчитали себя ведущими

[1] вручную восстановливать систему после отказов

[] при обнаружении двух ведущих автоматизировать отключение одного из них
