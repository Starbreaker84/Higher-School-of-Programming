### Понимание кода

По мере нарастания кода проект, слабенький в плане проектирования (называем его легаси, или унаследованный код, хотя это и не совсем точно), постепенно достигает критической массы -- сами разработчики перестают его понимать. Когда дизайн проекта хороший, то понять, как внести в него новые изменения, как правило, удаётся быстро, и сами изменения вносятся легко, причём работать с системой в результате становится ещё удобнее.

Чтобы выяснить, как внести изменения в унаследованную систему, требуется немало времени, а сами изменения в неё вносятся трудно. Нередко создаётся впечатление, что для полного понимания такой системы потребуется слишком много времени, а для изменения кода придётся действовать буквально на ощупь.

Классическая характеристика хорошего дизайна:  **система наглядно разделена на небольшие автономные и вполне понятные части (компоненты)** .

### Понимание кода

26. Проблема. Одна из самых больших сложностей унаследованного кода -- отсутствие тестов вокруг большей части такого кода. Более того, добавлять такие тесты сложно и трудоёмко. Когда возникает потребность в добавлении нового кода, разработчики нередко используют только что рассмотренные подходы, однако они связаны с целым рядом опасностей, как явных, так и неявных. Во-первых, мы не изменяем код существенно, а по сути, просто добавляем ему "приляпки", и поэтому он на самом деле не становится от этого особо лучше. Во-вторых, добавляемый код вполне может дублировать код, уже существующий на непротестированных и незнакомых частях, и в итоге он станет ещё большим "легаси". Причём мы можем даже и не осознавать, что дублируем код -- пока не зайдем слишком далеко с внесением изменений. В-третьих, менять конкретный фрагмент кода, упрощать его в целях удобства становится просто опасно.

Решение. В ООП имеется хорошая фича:  **наследование** , позволяющее вводить новые свойства, не видоизменяя класс непосредственно. Наследование (и неразрывно связанный с ним полиморфизм) в начале 21-го века существенно утратило популярность, потому что многие специалисты замечали, что наследование может вызывать серьёзные осложнения, если пользоваться им чрезмерно активно.

Но это совсем не означает, что мы должны отказаться от наследования -- как минимум, оно хорошо подходит для задач тестирования. Один из самых эффективных инженерных подходов тут -- это TDD (познакомьтесь с ним в материале с курса карьеры).

### Понимание кода

27. Проблема. Неаккуратно применяемое наследование вполне может привести к нарушению принципа подстановки Барбары Лисков (LSP). Объекты подклассов должны без проблем подставляться в коде вместо объектов их родительских классов, в противном случае в системе возникают скрытые ошибки. Код, работающий с некоторым классом, должен корректно использовать и экземпляры любых его подклассов, не зная, что они на самом деле объекты подклассов (подклассы не должны ломать родительский интерфейс).

Решение. Вообще, избегайте, по возможности, переопределения конкретных методов. Идея наследования прежде всего -- частичное (до)определение новых АТД со своим уникальным набором операций через расширение этого набора. Если вы всё же переопределяете конкретные методы, то проверьте, сможете ли (потенциально) корректно вызвать родительский переопределяемый метод в дочернем переопределяющем методе.

В нормализованной иерархии наследования ни у одного из классов нет более чем одной реализации каждого метода. Иными словами, ни у одного из классов нет метода, переопределяющего конкретный метод, наследуемый из суперкласса:  **в нормализованной иерархии не нужно беспокоиться о переопределении в подклассах уже существующего поведения, наследуемого ими от их суперклассов** .

### Понимание кода (задания)

======= 25. Классическая характеристика хорошего дизайна -- ...

[ ] система наглядно разделена на небольшие автономные подсистемы

[ ] система наглядно разделена на небольшие автономные модули

[ 1] система наглядно разделена на небольшие автономные компоненты

======= 26. Рассмотренные подходы к добавлению нового кода в легаси связаны с рядом опасностей (выберите ошибочную опасность)

[ 1] становится опасно улучшать конкретный фрагмент кода

[ ] добавляемый код может дублировать уже существующий код

[ ] мы не улучшаем код существенно

[ ] становится опасно упрощать конкретный фрагмент кода

======= 27. Самое правильное применение LSP -- это ...

[ ] аккуратное переопределение существующего поведения в нормализованной иерархии

[1 ] ни у одного из классов нет метода, переопределяющего метод, наследуемый из суперкласса

[ ] корректный вызов родительского переопределяемого метода в дочернем переопределяющем методе
