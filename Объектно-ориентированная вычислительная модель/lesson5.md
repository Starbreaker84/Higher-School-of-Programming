### Методы и сообщения первого класса

("класса" в смысле "вида" или "порядка")

Принцип прост: сообщения -- это записи, а заголовки методов -- это паттерны, которые выполняют разбор записей. Когда объект получает сообщение (ему некоторым образом передаётся значение в виде записи), автоматически подбирается метод, точно подходящий по своим параметрам для обработки этой записи.

Этот механизм, в частности, реализован в Julia и называется  **Multiple dispatch** . По мнению создателей этого языка, такой подход для мультипарадигмального языка обеспечивает гораздо большую гибкость, нежели классическая схема "присоединения" методов к классам, решая, в частности, проблему сильной связности, возникающей из-за необходимости использовать self/this.

Выбор соответствующего метода ("обработчика" сообщений) может происходить как в момент компиляции в языках со статической типизацией, так и в момент работы программы в языках с динамической типизацией.

Сам метод-обработчик может задаваться как с фиксированным числом параметров, так и с гибким, когда в дополнение к фиксированному списку параметров (или сразу вместо него) добавляется условное "..." -- произвольный список дополнительных параметров, заранее неизвестный. В Python например имеется такая возможность, когда к дополнительным параметрам можно обращаться по их индексам в заголовке, или по именам-ключам в словаре. В общем случае ссылка на заголовок метода со всеми его параметрами может сама по себе быть именованной, когда аргументы "упаковываются" в одну запись.

Параметры могут задаваться со значениями по умолчанию, которые они получают, если явно не заданы в конкретном вызове метода.

Наконец, метод может быть оснащён отдельным свойством (называемым, например, otherwise), которое задаёт, что данный метод будет вызван, если не будет найден (по своему заголовку) никакой другой метод для обработки сообщения. Такой метод не может быть в программе единственным (без других методов). Он имеет один параметр, получая в его качестве любое необработанное сообщение. Данный механизм реализует концепцию делегатов, как альтернативу наследованию и интерфейсам.

Вышеописанная концепция класса с атрибутами, методами/сообщениями и свойствами предлагает  **удобный синтаксис для определения АТД с инкапсулированным состоянием и множеством операций** .

В дополнение к такому синтаксису, в общем случае желательна поддержка "классов как значений", которые сохраняют все преимущества процедурных значений. Классы композиционны и могут быть вложены в классы. Они совместимы с процедурными значениями: классы могут быть вложены в процедуры, и наоборот. Но в популярных языках программирования такие гибкие возможности обычно отсутствуют.

## 3. Классы как инкрементальные (incremental) АТД

*Мне не удалось найти подходящего слова для incremental :)
частичные, наращиваемые, постепенные, постепенно формируемые...*

Как уже объяснялось ранее, основное дополнение, которое объектно-ориентированное программирование добавляет к компонентно-ориентированному программированию -- это  **наследование** . ООП позволяет определять класс постепенно, путём расширения (в том числе дополнения, уточнения, ограничения...) существующих классов. При этом недостаточно просто отметить, какие классы расширяются; для правильного определения нового АТД необходимо больше концепций. Наша модель включает три набора таких концепций:

1. **Наследование** само по себе, которое определяет, какие именно уже существующие классы расширяются.
2. **Управление доступом к методам класса** : как организуется такой доступ к определённым методам как в новом классе, так и в классах выше по иерархии.
3. **Управление инкапсуляцией** : как в остальной части программы за пределами класса организуется доступ к его атрибутам и методам.

Добавив к этим наборам поддержку сообщений первого класса (для реализации делегатов), получим полностью уникальный способ инкрементального определения АТД.

**Наследование -- это способ конструирования новых классов на основе существующих** . Наследование в общем случае допускается как **единичное** (у класса не может быть более одного родителя), так и  **множественное** , и определяет, как существующие атрибуты и методы становятся доступными в новом классе.

Общая схема наследования применима и к атрибутам, и к методам и называется  **связью (отношением) через перезапись (overriding relation)** : метод в классе А перезаписывает собой любой метод с такой же сигнатурой (именем метода и списком параметров с определёнными типами) во всех суперклассах А (находящихся выше по иерархии).

Иерархия классов -- это направленный граф с текущим узлом как корнем. Ребра направлены от нижестоящих к вышестоящим классам. Есть два требования для того, чтобы иерархия наследования была корректной.

Во-первых,  **отношение наследования должно быть направленным и ациклическим** . Условно говоря, нельзя наследовать класс A от B, а класс B от A.

Во-вторых, после удаления всех переопределённых методов, **каждый оставшийся метод должен иметь уникальную сигнатуру** и быть определённым только в одном классе в иерархии.

### Рантайм - это всё, что есть

Система программирования не должна строго различать время компиляции и время выполнения. Такое различие -- просто способ помочь компилятору выполнить определенные виды оптимизации, не более. Однако большинство популярных языков, включая Java, C++ и многие другие, вводят такое различие явно. Как правило, некоторые инструкции (например, объявления классов) могут быть могут быть "выполнены" только во время компиляции, а остальные -- только во время выполнения. В таком случае компилятор может "выполнить" все описания классов и функций одновременно, без какого-либо вмешательства в выполнение программы, что позволяет провести весьма мощную оптимизацию при генерации кода, а также множество глубоких проверок корректности использования системы типов. Однако такая схема значительно снижает гибкость языка.

### Статическое и динамическое связывание

При выполнении метода "внутри" объекта часто происходит вызов другого метода этого же объекта. В общем случае такой вызов можно считать рекурсивным относительно объекта в целом: объект "вызывает" сам себя. Когда в такой ситуации дополнительно допускается наследование, ситуация усложняется. Обычное наследование подразумевает определение нового АТД, который расширяет существующий АТД. Чтобы реализовать эту схему корректно, потребуются два способа поддержки рекурсивных вызовов: статическое и динамическое связывание.

Из-за полиморфизма не всегда возможно определить на этапе компиляции, объект какого именно класса хранится в некоторой переменной. Динамическое связывание (связывание метода с конкретным классом) подразумевает, что определение нужного метода в иерархии наследования выполняется непосредственно в момент обращения объекта к имени метода в процессе работы программы. Такой подход фактически не позволяет вызывать уже существующие "старые" (родительские) методы, когда мы расширили старый АТД новыми возможностями.

Статическое связывание подразумевает, что класс, в котором находится конкретный вызываемый метод, можно определить непосредственно в момент компиляции (например, с помощью явных синтаксических подсказок имени класса через приведение типов).


### Классы как инкрементальные (incremental) АТД

======= 14. Multiple dispatch -- это ...

[ 1] автоматический подбор метода для обработки обращения к объекту

[ ] полиморфный вызов метода объекта

[ ] статический вызов метода объекта

======= 15. Какая концепция вычислительной модели ООП потенциально лишняя?

[ ] видимость методов

[ ] наследование

[1 ] полиморфизм

[ ] инкапсуляция

======= 16. Наследование -- это способ ...

[ 1] конструирования новых классов на основе существующих

[ ] расширения существующих классов

[ ] конструирования новых классов с нуля

======= 17. Статическое связывание отличается от динамического тем, что класс с вызываемым методом можно определить ...

[ ] непосредственно в момент работы программы

[1 ] непосредственно в процессе компиляции

[ ] в момент работы программы, и в процессе компиляции
