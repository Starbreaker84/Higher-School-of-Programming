### 8. Stateless-архитектура

Казалось бы, невозможно сделать систему, где по смыслу наш робот может находиться в промежуточных состояниях, но никаких внутренних переменных или объектов мы не создаём. Конечно, эти состояния в системе в виде некоторой абстракции так или иначе будут присутствовать. Наша задача в другом --  **избавиться от любых явных мутабельных элементов в системе** . Здесь существует несколько интересных подходов, один из которых мы рассмотрим далее.


### Stateless-архитектура

До сих пор мы рассматривали совсем условную схему, где серверная часть лишь подразумевалась. Так, вызов

```
client = ClientApi()
```

на самом деле означает, что клиент начинает  **полноценную сессию взаимодействия с сервером** :

- шлёт запрос,
- авторизуется,
- сервер создаёт копию объекта ClientApi() (для каждого клиента),
- и в дальнейшем, идентифицируя каждое клиентское обращение в рамках сессии, сервер обеспечивает ему прямое взаимодействие с соответствующим объектом.С технической точки зрения такой подход, помимо чисто стилевых или архитектурных аспектов, сильно страдает также в плане неспособности масштабироваться на высокую нагрузку.

Поэтому рассмотрим вариант с техническим акцентом -- с использованием очереди сообщений, хранящей состояния в виде параметров.


### Stateless-архитектура

В новой модели клиент обращается к серверному API, который сам по себе stateless: он ничего внутри себя не хранит, а просто парсит входной вызов и отправляет команду на исполнение в очередь. Эта очередь параллельно и асинхронно обрабатывается так называемыми  **агентами** , также не содержащими мутабельных элементов.

Серверная часть:

```
import pure_robot

class RobotCommand:

    def __init__(self, input_state, command):
        self.state = input_state
        self.command = command

def transfer_to_cleaner(message):
    print (message)

##########

import Queue
import threading

queue = Queue.Queue()
out_queue = Queue.Queue()

class ThreadRobo(threading.Thread):
    def __init__(self, queue, out_queue):
        threading.Thread.__init__(self)
        self.queue = queue
        self.out_queue = out_queue

    def run(self):
        while True:
            command = self.queue.get()
            cleaner_state = command.state
            cmd = command.command.split(' ')
            if cmd[0]=='move':
                cleaner_state = pure_robot.move(transfer_to_cleaner,int(cmd[1]),
                                                cleaner_state)
            elif cmd[0]=='turn':
                cleaner_state = pure_robot.turn(transfer_to_cleaner,int(cmd[1]),
                                                cleaner_state)
            elif cmd[0]=='set':
                cleaner_state = pure_robot.set_state(transfer_to_cleaner,cmd[1],
                                                cleaner_state)
            elif cmd[0]=='start':
                cleaner_state = pure_robot.start(transfer_to_cleaner,
                                                cleaner_state)
            elif cmd[0]=='stop':
                cleaner_state = pure_robot.stop(transfer_to_cleaner,cleaner_state)
            else:
                continue

            rez = RobotCommand(input_state=cleaner_state,command='RESULT')
            self.out_queue.put(rez)
            self.queue.task_done()

def command_to_queue(command):
    queue.put(command)
    chunk = out_queue.get()
    out_queue.task_done()
    return chunk

num_workers = 5

for i in range(num_workers):
    t = ThreadRobo(queue, out_queue)
    t.setDaemon(True)
    t.start()
```

Клиентская часть:

```
import pure_robot
from cleaner_api import RobotCommand, command_to_queue

c = RobotCommand(input_state=pure_robot.RobotState(0.0, 0.0, 0, pure_robot.WATER), 
                                                     command='move 100')
c = command_to_queue(c)
c.command = 'turn -90'
c = command_to_queue(c)
c.command = 'set soap'
c = command_to_queue(c)
c.command = 'start'
c = command_to_queue(c)
c.command = 'move 50'
c = command_to_queue(c)
c.command = 'stop'
c = command_to_queue(c)

for i in range(1000):
    c.command = 'turn -90'
    c = command_to_queue(c)

print (c.state.x)
```

Нужные определения размещены по модулям не самым оптимальным образом исключительно для наглядности и краткости примера.

Сохраните пока эту страничку -- например, откройте последующий комментарий к этому коду в отдельной вкладке.


### Stateless-архитектура

Вся внутренняя "кухня" работает с единым типом  **RobotCommand** , определяющим сообщение, находящееся в очереди и исполняемое агентом. В этом классе хранится исходное (текущее) состояние робота и команда на его изменение.

Отмечу, что модуль pure_robot.py из предыдущих примеров -- ключевая библиотека логики в формате чистых функций, перекочевала в данную новую версию системы без каких-либо изменений. Это отличный пример практичности функционального подхода.

В Python имеется стандартный класс Queue, который позволяет организовать мультитредовую асинхронную обработку очереди.
В нашем примере будут две очереди:

- первая входная, куда серверные обработчики клиентских запросов на выполнение команд роботу будут складывать эти запросы, и
- вторая выходная, которую сервер непрерывно опрашивает и при появлении ответа сразу передаёт его обратно соответствующему клиенту. Мы намеренно не касаемся технических деталей идентификации связи ответа и клиента; это достаточно прозрачно реализуется добавлением поля - уникального идентификатора в класс RobotCommand.

Код

```
num_workers = 5
for i in range(num_workers):
    t = ThreadRobo(queue, out_queue)
    t.setDaemon(True)
    t.start()
```

подразумевается, инициализируется сервером в момент выполнения. Мы задаём в константе num_workers количество воркеров, которые в параллельном многопоточном режиме ожидают появления запросов во входной очереди, тем самым регулируется горизонтальная мощность нашей серверной части.Класс **ThreadRobo** задаёт структуру воркера. В бесконечном цикле он выбирает некоторый доступный запрос из очереди (если очередь пуста, ожидание входного запроса не нагружает процессор), далее с помощью функциональной библиотеки выполняет обработку, после чего возвращает результат в выходную очередь, информируя входной поток о завершении обработки исходного сообщения.

Взаимодействие с клиентской частью происходит через функцию  **command_to_queue** . Она помещает входной запрос в очередь, ожидает его обработки, помечает обработку выполненной, после чего возвращает результат клиенту. Эта функция конечно условна -- в реальной системе вместо одной такой функции будут две. Первая поместит запрос в очередь, записав в него идентификатор клиентской сессии, а вторая, получив из выходной очереди результат, по сохранённому в нём идентификатору отправит ответ соответствующему клиенту.

Клиентская часть совсем прозрачна. Всё взаимодействие умещается фактически в две инструкции -- формирование запроса и вызов command_to_queue.

Для проверки эффективности нашей мультиагентной системы заставим робот вращаться на месте подачей тысячи соответствующих команд: можно измерить время обработки на сервере и распределение быстро поступающих запросов воркерам.


### Stateless-архитектура

**Плюсы.**

Очень хорошо удалось выделить и организовать обработку мутабельных данных -- они фактически нигде не "светятся". В серверной части за счёт организации очереди сообщений практически нету явных узких мест.

Класс RobotCommand -- это по сути определение некоего протокола, который позволяет избавиться от завязок на конкретную реализацию сервера.

Функционально ядро остаётся автономным и неизменяемым.

Серверная часть полностью асинхронна.

Система хорошо масштабируется горизонтально -- при росте количества запросов мы просто наращиваем число воркеров, которые могут быть распределены внутри корпоративной сети.

**Минусы.**

В общем случае масштабирование на основе горизонтального списка агентов требует всего классического стека серверной highload-инфраструктуры: балансировщики нагрузки, супервизоры, анализаторы состояния сервера, мониторы ресурсов и т. д.

В некотором смысле серверные агенты остаются завязаны на состояния, пусть и не прикладные, а системные (порядок обработки заявок из очередей, статус заявок, ...). По этой причине соответствующие части кода сложны для понимания и тестирования, а когда логика "протокола" усложняется, возникают целые сети агентов со сложными взаимосвязями друга с другом (например, вследствие длинной цепочки обработки заявок). В результате сложность, которую мы существенно понизили функциональным ядром, "вылазит" совсем в других местах, и бороться с ней тут ещё более трудоёмко.

Однако в случае достаточно простого "протокола" данная модель показывает отличную производительность и масштабируемость (десятки тысяч запросов в секунду даже в самом простом варианте).

Далее мы рассмотрим, как нам разделять интерфейс и реализацию -- делать реализации сменяемыми, потому что пока мы напрямую завязаны на код конкретного класса CleanerApi.
