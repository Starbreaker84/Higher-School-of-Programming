## Три правила простого проектного дизайна

Как насчёт того, чтобы защитить от ошибок дизайн (в архитектурном смысле) вашего проекта? Как сделать его более удобным для развития и сопровождения?

Процитирую книгу  **"Дизайн привычных вещей" Дональда Нормана** :

*"Порочный круг начинается так: когда у вас что-то не получается, вы думаете, что это ваша вина. Поэтому вы считаете, что не можете справиться с этой задачей. В результате в следующий раз, когда вам придется выполнять подобное задание, вы уже полагаете, что не сможете, и даже не пытаетесь. В результате у вас ничего не получается, как вы и думали. Вы попали в ловушку самоисполняющегося пророчества".*

Рекомендация Нормана такая:

*" **Переложите вину на машины и их конструкцию** . Долг машин и тех, кто их проектирует -- прежде всего понимать нужды людей".*

В тему ещё можно упомянуть  **выученную беспомощность по Селигману** .

Да, я постоянно призываю брать на себя максимум ответственности, в том числе и за то, что нам неподвластно :) В данном случае как раз имею в виду, что, допустим, вы миддл или сеньор, который спроектировал некоторую (под)систему, и когда джуниор, развивая эту систему, делает ошибку, которую ранее уже делали другие разработчики, то это означает, что виноват не джуниор, а вы как проектировщик:  **ошибки разработчиков почти всегда есть следствие плохого дизайна системы** .

Классическое (ошибочное) решение (ведущее к выученной беспомощности) -- это указать джуниору на ошибку, задокументировать её как "типичную", и в следующий раз тыкать кодировщиков в эту документацию. Именно так и формируется порочный круг.

Правильно так: пересмотреть дизайн системы, и перепроектировать его так, чтобы подобные ошибки более не могли возникать.


### Три правила простого проектного дизайна

Например, разрабатывается шахматная программа. Есть класс Game с методом Move(int color). Код, который обычно джуниор пишет "в лоб", выглядит примерно так:

```
Game game = new Game();
...
game.Move(WHITE);
game.Move(BLACK);
```

Хороший миддл вполне может потребовать, чтобы метод Move(int color) был декомпозирован на два явных: MoveWhite() и MoveBlack(), так как в игре явно присутствуют ровно два игровых цвета, качественно отличающихся друг от друга (белые всегда ходят первыми, чёрные всегда ходят вторыми). Мы избавляемся от ненужного параметра, а код становится более наглядным и менее хрупким.

Но пока это косметическая правка, потому что джуниор случайно может написать

```
game.MoveWhite();
game.MoveWhite();
game.MoveBlack();
game.MoveBlack();
```

Программа работает нормально, а выловить такую логическую ошибку будет не очень легко.


### Три правила простого проектного дизайна

Сеньор советует применить такую тактику: класс Game отслеживает внутри себя, какой цвет ходил последним, и если метод MoveWhite() или MoveBlack() вызывается два раза подряд, то он генерирует исключение. Как минимум, такой подход существенно повышает вероятность того, что ошибка наподобие вышеприведённой будет отловлена юнит-тестами. Однако одновременно повышается и вероятность того, что программа будет периодически вылетать во время работы (хотя непонятно, что хуже: такой вылет, или логическая ошибка "два раза походить одним цветом" :).

К делу подключается проектировщик. Его рекомендация -- вообще избавиться от явных ходов за конкретный цвет, инкапсулировав текущее состояние (цвет ходящей стороны) внутрь класса Game. Тогда получится нечто вроде

```
Game game = new Game();
game.NewGame(); // новая игра
game.Move(); // ходят белые
game.Move(); // ходят чёрные
...
```

Такая схема уже существенно лучше защищена от ошибок кодировщика.


### Три правила простого проектного дизайна

Однако в реальной шахматной партии у нас имеются не просто белые и чёрные, а конкретные игроки (белковые или AI). Поэтому схема

```
Game game = new Game();
game.NewGame(); // новая игра
game.Move();
```

вылетает с исключением в Move() -- оказывается, что атрибут Player для белой стороны не инициализирован.

Поэтому конструктор Game по умолчанию лучше как-то запретить, а игроков указывать явно:

```
Game game = new Game(PlayerPetya, PlayerRybkaBot);
```


### Три правила простого проектного дизайна

Другая распространённая джуниорская ошибка -- использовать базовые типы там, где они плохо подходят (т.н. антипаттерн Primitive Obsession, одержимость примитивами). Например, конкретный ход может выполняться так:

```
game.Move("e2", "e4");
```

Это и есть типичная проблема дизайна. Ведь ничто не мешает вызывать

```
game.Move("e16", "x42");
```

Как обходить такие моменты, объясняю на курсе "Быстрая прокачка в ООП", а общий принцип такой, что под каждую смысловую сущность в проекте должен создаваться отдельный тип данных. В данном случае это может быть просто перечисление Cell { a1, a2, ..., h7, h8 }, т.к. клетки шахматной доски заведомо фиксированы.


### Три правила простого проектного дизайна

Разработчики, использующие систему, которая плохо спроектирована (другими разработчиками), склонны винить в проектных сложностях себя, а не эту систему, которую они используют. Однако это далеко не всегда верно, хотя подобное случается не только с программистами. Дональд Норман приводит много примеров подобных проблем у пользователей физических рукотворных объектов, и показывает выход: вам как прикладному разработчику важно прежде всего понять, что очень часто виновата именно система, которую вы используете, именно "внешняя" система накладывает множество ненужных ограничений и принуждает к кривому стилю. Такое постоянно встречается при использовании популярных веб-фреймворков например.

Главное, что вам самому надо проектировать программное обеспечение с учетом его надёжности и отказоустойчивости. Выше мы рассмотрели три простых способа улучшить дизайн класса, чтобы он был более защищен от ошибок:
--  **-избавляться от точек генерации исключений** , запрещая соответствующее ошибочное поведение на уровне интерфейса класса;
--  **отказаться от дефолтных конструкторов без параметров** , и передавать конструктору обязательные аргументы;
--  **избегать увлечения примитивными типами данных** , разрабатывать прикладную систему типов, на смысловом уровне моделирующую предметную область (используйте типы данных Клетка и Фигура, а не строки или числа).

В результате код получается проще для понимания, использования и развития, и в то же время позволяет избежать распространённых ошибок.
