### Непонятно, какие тесты писать под планируемые изменения

49. Проблема. Если в проекте применяется ручное тестирование вносимых изменений (в смысле проверок с помощью пользовательского UI по типовым скриптам и use cases, например), то почти всегда оказывается, что оно столь трудоёмкое, что либо команда начинает сильно отставать от графика, либо просто отказывается от таких тестов.

Решение. Напрашивается покрыть области планируемых изменений юнит-тестами, чтобы обеспечить сохранность поведения после внесения изменений. Такие тесты называются  **регрессионные** , и нужны они не столько для того, чтобы проверить корректность кода, сколько для страховочного сохранения правильного поведения системы, чтобы оно не поломалось после очередных правок.


### Непонятно, какие тесты писать под планируемые изменения

50. Проблема. Непонятно, в чём отличие между регрессионными и модульными тестами.

Решение. Регрессионные тесты обычно проверяют не конкретные методы, а поведение системы по некоторым типичным пользовательским сценариям, use cases, которые удаётся смоделировать программно (например, через серию последовательных вызовов API в одном регрессионном тесте). Тут может помочь документация, но она практически всегда в унаследованной системе устаревшая. Кроме того, намного важнее, что система делает на самом деле, и к чему пользователи уже привыкли, а не, что она должна делать, как когда-то планировалось.

Регрессионные тесты описывают конкретное поведение фрагмента кода с точки зрения его внешних пользователей (других программистов, программ-клиентов, ...), и по сути, документируют её конкретное типичное поведение. С их помощью мы не пытаемся немедленно обнаружить ошибки, а лишь добавляем механизм для обнаружения ошибок в дальнейшем, чтобы вовремя выявить любые отличия от текущего поведения системы, которое считается условно правильным, и которое надо сохранять.

Регрессионные тесты проверяют не множество специальных условий, а только "присутствие" в коде конкретного поведения. По его нормальному выполнению считаем, что после реорганизации кода корректность соответствующей логики сохранилась.


### Непонятно, какие тесты писать под планируемые изменения (задания)

======= 42. Регрессионные нужны для того, чтобы ...

[ ] проверить корректность кода

[ 1] сохранить правильное поведение

======= 43. Регрессионные тесты ...

[] описывают конкретное поведение с точки зрения пользователей системы

[1 ] документируют конкретное типичное поведение системы
