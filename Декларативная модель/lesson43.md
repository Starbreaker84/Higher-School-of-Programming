### 46. Правильная организация программы

Что такое правильная организация программы? Можно написать программу как один большой монолит, но по мере роста объёма он начинает стремительно запутываться. Лучший способ борьбы с растущей сложностью –  **разделить (декомпозировать) программу на логические единицы** , каждая из которых реализует набор операций, каким-то образом связанный в одно целое (хороший подход – через абстрактные типы данных).

Каждая логическая единица имеет две части:  **интерфейс и реализацию** . Только один интерфейс «виден» снаружи логического блока, а реализации могут свободно заменяться.

При таком подходе  **программа представляется направленным графом без циклов** , где ребро между двумя логическими единицами означает, что первая нуждается во второй для своей реализации. В мэйнстриме такие логические единицы называют "модули" или "компоненты", хотя точных определений этих слов обычно не даётся. На данном курсе мы выясняем, какие тут существуют основные понятия и как их можно применять для создания небольших декларативных программ. Аналогичная тема в разрезе programming in large рассматривается на следующих курсах.

### Модули и функторы

Мы называем **модулем** часть программы, которая группирует связанные по смыслу операции в одну сущность, которая имеет интерфейс и реализацию. В декларативной модели модули могут быть внедрены простым способом:

- Интерфейс модуля представляет собой запись, которая группирует связанные сущности (как правило, процедуры и функции, но в целом разрешено всё, включая классы, объекты, и тому подобное);
- Реализация модуля представляет собой набор языковых сущностей, которые доступны через интерфейс, а всё остальное снаружи недоступно. Реализация скрыта с помощью лексической видимости.

Спецификации модулей будем рассматривать как сущности, отличные от самих модулей. **Спецификация модуля** -- это вид шаблона, который создает новый модуль (как класс «создаёт» объект в ООП). Спецификация модуля иногда называется программным компонентом, но к сожалению, термин " программный компонент" широко используется в программировании для обозначения множества самых разнообразных понятий. Поэтому спецификацию модуля мы будем называть функтор.
**Функтор** – это функция, получающая на вход набор модулей, которые требуются для создания нового модуля, и возвращает новый созданный модуль.

Строго говоря, функтор получает на вход интерфейсы модулей как аргументы, создаёт новый модуль и возвращает его интерфейс.

Функтор состоит из трёх частей:

- **импорт** , задающий перечень требуемых модулей;
- **экспорт** , определяющий интерфейс итогового модуля;
- **реализация** , включающая код инициализации функтора.

В терминах программной инженерии, **программный компонент – это элемент для независимого развёртывания** (не требующий ничего дополнительного для своей установки и использования, кроме, возможно, перечня стандартных библиотек). Главное, что программный компонент не имеет внутреннего состояния, поэтому хорошо укладывается в декларативную модель.

Функторы можно считать одним из видов программных компонентов; тогда  **модулем будет экземпляр программного компонента – результат инсталляции функтора в конкретном рабочем окружении** . Такое окружение включает множество модулей, каждый из которых может иметь внутреннее состояние.

Приложение называется  **автономным (standalone)** , если оно не подразумевает активного взаимодействия с пользователем, как правило, через GUI. Оно состоит из главного функтора, который вычисляется при старте приложения и импортирует нужные модули, что в свою очередь приводит к вызову других функторов.

Вычисление, или «инсталляция» функтора выполняется в три шага.
Во-первых, идентифицируются модули, которые будут требоваться для его работы.
Во-вторых, выполняется код инициализации.
В-третьих, загружаются модули, которые непосредственно востребованы во время работы.
Вычисление не главных функторов может происходить в самое разное время работы программы, непосредственно в те моменты, когда в коде запрашивается некоторый ресурс из пока невычисленного функтора.
Это так называемое  **динамическое связывание** , в противоположность  **статическому связыванию** , когда все модули загружаются сразу в момент старта приложения.
В любой момент множество инсталлированных модулей называется  **рабочим модульным окружением** .


### Модули и функторы (задания)

======= 91. Модуль -- это часть программы, которая группирует ...

[ ]связанные операции в одну сущность, которая имеет интерфейс и реализацию

[ ]набор языковых сущностей, которые доступны через интерфейс

[ ]связанные сущности в одно

======= 92. Спецификация модуля -- это ...

[ ]программный компонент

[ ]шаблон, который "создаёт" новый модуль

[ ]design программной системы

======= 93. Функтор -- это ...

[ ]модуль, инициализирующий другие модули

[ ]автономное приложение с динамическим связыванием

[ ]функция, получающая на вход интерфейсы модулей, и создающая новый модуль
