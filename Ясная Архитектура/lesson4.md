### 3. Объектно-ориентированный стиль: возможное решение

```
import math

# взаимодействие с роботом вынесено в отдельную функцию
def transfer_to_cleaner(message):
    print (message)

# класс Чистильщик
class Cleaner:

    # режимы работы устройства очистки
    WATER = 1 # полив водой
    SOAP  = 2 # полив мыльной пеной
    BRUSH = 3 # чистка щётками

    # конструктор 
    def __init__(self, transfer):
        self.x = 0.0
        self.y = 0.0
        self.angle = 0
        self.state = self.WATER
        self.transfer = transfer 

    # перемещение
    def move(self,dist):
        angle_rads = self.angle * (math.pi/180.0)
        self.x += dist * math.cos(angle_rads)
        self.y += dist * math.sin(angle_rads)
        self.transfer(('POS(',self.x,',',self.y,')'))

    # поворот
    def turn(self,turn_angle):
        self.angle += turn_angle
        self.transfer(('ANGLE',self.angle))

    # установка режима работы
    def set_state(self,new_state):
        if new_state=='water':
            self.state = self.WATER  
        elif new_state=='soap':
            self.state = self.SOAP
        elif new_state=='brush':
            self.state = self.BRUSH
        self.transfer(('STATE',self.state))

    # начало чистки
    def start(self):
        self.transfer(('START WITH',self.state))

    # конец чистки   
    def stop(self):
        self.transfer(('STOP',))

    # интерпретация набора команд
    def make(self,code):
        for command in code:
            cmd = command.split(' ')
            if cmd[0]=='move':
                self.move(int(cmd[1])) 
            elif cmd[0]=='turn':
                self.turn(int(cmd[1]))       
            elif cmd[0]=='set':
                self.set_state(cmd[1]) 
            elif cmd[0]=='start':
                self.start()
            elif cmd[0]=='stop':
                self.stop()
```

```
# главная программа
cleaner = Cleaner(transfer_to_cleaner)
cleaner.make((
    'move 100',
    'turn -90',
    'set soap',
    'start',
    'move 50',
    'stop'
    ))
```

Первое значимое изменение -- это  **инкапсуляция автономных процедур и глобальных значений внутрь класса** . Мы получаем объект, который можно адресовать как целостную логическую единицу, и который скрывает внутри себя все особенности реализации. Пользователю по сути достаточно знать лишь форму вызова конструктора и название одного метода make(), которому на вход передаётся программа управления роботом.

Второе изменение --  **передача интерфейсной функции управления роботом transfer_to_cleaner как параметра в конструктор** . У нас может быть множество интерфейсов к роботам разных типов, но всегда ли имеет смысл прописывать в коде класса явный вызов transfer_to_cleaner? Как минимум, придётся строить иерархию классов и помнить названия всех моделей роботов, которых могут быть сотни.

Что лучше: переопределять transfer_to_cleaner для каждого класса под конкретную модель робота, или иметь компактную библиотеку разных вариантов реализаций transfer_to_cleaner?
Однозначного ответа нет. Классический подход ООП более правильный (строже и нагляднее), но и более многословный и трудоёмкий.

В данном случае, когда проект относительно небольшой, вариант с автономной функцией выглядит предпочтительнее. При появлении, например, интерфейса управления гигантским боевым шагающим роботом, где командами set/stop будет соответствовать открытие и прекращение огня, достаточно будет просто создать новый объект, передав ему новый интерфейс-параметр transfer_to_transformer, не внося никаких других изменений в код.

**Плюсы.**

Удобно работать с классом как единой сущностью, объединяющей данные и методы, их обрабатывающие.

Код весьма нагляден, реализацию можно вести сверху вниз, начиная с описания структуры классов, затем переходить к интерфейсу с набором методов, и лишь потом приступать к кодированию.

**Минусы.**

Состояние объекта по-прежнему хранится в мутабельных полях, только теперь они локальные/внутренние. Мы упростили процесс проектирования, существенно снизив его сложность, однако он по-прежнему имеет выраженные ограничения, так как проблемы с изменчивостью данных никуда не исчезли, а лишь завуалировались.

---

Напишите рефлексию по своему решению в стиле ООП, его плюсы и минусы.
Ссылку на гитхаб введите в форму ниже:
