## Двунаправленный связный список

Следующий тип для рассмотрения -- это **двунаправленный связный список**. Данный случай будет очень наглядным, он отлично продемонстрирует типичные проблемы проектирования классов, которые не решить "естественным" путём с позиций здравого смысла, или как минимум, без подходящих специфических механизмов самого языка программирования, на которые, однако, полагаться ещё хуже. Ведь мы ориентируемся на минималистичные описания АТД и соответствующие достаточно минималистичные реализации, и какие-то нестандартные технические возможности уже выходят за рамки вычислительной модели ООП, существенно ослабляя проектный потенциал.

### АТД TwoWayList

На первый взгляд, достаточно в АТД LinkedList добавить всего одну новую операцию **left (сдвинуть курсор на один узел влево)**, и мы получим готовый АТД TwoWayList (двунаправленный список). И это действительно так. Но, как уже говорилось, **при проектировании очень важно делать акцент на возможности повторного использования всех компонентов**, и в частности, на оформление логически связанных классов в автономное и самостоятельное подобие стандартных библиотек. Поэтому в данном случае напрашивается TwoWayList оформить, например, как наследника класса LinkedList, так как у них явно очень много общего. Проектирование с использованием технологий наследования будет рассмотрено на отдельном курсе, но даже в данном совсем простом примере мы сразу сталкиваемся с принципиальными проблемами.

1) Можно попробовать представить **TwoWayList как наследника LinkedList**, и вроде бы в TwoWayList достаточно будет добавить всего один новый метод left(). Однако при этом потребуется переопределить и большинство методов родительского класса LinkedList, так как их логика уже принципиально отличается от логики работы однонаправленного списка (надо корректировать связи между узлами уже в две стороны). В результате мы не выигрываем, а наоборот проигрываем, только усложняя систему классов. И вдобавок, при любом изменении логики работы со списками придётся вносить почти идентичные правки в несколько классов.
2) Другой вариант -- **создать абстрактный родительский класс с общими методами, которые переопределять в классах-наследниках**. Однако предыдущая проблема остаётся -- многие родительские методы придётся определять с нуля в каждом классе, причём по своей логике они будут сильно похожи друг на друга, или даже идентичны. А это верный признак плохого проектирования.
3) Можно также наоборот **унаследоватьуже сам класс LinkedList от класса TwoWayList**, который становится родительским: тогда мы сохраняем всю родительскую логику, поддерживающую перемещение по списку вправо, и всё, что по сути остаётся сделать в LinkedList -- это "всего лишь" скрыть родительский метод left(). Ничего страшного, что методы содержат код работы с двунаправленными связями, для пользователя это незаметно. Ради проектной простоты этой небольшой дополнительной нагрузкой, как правило, почти всегда можно пожертвовать.

И тут возникает другая проблема: популярные языки программирования такую возможность скрытия родительских методов не допускают, и этому есть принципиальная причина. Дело в том, что нередко возникает соблазн совершенно непродуманно применять наследование, примерно как в наших попытках наследовать друг от друга классы, не особо для этого предназначенные. Например, ради какой-то отдельной функциональности можно попробовать унаследовать класс Автомобиль от класса Двигатель -- тут путаются два классических вида отношений "является" и "содержит", не говоря уже о том, что у автомобиля например может быть два двигателя.

### Спасение в частично реализованных классах

И вот теперь, выяснив потенциальные подводные камни каждого из вариантов, мы приходим к достаточно неплохому и теперь уже напрашивающемуся решению: **реализовать родительский класс, например, ParentList -- как частично реализованный двунаправленный список без метода left()**. В таком случае LinkedList просто будет его прямым наследником, вообще никак родительскую функциональность не расширяющим. И TwoWayList также унаследует все возможности ParentList, а его непосредственная реализация будет представлять всего лишь один новый метод left() (и, вероятно, вспомогательный метод запроса статуса его работы). Это уже упоминавшийся сильный подход частично реализованных классов (хотя в данном случае родительский класс реализован полностью).

Пример с классами LinkedList и TwoWayList -- хорошая иллюстрация потенциальной проектной сложности даже в системе из 2-3 классов, а если их насчитываются сотни или тысячи? Поэтому так важно на всех этапах проектирования, включая проектирование самих классов, тщательно продумывать все нюансы на уровне АТД -- понимая и учитывая, что с большой вероятностью в будущем многое всё равно придётся дорабатывать.

**Задание 3**

Объедините АТД LinkedList и TwoWayList в иерархию, как только что было предложено, и дополните реализацией.
