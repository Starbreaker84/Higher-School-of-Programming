## Шесть ключевых ошибок оптимизации

при написании хорошего кода

Шесть ключевых моментов, которыми вам не нужно заниматься во время написания кода, и  **отказ от которых сэкономит вам уйму времени** .
"Преждевременная оптимизация -- корень всех зол" (с) Кнут (но это не точно) и, в частности, одна из основных проблем плохо написанного кода.

---

Преждевременная оптимизация -- одна из основных проблем плохо написанного кода. Но что же это такое?

**Преждевременная оптимизация -- это трата ваших ценных ресурсов, таких как время, усилия, строки кода или даже простота и ясность кода, на ненужные оптимизации** .

Нет ничего плохого в оптимизированном коде.

Проблема в том, что бесплатного обеда не существует. Если вы думаете, что оптимизируете фрагменты кода, то на самом деле вы жертвуете одной переменной характеристикой проекта (например, сложностью) ради другой (например, производительности).

Иногда можно получить простой код, который также оказывается более производительным и лёгким для чтения -- но вы должны потратить приличное время, чтобы добраться до этого состояния!

Иногда вы преждевременно пишете много дополнительных строк кода, оптимизируя алгоритм ради повышения скорости работы.

Например, вы можете добавить на 30% больше строк кода, чтобы увеличить скорость выполнения на 0.1%. Подобные компромиссы испортят весь ваш процесс разработки, если допускать их постоянно.

---

**Шесть ключевых моментов, которыми вам не нужно заниматься во время написания кода и отказ от которых сэкономит вам уйму времени.**

### 1) Предварительная оптимизация функций.

Во-первых, вы можете тратить много времени на  **оптимизацию функции или фрагмента кода** , который вы почему-то не можете оставить неоптимизированным. Вы утверждаете, что использование простого метода -- плохой стиль программирования, и для решения этой проблемы следует использовать более эффективные структуры данных или алгоритмы. Итак, вы переключаетесь в обучающий режим, находите и изучаете всё более и более эффективные алгоритмы. Наконец, вы находите что-то близкое к O(N), радуетесь своей крутизне -- но на то, чтобы соответствующая часть кода заработала корректно после смены алгоритма, у вас уходит несколько часов. Оптимизация была преждевременной, потому что, как оказалось в итоге, ваша функция выполняется крайне редко, и даже её работа за O(N) не приводит к заметному повышению производительности.

### 2) Предварительная оптимизация пользовательских фич.

Во-вторых, вы напихиваете **побольше "полезных" функций** в свой программный продукт, потому что верите, что они понадобятся пользователям, фактически решая за них. Вы оптимизируете продукт в соответствии с ожидаемыми вами, но ничем не подтверждёнными потребностями пользователей. Вместо скорейшей разработки минимально жизнеспособного продукта (MVP), который делает именно и только то, что требуется, вы добавляете все больше и больше фич, которые, как вы ожидаете, также будут необходимы в дополнение к основным. Позже вы обнаруживаете, что ваши пользователи никогда не используют эти возможности. Но такая предварительная оптимизация значительно замедлила цикл разработки продукта и снизила скорость понимания его пользователями из-за усложнения.

### 3) Предварительная оптимизация на этапе планирования.

В-третьих, вы преждевременно занимаетесь оптимизацией  **на фазе планирования работ** , пытаясь заранее найти решения всевозможных проблем, которые только могут возникнуть (точнее, которые только вы можете придумать). Несмотря на то, что отказ от планирования сам по себе обходится обычно очень дорого, многие разработчики вообще никогда не прекращают планирование, которое может быть столь же дорогостоящим! Только теперь затратами становятся альтернативные издержки на перестраховку.

Выпуск программного продукта в эксплуатацию подразумевает предоставление чего-то ценного реальным пользователям, даже если это ещё не совершенно. Вам нужна быстрая обратная связь с пользователями и тестирование реальности ещё до того, как вы поймете, какие проблемы ударят по вашему проекту сильнее всего. Планирование помогает избежать многих подводных камней, но если вы из тех людей, которые не склонны к активному взаимодействию с пользователями, все ваше планирование превратится в пыль на фоне реальных проблем, которые обычно неожиданны и непредсказуемы.

### 4) Предварительная оптимизация масштабируемости.

В-четвертых, вы преждевременно оптимизируете **масштабируемость** вашего приложения. Ожидая миллионы посетителей, вы проектируете распределенную архитектуру с использованием Kubernetes, которая при необходимости будет динамически добавлять виртуальные машины для обработки пиковых нагрузок. Я сам участвовал лет 10 назад в подобном проекте, который закрылся именно из-за того, что тимлид решил, что надо сразу создавать систему на сотни тысяч пользователей, и полгода такой пустой разработки обошлись команде катастрофически.

Распределенные системы сложны и подвержены ошибкам, и на то, чтобы заставить вашу систему работать хотя бы близко к планируемым характеристикам, уходят многие месяцы. Еще хуже, я видел вживую, когда подобная оптимизация не повышала, а снижала масштабируемость системы -- из-за возросших накладных расходов на связь и синхронизацию данных. Как проектировать такие системы правильно, я поясняю на курсах по highload-системам.

**Масштабируемые распределенные системы всегда обходятся дорого** . Вы уверены, что должны заранее платить за это всё? Какой смысл иметь возможность масштабироваться на миллионы пользователей, если вы не нашли и не обслужили даже одного своего самого первого пользователя?

### 5) Предварительная оптимизация тестирования.

В-пятых, вы свято верите в разработку, основанную на тестировании (TDD), и настаиваете на  **100% покрытии тестами всего кода** , пусть даже некоторые функции не поддаются юнит-тестам из-за наличия недетерминированных данных (например, функции обрабатывают текстовые сообщения, вводимые пользователями). Несмотря на это, вы преждевременно оптимизируете проект под идеальное покрытие юнит-тестами, что замедляет цикл разработки, внося в проект излишнюю сложность.

### 6) Предварительная оптимизация объектной архитектуры.

В-шестых, вы придерживаетесь объектной ориентации и настаиваете на  **моделировании мира с использованием сложной детальной иерархии классов** . Например, вы пишете небольшую компьютерную игру про автогонки. Вы создаете иерархию классов, в которой класс Zaporogets наследуется от класса Car, который в свою очередь наследуется от более универсального класса Vehicle. Ну а вдруг, думаете вы, через несколько лет я будут делать игру про мотогонки? Во многих случаях такие длинные иерархии типов добавляют ненужную сложность, и их вполне можно избежать. Вы преждевременно оптимизировали свой код для моделирования мира с гораздо большей детализацией, чем требуется.

---

В результате усложнения кода по какому-нибудь (или всем) из шести пунктов он стал более производительным, но какой ценой? Дополнительная сложность не даёт обычно значимого выигрыша производительности для небольших и средних приложений, но она делает их более запутанными и снижает удобство сопровождения. Никто никогда не заметит выигрыша в производительности многопользовательской игры на 5-10 процентов например, а вы можете потратить на это месяц труда.

---

Что вы можете сделать прямо сейчас?

**Начните использовать библиотеки вместо того, чтобы писать соответствующие функции и логику с нуля.**

**Удалите большие блоки кода с преждевременной оптимизацией.**

**Удалите блоки кода, которые вы прокомментировали с пометкой "на возможное использование в будущем".**

**Отрефакторите имена переменных, функций, классов и методов -- с чётким прицелом на текущие задачи проекта.**

**Структурируйте код в классах и логических единицах, как рекомендовалось на курсах по ООАП.**
