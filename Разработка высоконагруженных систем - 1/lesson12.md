## Часть 3. Подсистемы хранения и обработки данных

База данных должна решать две задачи: **сохранять данные** при получении от клиента и позднее **предоставлять данные** клиенту по запросу.

Должны ли волновать разработчика приложений внутренние нюансы того, как СУБД хранит данные, и как она их находит?

Вряд ли вы собираетесь реализовать собственную подсистему хранения данных с нуля -- но  **вам определенно нужно выбрать из множества существующих подсистем хранения подсистему, хорошо подходящую именно для вашего проекта** .

Чтобы настроить СУБД на оптимальную работу при вашей нагрузке, желательно иметь хотя бы приблизительное представление о том,  **каковы внутренние механизмы функционирования подсистемы хранения** . Так, существуют немалые отличия между подсистемами хранения, оптимизированными на транзакционные нагрузки, и оптимизированными для задач аналитики.


## Базовые структуры данных в СУБД

### 12. Ключ-значение

Модель данных **ключ-значение** очень проста и легка в эксплуатации. БД хранит **уникальные (как правило) ключи** (в простейшем случае, целочисленные идентификаторы), **каждому из которых соответствует некоторое значение** (в общем случае, типы этих значений могут различаться).

Простейшая форма реализации модели ключ-значение – это  **обычный текстовый файл** . В каждой строчке сперва записывается ключ, а затем – значение, сериализованное в текстовый вид. Производительность функции добавления новой пары ключ-значение в таком случае будет высокой, если ключи всегда генерируются новыми: обновления существующих записей (пар ключ-значение) не допускаются, и в качестве ключа выступает например текущее время. Тогда достаточно просто выполнить запись строки в конец файла.

В немалом числе СУБД используется очень похожий механизм, называемый  **журналирование** : имеется (текстовый) файл, называемый  **журнал** , и предназначен он только для добавления данных в его конец. На практике конечно журналирование подразумевает весьма много забот (управление конкурентным доступом к журналу, контроль пространства на диске -- чтобы журнал не рос до бесконечности, создание бэкапов, обработка ошибок и сбойных записей), но основной принцип остается тем же --  **журналы исключительно удобны** .

Как избежать ситуации исчерпания места на диске? Хорошее решение --  **разбить журнал на сегменты определенного размера** , закрывая файл сегмента при достижении им определенного размера, и записывая последующие данные уже в новый файл. Затем можно выполнить **уплотнение (compaction) этих сегментов** -- отбрасывание дублирующихся ключей из журнала и сохранение только последней версии данных для каждого ключа.

Запомните эту механику сегментов как следует: на ней строятся многие современные технологии журналирования.


### Индексы

С другой стороны, производительность функции считывания значения по ключу будет ужасна в случае большого количества записей в журнал. Каждый раз, когда нужно найти ключ, придётся просматривать всю «базу» (например, файл) от начала до конца, выискивая вхождение нужного ключа. Сложность поиска мы получим порядка O(n).

Для эффективного поиска значения конкретного ключа в БД необходима другая структура данных:  **индекс** . Общая идея индекса заключается в дополнительном хранении определенных метаданных -- своеобразных указателей, помогающих быстро найти нужные данные.

Многие СУБД позволяют добавлять и удалять индексы без какого-либо воздействия на содержимое базы –  **модификация индексов влияет только на производительность запросов** . Но поддержка дополнительных структур данных влечёт рост накладных расходов, особенно при записи на диск. В таком случае превзойти производительность простого дописывания данных в конец файла сложно, поскольку это простейшая, атомарная из всех возможных операций записи. Любые индексы обычно замедляют запись в базу, так как индекс тоже приходится обновлять всякий раз при записи данных на диск.

Это важный компромисс в системах хранения данных:  **хорошо подобранные индексы ускоряют запросы на чтение, но замедляют запись данных** . Поэтому СУБД обычно не индексируют по умолчанию всё, что можно, а предлагают разработчику выбирать индексы вручную, на основе знания паттернов запросов, типичных для приложения.


### Хэш-индексы

В языках программирования аналог модели «ключ-значение» -- это структура данных «словарь» (dict, map, …). Словари реализуются обычно в виде хэш-карты (hash map) или хэш-таблицы (hash table). Эти структуры данных мы проходили на курсах по алгоритмам. И раз уж хэш-карты используются для структур данных в памяти, то почему бы не задействовать их для индексации данных на диске?

Предположим, что хранилище работает только путем добавления данных в конец файла-журнала. Тогда простейшая стратегия индексации такова: хранить в оперативной памяти хэш-карту, в которой каждому ключу поставлено в соответствие физическое смещение (или относительный адрес) в файле данных -- место, где находится значение. Как правило, операции работы с файлами во всех ОС допускают операцию позиционирования курсора внутри файла с точностью до байта (операция seek).

Всякий раз при добавлении в файл новой пары «ключ — значение» происходит также обновление хэш-карты для отражения в ней адреса только что записанных данных. Причём этот механизм успешно работает как при вставке новых ключей, так и при обновлении значений существующих.

В качестве ключа может выступать, например, URL видео с котиками, а значение -- количество просмотров этого видео, которое увеличивается каждый раз, когда кто-то запрашивает воспроизведение видео. При таком типе нагрузки количество операций записи будет велико, но уникальных ключей при этом будет не слишком много. То есть количество операций записи на один ключ велико, но вполне можно хранить все ключи и значения (счётчики) в оперативной памяти. Эта концепция была реализована, в частности, в так называемых in-memory database, которые целиком (или отдельными крупными блоками) умещаются в оперативной памяти, за счёт чего достигается очень высокая производительность. А для обеспечения их надёжности выполняется регулярный сброс образа из памяти на быстрый диск.

Но хэш-таблица должна помещаться в оперативной памяти, так что если в базе очень много ключей, то ситуация плохая. В принципе, можно поддерживать хэш-карту и на быстром диске, но, к сожалению, добиться в таком случае хорошей её производительности очень непросто.


## Модель данных "ключ-значение" (задания)

======= 35. Сегменты файла-журнала -- это ...

[ ] файлы, свободно открытые для модификации

[1 ] файлы, закрытые для модификации по достижении определённого размера

[ ] "горячие" файлы для записи ключей

[ ] отдельные части внутри одного файла

======= 36. Уплотнение сегмента журнала -- это ...

[ 1] перезапись сегмента с удалением дублирирующихся ключей

[ ] физическое сжатие сегмента

[ ] создание нового чистого сегмента

[ ] удаление сегмента с дублирующимися ключами

======= 37. Каковы плюсы и минусы модели "ключ-значение" в реализации журналирования?

[ 1] быстрое добавление, медленный поиск по ключу

[ ] медленное добавление, медленный поиск по ключу

[ ] медленное добавление, быстрый поиск по ключу

[ ] быстрое добавление, быстрый поиск по ключу

======= 38. Каковы плюсы и минусы индексов?

[ ] быстрое добавление, медленный поиск по ключу

[ ] медленное добавление, медленный поиск по ключу

[ 1] медленное добавление, быстрый поиск по ключу

[ ] быстрое добавление, быстрый поиск по ключу

======= 39. Каковы плюсы и минусы хэш-индексов?

[ ] медленный поиск, надо мало оперативной памяти

[ ] быстрое обновление значений, надо много оперативной памяти

[1] быстрый поиск, надо много оперативной памяти
