## Операции записи и чтения по кворуму

Проблема 48. Мы предполагали, что операция записи успешна, если была обработана хотя бы двумя репликами из трех. Но если вообще только одна реплика из трёх получила данные об этой операции записи?

Решение. При наличии n реплик операция записи считается успешной, если подтверждена w узлами, причем необходимо опросить как минимум r узлов для каждой операции чтения. В рассмотренном примере n = 3, w = 2, r = 2.

Если w + r > n, то считается, что полученное при чтении значение будет актуальным (поскольку хотя бы один из r узлов должен оказаться актуальным). Операции записи и чтения, удовлетворяющие этому соотношению, называются  **операциями чтения и записи по кворуму** .

В Dynamo-подобных СУБД параметры n, w и r обычно можно настраивать. Чаще всего n делают равным нечетному числу (обычно 3 или 5), а w = r = (n + 1) / 2 (округлённому в большую сторону). Однако вполне допустимо настраивать их под конкретный проект. Например, в случае нагрузки, когда операций записи немного, но наличествует большое количество операций чтения, выгоднее задавать w = n и r = 1. Такая схема ускорит операции чтения, но один отказавший узел приведёт к сбою всей системы.

При наличии n реплик и выборе таких w и r, что w + r > n, можно, вообще говоря, ожидать возврата каждой операцией чтения наиболее свежего значения из записанных для данного ключа. Тут необходимо, чтобы множество узлов, в которые записаны данные, и множество узлов, из которых данные читаются, должны пересекаться -- среди читаемых узлов найдётся по крайней мере один узел с актуальным значением.

Когда значения w и r выбираются такими, чтобы составлять большинство (более чем n/2) узлов, это гарантирует, что в системе допускается до n/2 сбойных узлов с соблюдением w + r > n. Кворум не обязательно означает большинство: важен лишь факт пересечения хотя бы в одном узле множества узлов, используемых операциями чтения и записи.

## Операции записи и чтения по кворуму

Проблема 49. В системах репликации без ведущего узла не существует фиксированного порядка применения операций записи, что осложняет мониторинг актуальности. Более того, если база данных использует только разрешение конфликтов при чтении (никакого процесса противодействия энтропии), то не существует универсальной оценки устарелости значения: когда оно читается лишь изредка, возвращаемое устаревшей репликой значение вполне может оказаться совсем старым.

Решение. Технического хорошего нету :) Пользователи должны быть оповещены о подобных потенциальных случаях устаревания информации.

## Операции записи и чтения по кворуму

Базы данных с хорошо заданным кворумом могут выдержать отказы отдельных узлов без необходимости восстановления. Они могут выдержать и замедление работы отдельных узлов, поскольку запросам не нужно ждать ответа от всех n узлов -- достаточно, чтобы ответили w или r узлов. СУБД с репликацией без ведущего узла таким образом подходят для сценариев, требующих высокой доступности данных и низкого значения задержки, а также возможности пользователей "выдержать" случающиеся иногда операции чтения устаревших данных.

Проблема 50. Кворум -- отнюдь не волшебный отказоустойчивый метод. Сетевые сбои на стороне клиента вполне могут прервать связь клиента и со всеми узлами, или с очень большим их количеством, и хотя эти узлы продолжают функционировать нормально, и другие клиенты могут к ним подключаться, для отрезанного от них клиента они всё равно что не работают, и он не может достичь кворума.

Решение. Сформировать большой кластер -- с числом узлов, значительно превышающим n.

## Операции записи и чтения по кворуму

Проблема 51. В ситуации с большим кластером всё равно вполне вероятна следующая ситуация: клиент может подключиться к некоторым узлам базы данных во время сбоя сети (но не к нужным ему), и всё равно не сможет достичь кворума для конкретного обрабатываемого значения. Стоит ли в таком случае выдать ошибку в качестве ответа на все запросы, для которых не получается достичь кворума из w или r узлов?

Решение. Может использоваться схема  **нестрогого кворума (sloppy quorum)** : операции записи обрабатываются в любом случае, и применяются ко всем узлам, которые доступны, но не входят в число n узлов, в которых обычно размещается это значение. То есть для операций записи и чтения по-прежнему необходимо w и r подтверждений успешного выполнения, но при этом учитываются узлы, не входящие в число выбранных для этого значения n "родных" узлов.

После исправления сбоя сети все операции записи, временно отправленные в какой-либо другой узел вместо недоступного, отправляются в соответствующие "родные" узлы (так называемая  **направленная передача, hinted handoff** ).

Нестрогий кворум вовсе не кворум в обычном смысле -- это просто гарантия сохраняемости данных (сохранения данных в каких-то w узлах). Эти данные при чтении из r узлов окажутся точно видны только после того, как завершится направленная передача.

### Операции записи и чтения по кворуму (задания)

======= 42. При наличии n реплик операция записи считается успешной, если подтверждена w узлами, причем необходимо опросить как минимум r узлов для каждой операции чтения

[ ] w + r >= n

[ 1] w + r > n

[ ] w + r < n

======= 43. Если СУБД применяет только разрешение конфликтов при чтении, то ...

[ ] применяем префикс даты/времени

[ 1] невозможно оценить устарелость значений

[ ] нумеруем реплики

======= 44. Сбои на стороне клиента прервали связь с большим количеством узлов

[ ] запускаем процесс снижения энтропии

[ 1] формируем кластер с числом узлов, значительно превышающим n

[ ] делаем w + r >> n

======= 45. Даже в большом кластере всё равно вероятна ситуация, что клиент не сможет достичь кворума

[ 1] обрабатывать операции записи в любом случае, и применять их ко всем доступным узлам

[ ] выдать ошибку в качестве ответа на все запросы, для которых не достгнут кворум

[ ] попробовать сразу выполнить направленную передачу
