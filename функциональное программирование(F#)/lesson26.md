## Часть 7. Ленивые вычисления и последовательности

### 48. Хвостовая рекурсия

**48.1. Принцип хвостовой рекурсии**

Значения примитивных типов в F# (например, числа) хранятся в стеке, а более сложные структуры данных (например, списки), а также объекты и функции, в куче.

Рекурсивные функции возвращают промежуточный результат вычислений в стек, и при обработке больших списков с помощью рекурсии нередко возникает исключительная ситуация переполнения стека StackOverflow.

Для исключения стека из рекурсивного расчёта надо, чтобы рекурсивный вызов функции располагался в самом конце функции (хвостовая рекурсия), и не входил ни в какие вычисления -- в таком случае компилятор может оптимизировать этот вызов без использования стека на рекурсию произвольной глубины.

Хвостовая рекурсия обычно реализуется в функциональных языках двумя следующими шаблонами.

**48.2. Аккумулятор для хвостовой рекурсии**

Рекурсивная функция снабжается дополнительным параметром, накапливающим результат, с которым сразу вызывается.

Например, следующая реализация факториала не оптимизирована:

```
let rec factorial = function 
 | 1  -> 1
 | n  -> n * factorial(n - 1)
```

В выражении n * factorial(n - 1) подразумевается, что сначала надо сделать рекурсивный вызов, а затем умножать его результат на n.

Версия с хвостовой рекурсией и аккумулятором:

```
let factorial n =
    let rec f x a =
        if x <= 1 then a
        else f (x - 1) (a * x)
    f n 1
```

**48.3. Продолжения (continuations, continuation passing style)**

Продолжения также используют дополнительный аргумент, только он содержит не значение, а функцию-продолжение, которая выполняет то, что остаётся, вместо сохранения точки возврата из рекурсии в стеке.

Второй параметр "c" функции factorial -- это функция-продолжение, в которой записывается остаток вычислений n * f после рекурсивного вызова factorial (n-1).

```
let rec factorial n c =
    if n <= 1 then c 1
    else factorial (n-1) (fun f -> c(n * f))
```

При первом вызове функции factorial в качестве параметра продолжения используется предопределённое значение id.

```
printfn "%d" (factorial 5 id) // 120
```

**48.4. Задания**

48.4.1. Напишите две версии функции вычисления n-го числа Фибоначчи Fn.

1. fibo1: int -> int -> int -> int, с двумя параметрами-аккумуляторами n1 и n2, где
   fibo1 n n1 n2 = Fn, n1 = второй начальный элемент последовательности, и n2 -- самый первый начальный.

Например, fibo1 6 1 0 = 8 , fibo1 6 5 3 = 55.

2. fibo2: int -> (int -> int) -> int , где первый параметр -- n, а последний параметр -- функция-продолжение.

48.4.2. Имеется функция генерации списка

```
let rec bigList n k =
  if n=0 then k []
  else bigList (n-1) (fun res -> 1::k(res))
```

Эта функция при вызове

```
bigList 230000 id
```

генерирует исключение StackOverflow.

Напишите корректную версию bigList.

Шаблон для отправки на сервер:

```
// 48.4.1
let rec fibo1 n n1 n2 = ...

// 48.4.2
let rec fibo2 n c = ...

// 48.4.3
let rec bigList n k = ...
```

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/d337138cc4.html)**

---

**Ответы на задания 47**

```
let f n =  
     let mutable p = 1 
     let mutable i = 1 
     while i <= n do 
         p <- p * i 
         i <- i + 1 
     p 
  
let fibo n = 
     let mutable a = 0 
     let mutable b = 1 
     let mutable c = 0 
     let mutable i = 1 
     while i < n do 
         c <- b 
         b <- a + b 
         a <- c 
         i <- i + 1 
     if n = 0 then a else b 
```
