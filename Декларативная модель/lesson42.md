### 44. "Недекларативщина"

Декларативное программирование благодаря своему "чисто функциональному" взгляду на программирование несколько оторвано от реального мира, в котором сущности имеют память (состояние) и могут развиваться независимо и проактивно (параллельно). Чтобы связать декларативную программу с реальным миром, необходимо её дополнить некоторыми не совсем декларативными операциями.

Одни из наиболее востребованных классов таких операций -- это файловый ввод/вывод и графические интерфейсы пользователя. На самом деле такие недекларативные операции укладываются в более общие вычислительные модели, нежели декларативные -- в частности stateful- (например, императивные) и параллельные модели.

Простой способ стыковки декларативного программирования с реальным миром -- это использование файлов. В общем случае файл представляет собой последовательность значений, которые хранятся вне запущенной программы на постоянном носителе информации, например, на жёстком диске. В декларативной модели файл, открытый на чтение, может представляться, например, как список, и обрабатываться итератором. Операция, модифицирующая файл, может работать так, словно она получает на вход старый файл, и создаёт новый файл, хотя физически он на диске остаётся всё тот же.

А прямой способ взаимодействия программ с человеком через графический интерфейс пользователя (GUI) в декларативной модели продуктивно реализуется через определения GUI с помощью компактных и преимущественно декларативных спецификаций -- с помощью описательного декларативного языка.

### Проектирование программ

Мы познакомились с различными методами программирования в декларативной модели, и следующим логическим шагом будет их использование для создания реальных программ. Этот шаг называется  **проектированием (design) программ** . Он начинается с формулировки проблемы или задачи, которую надо решить/реализовать. Как правило, эта формулировка делается словами, и часто далеко не точно и не без противоречий. Проектирование даёт нам высокоуровневую структуру программы: какие программистские техники мы будем использовать, и как они будут связаны между собой, и как в конечном итоге будет получена полная программа, которая решает исходную проблему.

При проектировании программ надо учитывать важное классическое различие между "программированием в малом" (programming in small) и "программированием в большом" (programming in large). В зависимости от подхода полученные программы можно называть "маленькие программы" и "большие программы". Однако данное различие не имеет ничего общего с размером/объёмом программы – прежде всего оно определяет, сколько людей было задействовано в её разработке.

Маленькие программы пишутся одним человеком за относительно короткий промежуток времени. Большие программы пишутся двумя и большим количеством людей или в течение длительного периода времени. Дело в том, что один и тот же человек-разработчик «сегодня» и «через год» рассматривается в программной инженерии как два разных разработчика, так как человек за год забудет много важных деталей.

Впрочем, существует и другое разделение programming in small / large: small подразумевает прежде всего кодирование, написание ясного, чистого, продуктивного кода; а large -- это прежде всего про правильное проектирование, которое действительно становится крайне актуальным, едва программа становится более-менее большой (начиная с нескольких тысяч строк кода).


### 45. Методология проектирования в малом/in small

Возникла ситуация, когда требуется в одиночку разработать относительно небольшую программу (ориентировочный объём – до единичных десятков тысяч строк). Рекомендуется следующая простая методика проектирования, в которой смешаны творческий подход и формальное мышление:

1) **Неформальная спецификация** . Мы начинаем с того, что записываем как можно точнее, что должна делать программа: что она будет получать на вход, что должна выдавать на выходе, и каким образом выходные данные соотносятся с входными. Такое описание называется неформальная спецификация (в мэйнстриме она часто называется техническим заданием). Несмотря на то, что она будет, как мы рассчитываем, точна как только можно, мы называем ее "неформальной", потому что она будет написана на обычном русском языке. "Формальные" спецификации записываются в математической нотации.
2) **Примеры** . Чтобы ещё больше прояснить спецификацию, всегда хорошо и полезно представить примеры того, что делает программа в конкретных случаях (лучше всего в формате тестов). Эти примеры должны, во-первых, показывать «границы» программы (проверять её работу в граничных условиях и самыми неожиданными способами, которые мы можем себе представить), и во-вторых, демонстрировать типовые сценарии её эксплуатации.
3) **Исследование** . Чтобы выяснить, какие конкретно методы программирования нам подойдут лучше всего, хороший способ -- использовать интерактивный интерфейс для экспериментов с фрагментами программы. Идея состоит в том, чтобы написать небольшие достаточно автономные операции, которые, как мы думаем, буду необходимы нашей программе. Эти операции достаточно наглядны и обеспечивают некоторый системный базис программы. Этот шаг дает нам более чёткое представление о том, что представляет собой структура нашей программы.
4) **Структура и реализация** . Теперь мы можем сформировать структуру программы: делаем приблизительный набросок операций, необходимых для расчета результатов, получаемых на входе, и способы, которыми эти операции будут комбинироваться друг с другом. Затем мы заполняем оставшиеся пробелы, добавляя реальный код. Операции должны быть простыми: каждая операция должна делать только одну вещь. Для улучшения структуры мы группируем связанные операции в модули.
5) **Тестирование и обдумывание** . Наконец, мы должны убедиться, что наша программа работает правильно. Мы проверяем её на серии тестовых случаев, включая примеры, которые мы придумали раньше. Мы исправляем ошибки до тех пор, пока программа не заработает хорошо. Мы также можем порассуждать о структуре программы и о её сложности, используя формальную семантику для непонятных частей. Тестирование и обдумывание взаимодополняемы: важно делать и то, и другое, чтобы получить качественную программу.

Как видите, подход программирования в малом весьма простой. Перечисленные шаги не являются обязательными, они скорее служат вдохновляющей схемой для разработчика. Не стесняйтесь адаптировать их к своим конкретным обстоятельствам. Например, на любом шаге может появиться понимание того, что надо внести определённые коррективы в предыдущие шаги, в частности, в спецификацию. Пока разработчик один, код пишется аккуратно и его не очень много, такие итерации не вызывают особых проблем. Однако, никогда не забывайте о самом важном шаге в процессе programming in small -- тестировании. В частности, полезно сразу применять какую-нибудь конкретную методику, тесно связанную с тестами, например, TDD.

****

### Пример подхода programming in small

Имеется **простое рабочее задание** для программиста-стажёра:

*Напишите функцию, которая получает в качестве аргумента имя файла, содержащего текст книги, и затем выводит на экран список пар, где каждая пара состоит из слова и целого числа, показывающего количество раз, сколько это слово встречается в файле.*

Достаточно ли точна эта спецификация? Надо ли выводить результат в отсортированном порядке? В каком именно? Что понимается под "словом", как слова отделяются друг от друга? Надо ли учитывать разные кодировки (не ASCII), надо ли учитывать в качестве разделителей знаки препинания, или символы табуляции? Что, если файл в двоичном формате? Что должно быть выведено, если файл пустой или сбойный?

**Мы обращаемся к заказчику (или старшему программисту)** , который нехотя уточняет: считайте словом непрерывную последовательность из английских букв и цифр (хотя, скорее всего, понадобится также учитывать и дефис, и символ подчёркивания).

В данной ситуации  **хорошо помогли бы примеры** , но, как часто бывает, их нету.

Хорошо, следующий шаг --  **проектирование структуры программы** , как минимум, предварительное обдумывание её в уме,  **абсолютно обязательно -- физически не перед экраном компьютера** . Применим схему организации функций как конвейера, что мы делали при создании декларативного стека: сначала функция читает файл в виде списка символов, затем преобразовывает список символов в список слов.

Важный момент, что восприятие файла как списка строк – слабая абстракция, так как каждую строку придётся вводить и обрабатывать отдельно, что добавляет ненужную сложность. Правильнее воспринимать файл как непрерывный поток символов.

По мере того, как последовательно выделяются слова, надо накапливать по ним статистику. Для этого нужна структура данных, которая позволяет использовать слова как индексы или ключи – стандартный словарь хорошо подойдёт.

Далее  **мы делаем тесты** , готовим несколько файлов с тестовыми данными, статистика по словам которых собрана вручную, и особо проверяем непонятные или нечёткие случаи, чтобы в случае чего быстро их исправить и проверить.

Такая схема в общем и целом близка практической работе программиста над небольшими проектами. В ней нету никаких сложных моментов, главное:

- **обеспечивать адекватность спецификации** , не допуская по возможности неоднозначных мест, которые потом могут серьёзно усложнить доработку,
- **сохранять ясность и выразительность кода** , чтобы он был легко понятен и самому разработчику, и другим людям,
- **поддерживать хорошее множество тестов** , покрывающих как спецификацию (словесное описание задания), так и реализацию (код).


### Проектирование программ (задания)

======= 88. Что такое programming in small?

[ ]кодирование по маленькому

[ ]проектирование в малом

[x]ясное, чистое продуктивное кодирование

======= 89. Что такое programming in large?

[ ]проектирование по большому

[ ]ясное, чистое продуктивное кодирование

[x]design программной системы

======= 90. Самый важный шаг в programming in small?

[ ]Структура и реализация

[x ]Тестирование и обдумывание

[ ]Неформальная спецификация

[ ]Исследование

[ ]Use cases
