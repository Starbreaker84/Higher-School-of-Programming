## 5. Связь ООП с другими вычислительными моделями

ООП -- это один из способов структурирования программ, который чаще всего применяется вместе с явным состоянием. В сравнении с другими вычислительными моделями  **ООП характеризуется, прежде всего, использованием наследования** .

Наследование, строго говоря -- отнюдь не новая концепция, оно рождается скорее из способа определения лингвистической абстракции классов, и на самом деле, довольно тесно связано с разными техниками программирования высшего порядка.

**Объектно-базированное программирование** -- это ООП без наследования. Оно по сути представляет собой компонентно-базированное программирование, расширенное синтаксической поддержкой классов. Без наследования объектная абстракция становится намного проще и предлагает удобную нотацию для инкапсуляции состояния и определения множества операций над ним (исчезают проблемы с переопределением методов, пропадает различие между статическим и динамическим связыванием, и т. п.).

**Программирование высшего порядка тесно связано с ООП** . Допустим, имеется функция сортировки, которая получает на вход функцию, сравнивающую два элемента, и возвращает итоговую функцию, "параметризованную" конкретной функцией сравнения (например, под конкретный тип данных). В объектно-базированном программировании (без наследования) мы можем создать класс сортировки, который будет получать в конструкторе или параметром отдельного метода объект другого класса (композиция), который выполняет сравнение значений конкретных типов. В ООП (с наследованием) создаются классы-потомки, которые перезаписывают метод сравнения значений "абстрактного" типа сравнением значений конкретного типа.

### Вкусняшки, добавляемые ООП

Очевидно, что процедурные/функциональные значения и объекты тесно связаны. Основная разница между программированием высшего порядка и ООП заключается в том, что ООП как бы "приукрашивает" программирование высшего порядка -- и семантически, и синтаксически. Это более богатая абстракция, предоставляющая набор дополнительных идиом за рамками процедурной абстракции.

- **Явное состояние** легко определяется и используется.
- Легко определяются  **множественные методы** , обрабатывающие одно и то же явное состояние, а объект выбирает нужный метод для вызова.
- Доступны  **классы** , которые задают набор методов, а на их основе создаются объекты, причём каждый экземпляр класса имеет оригинальное явное состояние. Если объекты подобны обычным процедурам, то классы подобны процедурам высшего порядка, которые возвращают "процедуры" (объекты) в качестве своего значения.
- Предусмотрено  **наследование** , позволяющее определять новые наборы методов на базе существующих наборов -- путём расширения, модификации и комбинирования существующих методов. Статическое и динамическое связывание делают эту возможность особенно богатой.
- На уровне классов и объектов могут быть определены  **различные уровни инкапсуляции** . Атрибуты и методы могут быть private/public/protected, или иметь какую-либо другую степень инкапсуляции, определяемую программистом.

Важно отметить, что все эти механизмы ООП не предоставляют никаких принципиально новых возможностей. Они могут быть полностью определены с помощью программирования высшего порядка, явного состояния и имён-как-значений (для поддержки разных схем видимости). С другой стороны, эти механизмы оказываются весьма полезными идиомами, которые приводят к удобному стилю программирования.

ООП -- это абстракция, которая предоставляет выразительную синтаксическую нотацию для использования любого из этих механизмов, или всех вместе, когда они необходимы. Но такое богатство -- обоюдоострый меч. С одной стороны, оно делает абстракции действительно полезными во множестве прикладных задач программирования. С другой стороны,  **абстракция ООП характеризуется довольно сложной семантикой** , и о системе в парадигме ООП на самом деле трудно рассуждать, как только проект становится более-менее объёмным. Работая с ООП, можно быстро насоздавать в проекте много "сложностей", и выдерживать на практике принцип "сложность системы равна линейной сумме сложностей её подсистем" становится практически невозможным.

По этой причине, как ни странно это прозвучит в контексте применения научных парадигм программирования к повседневной разработке,  **рекомендуется всё же использовать ООП только в тех случаях, когда оно значительно упрощает структуру программы** . Например, когда есть явная необходимость в наследовании: программа содержит набор тесно связанных абстрактных типов данных, каждый из которых представляет собой частичное расширение или уточнение родительского АТД. В остальных случаях предлагается применять более простые методы и приёмы программирования, прежде всего декларативные.

### Общие ограничения объектного подхода

Парадигма cистемы объектов с наследованием, определенная на данном курсе, особенно близка к программированию высшего порядка. Не все объектные системы так к нему близки.

На практике, ряд нижеприведённых полезных характеристик системы объектов, близкой к программированию высшего порядка, часто отсутствует или неудобен в использовании:

- **Классы как значения** . Классы (фактически, пользовательские типы данных) можно создавать во время выполнения, передавать в качестве аргументов, и хранить в структурах данных.
- **Полное лексическое замыкание** . Подразумевается, что язык программирования поддерживает процедурные значения с внешними ссылками. Это позволяет определить класс внутри области видимости процедуры или другого класса. В Java например такой подход предлагается с некоторыми ограничениями: допускаются вложенные классы.
- **Сообщения первого класса** . Обычно имена сообщений и методов должны быть известны во время компиляции. Самый общий способ снять это ограничение -- позволить сообщениям быть значениями, которые могут вычисляться во время выполнения. В некоторых популярных языках предоставляется такая возможность, хотя она синтаксически обычно более многословна, чем статические вызовы методов.

В целом, многие популярные объектно-ориентированные языки, например, C++, не поддерживают полноценное программирование высшего порядка, поскольку они не допускают процедурные значения с лексическим замыканием во время выполнения. Но в этих языках многие возможности программирования высшего порядка могут быть получены с помощью инкапсуляции и наследования, с небольшими дополнительными усилиями со стороны программиста.

- **Процедурное значение может быть представлено как объект** . Атрибуты объекта представляют собой внешние ссылки процедурного значения, а параметры метода -- это параметры процедурного значения. Когда объект создается, его атрибуты инициализируются значениями по внешним ссылкам. Объект можно передавать и вызывать точно так же, как и процедурное значение. При соблюдении простой дисциплины и получается программирование с процедурными значениями, что в свою очередь допускает возможность программирования высшего порядка.
- **Общая/обобщённая процедура может быть закодирована как абстрактный класс** . Общая процедура -- это процедура, которая принимает аргументы и возвращает конкретную процедуру. Например, общая процедура сортировки может принимать операцию сравнения для заданного типа и возвращает готовую процедуру сортировки, которая сортирует массивы соответствующего типа. А в случае абстрактного класса неопределённые в нём методы конкретизируются в классах-наследниках.

В результате мы можем использовать почти все приемы программирования высшего порядка, описанные в этом курсе. Но у объектно-ориентированного подхода есть два недостатка по сравнению с процедурным: он  **более громоздкий в написании** , и  **в объекте-замыкании внешние ссылки должны быть указаны в явном виде** .


### Диаграммы и паттерны

======= 30. В объектно-базированном программировании (ООП без наследования) существуют проблемы с ...

[ ] переопределением методов

[ 1] явным состоянием

[ ] статическим и динамическим связыванием

======= 31. Какой семантический или синтаксический плюс не характерен для реализаций ООП ?

[ ] наследование

[ ] простота определения явного состояния

[ 1] лексическое замыкание

[ ] концепция классов

[ ] полиморфизм

======= 32. Паттерн проектирования -- это ...

[ ] использование классов как значений

[1 ] способ инженерного мышления

[ ] синтаксический сахар
