## Базовые действия над списками - 2

**35. Диапазоны списков**

Список из целых или вещественных значений в диапазоне от a до b с шагом +1 (включая границы) задаётся выражением диапазона [ a .. b ].

```
[ 1 .. 3 ] = [1; 2; 3] // true
[ -1.0 .. 3.14 ] = [-1.0; 0.0; 1.0; 2.0; 3.0] // true
```

Выражение диапазона [ a .. s .. b ] дополнительно задаёт ненулевой шаг генерации s.

```
[ 3 .. -2 .. -1  ] = [3; 1; -1] // true
```

Функция перемножения всех чисел списка:

```
let rec mul = function
 | [] -> 0
 | [x] -> x
 | head :: tail -> head * mul tail
mul [ 1 .. 5  ] // 120
```

**36. Слоистый шаблон**

Слоистый шаблон -- это форма pat as id , где pat -- обычный шаблон, as -- ключевое слово, и id -- идентификатор, который связывается со значением, сопоставленным шаблону pat.

```
let rec mul = function
 | [] -> 0
 | [x] -> x
 | head :: (head2 :: _ as tail) -> head * mul tail
```

**37. Стандартные функции для работы со списками**

Инфиксный оператор @ сцепляет два списка одного типа.

```
[1; 2] @ [3; 4; 5] = [1; 2; 3; 4; 5] // true
```

Функция List.rev переворачивает список от конца к началу.

```
(List.rev [5; 4; 3; 2; 1]) = [1; 2; 3; 4; 5]
```

**38. Списки и полиморфизм**

Функции, работающие со списками, в большинстве полиморфические, потому что могут обрабатывать списки разных типов.

В F# есть ограничение на полиморфические выражения, состоящее в том, что такие выражения не могут быть редуцированы (их вычисление нельзя отложить).

Корректные полиморфические выражения:

```
[ ]
Some [ ]
(fun x -> [x])
```

Выражение, вычисление которого может быть отложено:

```
[ ] @ [ ]
List.rev []
```

На высшем уровне абстракции (использования в качестве аргументов) полиморфические выражения должны вычисляться сразу. На промежуточных этапах полиморфические выражения могут использоваться свободно и включать в том числе и отложенные вычисления.

**39. Задания**

39.1. Напишите функцию rmodd, которая получает на вход список, и выдаёт список, в который входят значения входного списка на нечётных позициях (первая позиция в списке, с индексом 0, считается чётной).

39.2. Напишите функцию del_even, которая получает на вход список, и выдаёт список, из которого удалены все чётные значения входного списка.

39.3. Напишите функцию multiplicity x xs, которая находит, сколько раз значение x встречается в списке xs.

39.4. Напишите функцию split, которая разделяет входной список на два следующим образом:

```
split [x1; x2; ...; xn-1; xn] = ([x1; x3; ...], [x2; x4; ...])
```

39.5. Напишите функцию zip, которая преобразует два входных списка в результирующий список следующим образом:

```
zip ([x1; x2; ...], [y1; y2; ...]) = [(x1,y1); (x2,y2); ...]
```

Если длины входных списков неодинаковы, генерируйте исключение.

Шаблон для отправки на сервер:

```
// 39.1
let rec rmodd = ...

// 39.2
let rec del_even = ...

// 39.3
let rec multiplicity x xs = ...

// 39.4
let rec split = ...

// 39.5
let rec zip (xs1,xs2) = ...
```

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/f2f8s6e9ff.html)**

---

**Ответы на задания 34**

```
let rec upto = function
 | 1 -> [1]
 | n -> upto(n - 1) @ [n]
 
let rec dnto = function
 | 1 -> [1]
 | n -> n :: dnto(n - 1)
 
let rec evenn = function
 | 1 -> [0]
 | 2 -> evenn(1) @ [2]
 | 3 -> evenn(2) @ [4]
 | n when n < 1 -> []
 | n -> evenn(n - 1) @ [2 * (n - 1)]
```
