## Ассоциативный массив

Хэш-таблицы хоть и реализованы в большинстве языков программирования, в стандартных библиотеках, однако напрямую используются редко, так как сами по себе не очень полезны. Однако существует такая очень популярная структура данных, как  **ассоциативный массив (или словарь)** , когда мы храним данные в формате ключ - значение. Такой массив отличается от обычного тем, что в качестве индексов выступают не целые числа, а произвольные значения (например, строки). Вот тут мы и находим точку пересечения с хэш-таблицами.

Практически во всех современных языках присутствует структура данных Словарь (Dictionary, Map, ...). Он позволяет поместить в переменную набор пар ключ-значение.

Часто при записи поддерживается синтаксис формата данных JSON, например:

```
my_dict = {"key1": "значение 1", "ключ 23": 512}
```

и в дальнейшем получать нужное значение, указав ключ в качестве индекса:

```
my_dict["ключ 23"]
```

Можно изменять значения в словаре:

```
my_dict["ключ 23"] = 1024
```

Для реализации ассоциативного массива NativeDictionary воспользуемся хэш-таблицей, реализованной в предыдущем занятии. По сути, потребуется лишь расширить её вторым массивом -- в дополнение к массиву слотов, который будет хранить ключи.
Второй массив по размеру будет таким же, как и первый, а записываются в него значения, соответствующие ключу слота (с таким же индексом).

Главное отличие ассоциативного массива от хэш-таблицы в том, что он обычно не ограничен каким-то фиксированным размером (количеством ключей), и либо исходно под конкретную задачу создаётся с гарантированным запасом по размеру, либо сочетает возможности хэш-таблицы и динамического массива.

Для хранения данных произвольных типов можно применить механизм полиморфизма или типы-генерики, если язык это позволяет.

Если по каким-то причинам реализация с хэш-функциями не подходит (например, возникает слишком много коллизий), то для реализации словаря вполне можно использовать упорядоченный массив фиксированного размера, который хранит, например, объекты с двумя полями ключ и значение.
Другой вариант -- использовать для реализации словаря двоичное сбалансированное дерево, где поиск ключей происходит очень эффективно (все важные виды поиска проходим на курсах по деревьям графам и сортировкам). Но сама реализация будет сложнее, она подразумевает работу с указателями и динамическим выделением памяти, а изменение структуры дерева (добавление новых узлов и балансировка) может требовать дополнительных накладных ресурсов, если, например, счёт идёт на миллионы элементов.

**Задания.**

1. Выясните, как в языке программирования, которым вы пользуетесь, реализован тип данных Словарь.
2. Реализуйте класс NativeDictionary, как описано выше.
3. Добавьте в этот класс три метода:

- put(key, value) - сохранение внутри класса ассоциативного массива пары ключ-значение по описанной выше схеме;
- is_key(key) - проверка, имеется ли в слотах такой ключ;
- get(key) - поиск и извлечение значения по ключу, или отсутствие значения, если ключ не найден.

4. Сделайте тесты, проверяющие, как работают put(), is_key() и get():

- добавление значения по новому ключу и добавление значения по уже существующему ключу с проверками что записалось,
- проверка присутствующего и отсутствующего ключей,
- извлечение значения по существующему и отсутствующему ключу.

**[предыдущее](https://skillsmart.ru/algo/15-121-cm/c5f6d68jj7.html)**

---

В данном обучающем примере исходим из фиксированного размера ассоциативного массива. В автоматических тестах этот размер гарантированно не будет превышен.

## заготовка класса C# для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
using System;
using System.Collections.Generic;

namespace AlgorithmsDataStructures
{

  public class NativeDictionary<T>
  {
    public int size;
    public string [] slots;
    public T [] values;

    public NativeDictionary(int sz)
    {
      size = sz;
      slots = new string[size];
      values = new T[size];
    }

    public int HashFun(string key)
    {
      // всегда возвращает корректный индекс слота
      return 0;
    }

    public bool IsKey(string key)
    {
      // возвращает true если ключ имеется,
      // иначе false
      return false;
    }

    public void Put(string key, T value)
    {
      // гарантированно записываем 
      // значение value по ключу key
    }

    public T Get(string key)
    {
      // возвращает value для key, 
      // или null если ключ не найден
      return default(T);
    }
  } 
}
```

---

## заготовка класса Java для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
import java.lang.reflect.Array;

class NativeDictionary<T>
{
    public int size;
    public String [] slots;
    public T [] values;

    public NativeDictionary(int sz, Class clazz)
    {
      size = sz;
      slots = new String[size];
      values = (T[]) Array.newInstance(clazz, this.size);
    }

    public int hashFun(String key)
    {
      // всегда возвращает корректный индекс слота
      return 0;
    }

    public boolean isKey(String key)
    {
      // возвращает true если ключ имеется,
      // иначе false
      return false;
    }

    public void put(String key, T value)
    {
      // гарантированно записываем 
      // значение value по ключу key
    }

    public T get(String key)
    {
      // возвращает value для key, 
      // или null если ключ не найден
      return null;
    }
}
```

---

## заготовка классов C++ для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/15-121-cm/github.html)

```
class NativeDictionary
{
  public:
    int slots_size;
    char** slots;
    int* values; // хранит неотрицательные значения

    NativeDictionary(int sz)
    {
      slots_size = sz;
      slots = new char*[slots_size];
      for(int i=0; i<slots_size; i++) slots[i] = NULL;
      values = new int[slots_size];
      for(int i=0; i<slots_size; i++) values[i] = -1;
    }

    int hashFun(char* key)
    {
      // всегда возвращает корректный индекс слота
      return 0;
    }

    bool is_key(char* key)
    {
      // возвращает true если ключ имеется,
      // иначе false
      return false;
    }

    void put(char* key, int value)
    {
      // гарантированно записываем 
      // значение value по ключу key
    }

    int get(char* key)
    {
      // возвращает value для key, 
      // или -1 если ключ не найден
      return -1;
    }
};
```
