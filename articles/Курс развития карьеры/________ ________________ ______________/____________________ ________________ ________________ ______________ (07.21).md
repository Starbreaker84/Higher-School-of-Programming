## Версионный контроль исходных текстов

С технологиями версионного контроля исходных текстов у меня всегда были отношения любви и ненависти.

Эти технологии стали массовыми далеко не сразу, и хотя подобные системы существовали ещё на мэйнфреймах ЕС ЭВМ (IBM 360) полвека назад, тогда они были полной экзотикой.

Более-менее массовое распространение они получили в 21-м веке, ну а сегодня стали стандартом во всех уважающих себя компаниях во многом благодаря набравшей невероятную популярность системе версионного контроля git и ресурсу github.com, где развиваются бесплатные проекты в исходных текстах, а контроль ведётся с помощью git.

В своей карьере я довольно быстро понял, что -- нравится мне это или нет -- но  **умение уверенно работать с системой контроля исходных текстов -- это весьма важная часть работы программиста** .

Одной из первых таких массовых систем в моей практике стала SVN -- поэтому что она была неплохо интегрирована с Visual Studio ещё самых первых версий, на следующей работе применяли CVS, и т. д.

Историю этих систем можно почитать тут: [habr.com/ru/post/478752/](https://habr.com/ru/post/478752/).

Сегодня для всех этих систем, как правило, доступны удобные графические клиенты, либо "родные", либо сторонние, например, TortoiseGit и TortoiseSVN.

Зачем это всё?

Возможно, вы сталкивались с ситуацией, когда, в одно прекрасное утро, пиша код, вы решаете забрать последние обновления проекта у ваших коллег.

Я гарантирую, что программисты в любой серьёзной команде, не использующей версионный контроль, оказывались в похожей передряге.

Когда вы сносите устаревший код, пересобираете проект, запускаете его...

Жёсткий диск начинает интенсивно мигать, долго-долго что-то делает...

И вот на экране выскакивает диалоговое окно ошибки, вы жмёте ОК -- и, привет, синий экран смерти Windows.

Хорошо, что вам не пришлось переустанавливать систему заново.

Или пришлось?

И вот вы потратили день-два на полное восстановление вашего компьютера, загрузили последнюю версию исходного кода вместе с вашими последними изменениями, которые вы предусмотрительно сохранили (я надеюсь...) на флешке или файловом сервере -- и запускаете приложение.

И снова индикатор жёсткого диска начинает долго мигать.

Теперь вы пытаетесь прервать работу -- но уже слишком поздно.

Несколько секунд спустя снова синий экран, отказ от перезагрузки, и вам снова надо переустанавливать всё с нуля.

Наконец, до вас доходит.

Вы подходите к столу Олега, вашего коллеги, и смотрите на последние изменения, которые он внёс в проект.

Оказывается, Олег для удобства отладки на своём компьютере изменил одну из глобальных проектных констант в одном из заголовочных файлов С++ на "C:\temp".

Он сделал это, когда закончил свою функцию, которая сканировала файлы (подразумевается, временные файлы) в заданном каталоге, и удаляла их при запуске.

Вы тоже вносили изменение в тот же заголовочный файл C++, но еще не объединили свои изменения с доработками Олега.

Поэтому, когда вы объединяли свой код с новым кодом проекта, вы не выполнили аккуратное построчное слияние (так называемый merge) своего кода с текущим, а просто перезаписали его своим.

А в вашем заголовочном файле по умолчанию оставалось значение "C:\" -- корневой каталог компьютера.

Каждый раз, когда вы запускали приложение, функция Олега рекурсивно удаляла все файлы на вашем компьютере.

И это только один из множества случаев, когда версионный контроль может буквально вас спасти.

Например, частая ситуация, когда вы удалили код, который вроде бы устарел, а потом оказалось, что он был полезен и важен. Но откуда теперь его взять? Вспомнить по частям и кодировать заново?

Контроль исходного кода может быть очень забавным.

### Что же такое контроль исходного кода (версионный контроль)?

**Контроль исходных текстов -- это способ отслеживания различных версий файлов (прежде всего с исходным кодом) в программном проекте** . Он координирует действия нескольких разработчиков, которые могут работать одновременно над одним и тем же набором файлов.

Существует множество систем контроля исходного кода, но все они преследуют одну и ту же цель --  **помочь вам наилучшим образом управлять исходным кодом всего проекта** .

### Важное

Как я уже говорил, раньше системы контроля исходного кода использовались очень редко.

Типичной была ситуация, когда в большом и дорогом проекте исходный код располагался в общей сетевой папке или на дискете, которую передавали по кругу.

Как вы думаете, сколько компаний, полагавшихся на такую версию контроля исходных текстов, разорились, когда кто-то по ошибке удалял содержимое дискеты или каталога на файловом сервере?

Одна из основных причин, по которой контроль исходных текстов так важен, заключается в том, что он очень сильно смягчает эту проблему.

**Команда, использующая систему контроля исходных текстов, имеет гораздо меньше шансов "потерять" свой код или полезные модули** , которые были ошибочно удалены за ненужностью.

Контроль исходного кода -- это сервис, с помощью которого вы можете проверить свой код и сохранить его в безопасности, чтобы он не мог быть бессистемно удален -- а также отслеживать изменения, чтобы, если вы случайно удалите часть кода или сделаете ошибку, вы могли вернуться и исправить её.

Вы когда-нибудь сохраняли на своем компьютере несколько копий документа с разными датами в заголовке, или в разных каталогах, чтобы при необходимости вернуться к более ранней версии?

Именно это контроль исходных текстов может сделать для любого кода в вашем приложении.

Но контроль исходных текстов -- это не только уверенность в том, что вы не потеряете исходный код.

Вы можете просто регулярно создавать резервные копии, чтобы избежать этой проблемы.

Все ответственные программисты всегда так делали и делают и сегодня, потому что ваш компьютер может отказать в любой момент, и что вы будете делать, если ваш многомесячный труд хранился только на жёстком диске?

Абсолютное правило:  **каждый день (а лучше чаще) без исключения делайте копию всего вашего проекта -- на флешку или в облако например** .

Контроль исходных текстов (в общем случае -- контроль версий файлов, которые могут быть двоичными) также  **помогает координировать работу нескольких разработчиков, использующих один и тот же набор файлов в проекте** .

Без контроля исходных текстов, помогающего управлять различными изменениями, вносимыми разработчиками, программисты легко могут безвозвратно перезаписать изменения друг друга, или долго ждать, пока кто-то другой закончит редактирование файла, прежде чем настанет их черёд.

Хорошая система контроля исходных текстов позволяет одновременно работать над одними и теми же файлами (на самом деле, конечно -- над разными копиями этих файлов), а затем аккуратно объединять изменения вместе.

Контроль исходных текстов также решает проблему работы над несколькими версиями кодовой базы проекта.

Например, в системе нашлись некоторые ошибки, которые необходимо исправить, но вы уже работаете над новыми функциями для следующей версии проекта, и эти новые функции ещё не совсем готовы.

Вот почему неплохо иметь несколько версий кода и грамотно ими управлять.

Например, одна версия может быть текущей -- в которой вы исправляете ошибки, а другая версия -- это та, где вы разрабатываете новые возможности.

И разве не было бы здорово, если бы вы могли корректно применять исправления ошибок из одной версии кода к версии, содержащей новые возможности?

Контроль исходного кода позволяет вам сделать именно это.

### Основы версинного контроля исходного кода

О принципах и системах контроля исходных текстов нужно знать довольно много, и вы, конечно, не станете экспертом, просто прочитав об этом, но вы как минимум получите представление об основах.

Далее я кратко расскажу вам об основных положениях контроля исходных текстов, а затем о нескольких наиболее распространенных технологиях, чтобы вы могли хотя бы понять, как работает версионный контроль в целом.

**Репозиторий (репа, repository)**

Одна из ключевых концепций практически всех систем контроля исходного кода -- это идея  **репозитория (хранилища)** , по сути, места, где хранится весь код со всеми версиями и полной историей.

Когда вы работаете с исходным кодом, вы берёте его из репы, работаете над ним, проверяете свои изменения.

То же самое могут делать и другие разработчики.

Репозиторий -- это место, где весь код проекта собирается вместе и где он "живёт" технически.

Различные системы контроля исходного кода по-разному трактуют понятие репозитория (например, может использоваться только локальный репозиторий, а не серверный или облачный), но в конечном итоге для любой базы кода обязательно должно быть одно центральное место, или репозиторий.

**checking out code (выгрузка кода из репозитория, чекаут)**

Возможно, вы ранее изучали занятие по DevOps (если ещё нет, настоятельно рекомендую), где мы уже рассматривали check in и check out.

Очевидно, первое, что вам надо сделать, когда вы только приступили к проекту, или хотите синхронизировать ваш код с последними изменениями, которые сделали другие разработчики -- это получить (скачать, выгрузить (в отношении терминов "выгрузить" и "загрузить" ведутся нескончаемые споры)) себе из репозитория локальную версию кода, на свой жёсткий диск, которую вы можете локально изменять, не мешая работе других.

Старые системы контроля исходных текстов фактически блокировали файлы, чтобы только вы один могли их редактировать.

Большинство современных систем позволяют вам произвольно модифицировать код проекта, потому что он хранится в виде локальной копии на вашей собственной машине или в локальном хранилище.

**checked out code -- это ваша локальная версия проекта** (обязательно запомните английские термины, их немного), не связанная с основным репозиторием, и вы можете безопасно для других производить над ней произвольные манипуляции.

**check in code (отправка ваших изменений кода в репозиторий)**

Эта операция чаще называется commit (комит, я закомитил в репу/в мастер, ...).

### Ревизии

В системах контроля исходных текстов существует  **понятие ревизий, которые представляют собой предыдущие версии файла, содержащиеся в репозитории** .

Так, например, если у нас есть файл users.py, который я создал, затем вы его изменили, а потом я снова вношу изменения, то в хранилище будет содержаться три разных версии users.py:

- Самая первая, которую я исходно создал;
- Версия файла после того, как её изменили вы (и закомитили);
- Окончательная версия после того, как я изменил ее снова (и выполнил чекин).

Почему это важно? Ну, по нескольким причинам.

Прежде всего, предположим, что я испортил users.py, и вы хотите вернуться к версии, которая существовала до того, как я внес свои кривые изменения.

Поскольку файл находится в системе контроля, вы можете просто вернуться к предыдущей ревизии и сделать вид, что моих изменений вообще не было.

Можно также **просмотреть историю (лог) ревизий** и выяснить, как изменялся файл с течением времени, чтобы выяснить, какие конкретно изменения происходили в каждой ревизии, и кто их вносил.

**Бранчи, branching**

Одна из самых непонятных для начинающих тем в контроле исходных текстов -- это  **ветвление (создание бранчей)** , а точнее, как правильно организовывать и использовать бранчи.

Концепция бранча, однако, довольно проста.

Большинство систем контроля исходных текстов позволяют вам создавать "ответвления" от существующей кодовой базы -- фактически, создать новую кодовую базу, которая может развиваться независимо от своей родительской базы.

Вам надо думать о своём коде как о дереве.

Это очень полезный навык, если вы планируете создавать проекты объёмом больше чем 300 строк кода.

У вас есть  **"ствол" (транк, trunk) основного кода** , и в какой-то момент у вас может появиться несколько  **ветвей (бранчей), которые отходят от этого ствола** .

Современные системы контроля версий очень хорошо визуализируют дерево бранчей и нередко позволяют легко им манипулировать через графический интерфейс.

![](https://skillsmart.ru/self/git.png)

Но я настоятельно рекомендую **изучать управление контролем прежде всего из командной строки** и не увлекаться GUI, иначе вы не получите глубокое понимание этой технологии.

Как это выглядит в реальности?

Предположим, у вас есть версия проекта, над которой вы работаете, и вы намерены отправить эту версию клиентам, и хотите назвать её версией 1, но... вы всё ещё хотите продолжить работу над новыми функциями для версии 2.

Проблема в том, что, несмотря на то, что вы потрясающий программист, вы знаете, что в версии 1, которую вы отправляете клиентам, будет как минимум несколько ошибок, которые вам придётся исправить в ближайшем будущем.

Однако вы не хотите отправлять им функции версии 2, пока не выпустите пофикшенную версию 1.1. (Вы планируете впоследствии взимать с них плату за обновление до версии 2).

Что же делать?

Очень просто. Вы разветвляете код, создаёте бранч.

Когда вы будете готовы к отправке версии 1, вместо того, чтобы просто отправить им то, что есть в транке (или, чаще говорят, в "мастере"), вы создаёте новую ветвь. Вы называете эту ветку "версия 1".

Это то, что вы отправляете клиентам.

Затем вы исправляете ошибки в этой ветке версии 1, а также реализуете новые фичи в мастере.

Вот только одна проблема...

Что, если вы захотите, чтобы ваши исправления багов попали и в мастер (что естественно)?

**Мержи (merging)**

Посмотрите, как красиво всё получается.

Решение вашей проблемы --  **слияние (мерж)** .

Что такое мерж, спросите вы?

Это именно то, как это называется.

Вы собираетесь  **построчно слить изменения двух файлов с кодом в один** .

В нашем небольшом примере мы просто используем готовую функцию слияния для объединения изменений в бранче версии 1 с мастером.

Мерж берёт все изменения, сделанные в ветке версии 1, и сливает их непосредственно с транком проекта.

**Слияние работает только в одном направлении** , поэтому мы получим все изменения из ветки версии 1 в мастере, но ни одна из новых функций, над которыми мы работали в мастере, не попадёт в ветку версии 1.

На что мы и рассчитывали.

В теории всё хорошо и спокойно -- пока мы не попытаемся выполнить мерж и не обнаружим, что у нас...

**Конфликты версий**

Блин!!! Чё за фигня??

Обычно именно такие слова постоянно произносят разработчики, когда пытаются выполнить простой и понятный процесс слияния нескольких простых изменений обратно c мастером.

В основном это происходит в пятницу вечером к 17:00, когда вы планировали сделать быстрый мерж и убраться оттуда.

У меня бывали подобные случаи, и не раз.

Закончилось это тем, что мудрый CEO просто запретил выкладывать что-то в мастер и деплоить в продакшен по пятницам.

Иначе всю субботу команде приходилось править баги либо откатывать мастер к предыдущей проверенной ревизии.

Вы отправляете ваш код мержиться, надеваете куртку, пишете друзьям в соцсети сообщение о том, где вы собираетесь с ними встретиться на расслабляющем вечере с напитками и вкусным ужином, и бегло бросаете взгляд на экран, чтобы увидеть:

```
CONFLICT (content): Merge conflict in gameEngine.java
Automatic merge failed; fix conflicts and then commit the result.
```

Или еще какой-нибудь подобный мусор.

Часы бегут и бегут, пока вы смотрите на кучу символов "<<<<<" и ">>>>>" в файле (они показывают места конфликтов в текстовом коде программы) и пытаетесь понять смысл этого всего.

Не буду врать: конфликты слияния -- это... неприятно.

В большинстве случаев хорошая система контроля исходных текстов пытается автоматически объединить простые модификации, сделанные в одном файле, с другим файлом с этим же кодом, который правил другой программист, и все работает как по волшебству.

Но... время от времени вы вносите изменение в некоторый файл в бранче, а какой-то тупой идиот-разработчик также вносит изменение в этот же файл в этом же бранче именно в тот класс, метод или функцию, который меняете вы - потому что он идиот - и теперь требуется ручное вмешательство.

Или, возможно, он не трогал ваш класс, но полностью изменил структуру этого файла, поменяв местами кучу его частей.

**Компьютер не настолько умён, чтобы понять, какое изменение в коде какому месту в файле теперь соответствует, или как правильно согласовать множество противоречивых правок одной и той же функции, и теперь всё зависит только от вас** .

Ваш вечер пятницы полностью испорчен.

Техники разрешения конфликтов мержа и тонкости слияния могут потребовать отдельной книги, поэтому здесь я не буду вдаваться в подробности.

Пока вам достаточно знать, что  **слияние в основном работает хорошо, и что когда оно не работает, возникают конфликты, которые нужно разрешать вручную** .

Да, и не делайте "простые мержи очень быстро" в пятницу вечером, прямо перед тем, как вы собираетесь уходить -- оставьте это дерьмо для утра понедельника.

### Технологии

Контроль исходных текстов имеет довольно длинную и весьма интересную историю, которую мы не будем обсуждать, потому что я обманул вас насчет интересной истории.

Достаточно сказать, что системы контроля исходных текстов развивались от передачи исходного кода на дискетах и флешках или копирования каталогов с исходными текстами на файловом сервере до довольно сложных систем, которые мы имеем сегодня.

На планете контроля исходных текстов велось много войн, и в конечном итоге победили две основные фракции:  **централизованный контроль исходных текстов, и распределенный контроль** .

Централизованный более старый. У него не так много "наворотов", но он немного проще для понимания и надёжно выполняет свою работу.

CVS и Subversion -- два примера централизованного подхода.

Распределенный подход более новый. Возможно, он более выразителен, и он немного сложнее, но всё больше людей используют именно его.

Git и Mercurial -- два примера распределенного контроля исходных текстов.

**Централизованный контроль исходных текстов**

У вас есть  **один репозиторий, размещённый на центральном сервере, который используют все разработчики** , работающие с кодом, получающие копии нужных им файлов и проверяющие изменения, внесённые в файлы.

У каждого разработчика есть клиентская программа контроля исходного кода, которая управляет взаимодействием с центральным хранилищем файлов программы.

Вся история версий и ревизии файлов хранятся в этом центральном хранилище.

Типичный рабочий процесс при использовании централизованного контроля исходных текстов может выглядеть следующим образом:

- Вы обновляете локальную копию файла с кодом, с которым работаете, загржая его из централизованного хранилища.
- Вносите в этот файл изменения.
- Фиксируете изменения файла в центральном хранилище (и разрешаете любые конфликты, если они возникли -- если, пока вы работали с файлом локально, его основную версию в хранилище обновил какой-то идиот).

**Распределённый контроль исходных текстов**

Самое важное различие данной схемы от централизованой в том, что  **каждый разработчик хранит полную копию всего репозитория на своей машине** .

Некоторые крутые хипстеры любят заявлять, что это означает "Нет никакого центрального хранилища, чувак. Тут получается, словно у всех нас есть свои собственные версии системы, и ни одна версия не главнее других".

Это попросту неверно.

Да, теоретически такое возможно, но как и куда вы собираетесь комитить код и координировать проект между несколькими разработчиками, если у вас нет какой-то единой системы записей?

Такое невозможно.

Если же вы думаете, что это возможно, то вам следует основать свой культ, или что-то в этом роде.

Реальность такова, что, да, у каждого разработчика есть своя полная копия репозитория, но вы все равно взаимодействуете с некой центральной версией, которая выступает в качестве главного репозитория проекта.

Когда вы работаете в распределенной системе контроля исходных текстов, вы просто работаете локально и делаете всё то же самое, что и в системе центрального хранилища, за исключением того, что  **вся ваша активность происходит локально** .

По сути, это означает, что вам не нужно постоянно гонять файлы по сети, и вы можете некоторое время работать вообще автономно.

В конце концов вам всё равно придётся откуда-то забирать изменения, сделанные другими людьми, и отправлять ваши прекрасные, драгоценные наработки в командный мир, чтобы они там постояли за себя.

Для этого нужно выполнять **pull (выгрузка репы локально)** и  **push (загрузка вашего кода в центральную репу)** .

Вы можете утягивать (pull down) изменения в свой локальный репозиторий, и вы можете "пушить" сделанные вами изменения в основной репозиторий, или любой другой репозиторий, который вам доступен -- включая тот самый хипстерский репозиторий, децентрализованный, якобы совершенно равный всем другим репозиториям.

### Быстрый обзор наиболее популярных систем версионного контроля

Если вы прочитаете этот материал в будущем, через месяцы или годы после лета 2021-го года, данный список, вероятно, изменится.

Новые модные горячие решения в области контроля исходных текстов появляются регулярно, потому что эта тема важна абсолютно для всех мало-мальски серьёзных команд.

Я даю вам очень краткое введение в наиболее распространенные системы контроля исходных текстов, которые вы можете встретить в природе.

**CVS**

CVS (Concurrent Versions System) -- это централизованная система контроля исходных текстов, и она довольно надежна.

Я знаю, что некоторые люди разозлятся, когда я это скажу, но, по моему мнению,  **CVS -- это предшественник Subversion** .

Она довольно мощная, но немного медленная.

Большинство организаций, ранее использовавших CVS, потом перешли на Subversion, но CVS по-прежнему имеет своих поклонников, потому что реализует некоторые вещи немного по-другому, и отдельные разработчики предпочитают именно эти различия.

Например, тегирование и организация бранчей, а также откат коммитов обрабатываются в CVS по-другому.

(Если вы не знаете, что такое тегирование, считайте, что это просто присвоение имени или ярлыка версии хранилища или элементу кодовой базы).

Фанатики CVS скажут вам, что CVS делает это правильно, а Subversion -- неправильно.

Ну, штош.

**Subversion**

Если говорить о централизованных системах контроля исходных текстов, то я считаю Subversion лучшей, хотя у неё конечно имеется ряд недостатков.

Однако в целом она хорошо выполняет свою работу и довольно проста в использовании, так что мне она нравится.

**Git**

Git стал практически синонимом контроля исходных текстов.

Спросите сегодня любого разработчика моложе 25 лет, что такое контроль исходных текстов, и он или она, скорее всего, ответит: " вы имеете в виду git?".

На это есть веская причина.

Git -- это... ну... довольно круто.

Действительно, это так.

**Git делает практически всё, что вам нужно** .

Он чрезвычайно мощный.

Основные принципы работы с ним довольно просты.

Он быстр, эффективен и универсален.

Особую популярность Git-у придал знаменитый сервис GitHub.com, который стал так популярен, что его купила Microsoft.

Он предоставляет бесплатный хостинг для проектов в исходных текстах, работа с которыми, как вы догадались, ведётся с помощью Git.

Вам определённо стоит зарегистрироваться на гихтабе, если вы ещё этого не сделали, и выкладывать туда различные ваши проекты, по которым, в частности, работодатели судят о вашей квалификации.

Ну и, конечно,  **вам однозначно надо изучить работу с git из командной строки** .

Учебник по git-у: [git-scm.com/book/ru/v2](https://git-scm.com/book/ru/v2)

Обучающая игра: [learngitbranching.js.org/](https://learngitbranching.js.org/)

Уточняющие рекомендации: [htmlacademy.ru/blog/187-git-console](https://htmlacademy.ru/blog/187-git-console)

Графические клиенты к гитхабу:

- родной [desktop.github.com/](https://desktop.github.com/)
- тоже популярный [tortoisegit.org/](https://tortoisegit.org/)

### Mercurial

[mercurial-scm.org](https://www.mercurial-scm.org/)

Почему я начал с Git-а в контексте децентрализованных систем, ведь он самый популярный на сегодня, и логично было бы рассказать о нём в последнюю очередь?

Дело в том, что Mercurial -- это как бы злой брат-близнец Git-а, который желательно рассмотреть именно в свете популярности его раскрученного брата.

В международной ИТ-тусовке обычно заявляют, что что Git похож на МакГайвера, а Mercurial -- на Джеймса Бонда.

Я не совсем понимаю, о чем они говорят или что они курят, но я вроде как тоже немного в теме.

Я бы назвал Mercurial немного более элегантным и отшлифованным, нежели Git.

Основная идея та же -- обе эти системы занимаются распределённым контролем исходных текстов.

Та же базовая функциональность и те же возможности.

Но, по моему опыту, Mercurial немного проще в использовании и освоении, в то время как Git немного более заумный, но при этом в нем побольше способов объединять вместе разную специфику.

Итак, по сути, я только что слегка описал Mercurial, сравнив его с Git.

Если вы попрактикуетесь в обоих этих системах, думаю, вы поймёте, почему я так написал.

Сравнение этих систем похоже на одну из тех бессмысленных религиозных войн.

### Это всё?

Нет, не совсем.

Основными системами контроля исходных текстов, которые используются, наверное, в 99% массовых ИТ-проектов, считаются четыре вышеописанных, причём **Git занимает огромную** - я имею в виду именно ОГРОМНУЮ -  **долю рынка** .

Да, некоторые люди используют другие системы и весело трезвонят об этом, но это большая редкость и экзотика.

Итак, теперь вы имеете представление об основах контроля исходных текстов.

Помните, что **коммитить нужно пораньше** (а не когда вы нафигачили кучу разнообразного кода к концу дня) и **коммитить нужно часто** (каждую маленькую самостоятельную фичу, которую вы добавили).

О, и, пожалуйста,  **используйте осмысленные названия комитов** .
