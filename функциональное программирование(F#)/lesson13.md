## 27. Размеченные объединения

**27.1. Размеченное объединение**

Размеченное объединение -- это тип, принимающий одно из множества явно заданных значений (тегов, идентификаторов).

Размеченное объединение задаётся как набор тегов, перечисленных через символ |.

```
type Animal = 
  | Cat
  | Dog
  | Mouse
```

Значением типа Animal может быть только одно из трёх значений: Cat, Dog или Mouse.

```
let barsik = Cat
```

**27.2. Шаблоны для размеченных объединений**

Теги могут задаваться в качестве шаблонов сопоставления.

```
let animal_tag = function
  | Cat -> "кот"
  | Dog -> "собака"
  | Mouse -> "мышь"

let animal_big = function
  | Cat | Dog -> true
  | _ -> false

animal_tag Dog // "собака" 
animal_big Dog // true
```

**27.3. Конструкторы значений**

Каждый тег дополнительно может сопровождаться связанным с ним значением любого типа, который задаётся через ключевое слово of.

```
type Animal = 
  | Cat of int
  | Dog of int
  | Mouse of float
```

Теги в размеченном объединении, дополненные связанным типом -- это функции, называемые конструкторы значений.

Конструктор значений получает в качестве аргумента значение связанного с тегом типа, и создаёт соответствующий объект из двух элементов (тег и значение).

```
let barsik = Cat 5
let mike = Mouse (3.14 - 2.78)
```

Значения размеченных объединений можно сравнивать друг с другом.

```
let barsik = Cat 5
let barsik2 = Cat (25 / 5)
let mike = Mouse (3.14 - 2.78)

barsik = barsik2 // true
barsik > barsik2 // false
barsik = mike // false
```

Теги, указанные в описании типа позже, считаются большими, чем предыдущие теги.

```
printfn "%b" (mike > barsik2)// true
```

**27.4. Шаблоны для конструкторов значений**

Конструкторы значений можно использовать в сопоставлении в качестве шаблонов, но проверяются они не по значению, а по своему имени (тегу).

```
type Animal = 
  | Cat of int
  | Dog of int
  | Mouse of int * int

let animal_age = function
  | Cat a -> a * 7
  | Dog b -> b * 4
  | Mouse (c,d) -> c * d

printfn "%d" (animal_age (Mouse (2,3))) // 6
```

**27.5. Задание**

Реализуйте задание 24.4, в котором половина дня представлена не строкой, а размеченным объединением F.

Шаблон для отправки на сервер:

```
type F = 
  | AM
  | PM

type TimeOfDay = { hours : int; minutes : int; f: F }

let (.>.) x y = ...
```

**[[ предыдущее ]](https://skillsmart.ru/fp/fsh/f94ee11c69.html)**

---

**Ответы на задания 24**

```
type TimeOfDay = { hours: int; minutes: int; f: string }

let transform (x: TimeOfDay) = 
    if x.f = "PM" then (x.hours + 12) * 60 + x.minutes
    else x.hours * 60 + x.minutes

let (.>.) x y = (transform x) > (transform y)
```
