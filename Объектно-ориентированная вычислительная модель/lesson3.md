## Инкапсулированное состояние и наследование

Классическая область ООП возникла как сочетание инкапсуляции, явного состояния и наследования. В этой области была разработана богатая теория и множество практик на тему "как писать stateful-программы с использованием наследования". Однако со временем возник явный перебор: сильная концепция "всё есть объект" из языка Smalltalk, насильственно привитая языкам мэйнстрима, стала и существенным их ограничением из-за смешения понятий состояния и инкапсуляции. Современные объектно-ориентированные языки чрезмерно игнорируют преимущества, которые можно получить, применяя другие сущности, отличные от объектов, и используя инкапсуляцию без состояния. Далее мы подробно рассмотрим эти моменты.

Засада в том, что большинство объектно-ориентированных языков программирования по умолчанию считают, что АТД должен иметь явное состояние -- даже Smalltalk, не говоря уже о C++ и Java.

Явное состояние -- сложное понятие, и оно не должно быть первым понятием, которому учат программистов с нуля. Существуют более простые приёмы программирования, которые мы рассматривали на предыдущих курсах: например, использование идентификаторов для ссылки на значения, или dataflow-переменные. Все эти более простые способы должны быть изучены прежде, чем совершится переход к работе с явным состоянием.


## Объекты и классы

Объект -- это сущность, которая инкапсулирует состояние таким образом, что доступ к нему за границами объекта может быть получен только контролируемым образом -- с помощью методов, которые представляют собой процедуры, доступные извне, и которые могут внутри объекта непосредственно обращаться к внутреннему состоянию. Единственный способ изменить состояние объекта -- это вызвать соответствующий метод. Это гарантирует, что состояние объекта всегда удовлетворяет некоторому инвариантному свойству.

Класс -- это сущность, которая определяет объект некоторым "постепенным" способом (разными кусочками). Объект в смысле экземпляра класса определяется классами, от которых он наследуется, и тем, чем он отличается от прямых предков. Большинство современных языков поддерживают концепцию классов как лингвистическую абстракцию, чаще всего через простую, но мощную синтаксическую конструкцию class.


## 2. Классы как полноценные АТД

**Основа концепции объекта -- контролируемый доступ к инкапсулированным данным** .

Поведение объекта задается классом. В самом общем случае  **класс -- это (частичное) определение АТД в виде модификации других АТД** .

Богатый набор понятий для определения классов классифицируется двумя схемами -- в зависимости от того, позволяется ли классу определять АТД только полностью, или постепенно/частично.

**Полное определение АТД** . Тут, в свою очередь, два подхода.
-- Конструирование класса из методов, свойств и атрибутов. Атрибуты могут инициализироваться с привязкой либо к объекту, либо к классу.
-- Использование динамической типизации (сообщения первого класса и атрибуты первого класса, см. далее). Становятся доступными мощные формы полиморфизма, которые очень трудно или вообще невозможно реализовать в языках со статической типизацией. Расплатой же за такую свободу становится заметно возрастающая вероятность довольно простых ошибок, связанных с проcтой невнимательностью (в предыдущем подходе такие ошибки ловит компилятор или тайп-чекер).

**Постепенное определение АТД** . Тут -- все концепции, связанные с наследованием (как класс связан с другими классами).


### 2. Классы и АТД

======= 8. Объект -- это сущность, которая ...

[ ] поддерживает состояние, предлагая свободный доступ к нему

[ 1] инкапсулирует состояние, контролируя доступ через методы

[ ] инкапсулирует состояние, контролируя его через инвариант

======= 9. Класс -- это сущность, которая определяет объект

[ ] целиком и полностью

[ ] через лингвистическую абстракцию

[1 ] "постепенным" способом по кусочкам

======= 10. Класс -- это ...

[ ] полное автономное определение АТД

[ 1] частичное определение АТД через модификацию других АТД
